"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/mime/Mime.js
  var require_Mime = __commonJS({
    "node_modules/mime/Mime.js"(exports, module) {
      "use strict";
      function Mime() {
        this._types = /* @__PURE__ */ Object.create(null);
        this._extensions = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < arguments.length; i++) {
          this.define(arguments[i]);
        }
        this.define = this.define.bind(this);
        this.getType = this.getType.bind(this);
        this.getExtension = this.getExtension.bind(this);
      }
      Mime.prototype.define = function(typeMap, force) {
        for (let type in typeMap) {
          let extensions = typeMap[type].map(function(t) {
            return t.toLowerCase();
          });
          type = type.toLowerCase();
          for (let i = 0; i < extensions.length; i++) {
            const ext = extensions[i];
            if (ext[0] === "*") {
              continue;
            }
            if (!force && ext in this._types) {
              throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
            }
            this._types[ext] = type;
          }
          if (force || !this._extensions[type]) {
            const ext = extensions[0];
            this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
          }
        }
      };
      Mime.prototype.getType = function(path) {
        path = String(path);
        let last = path.replace(/^.*[/\\]/, "").toLowerCase();
        let ext = last.replace(/^.*\./, "").toLowerCase();
        let hasPath = last.length < path.length;
        let hasDot = ext.length < last.length - 1;
        return (hasDot || !hasPath) && this._types[ext] || null;
      };
      Mime.prototype.getExtension = function(type) {
        type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
        return type && this._extensions[type.toLowerCase()] || null;
      };
      module.exports = Mime;
    }
  });

  // node_modules/mime/types/standard.js
  var require_standard = __commonJS({
    "node_modules/mime/types/standard.js"(exports, module) {
      module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
    }
  });

  // node_modules/mime/types/other.js
  var require_other = __commonJS({
    "node_modules/mime/types/other.js"(exports, module) {
      module.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
    }
  });

  // node_modules/mime/index.js
  var require_mime = __commonJS({
    "node_modules/mime/index.js"(exports, module) {
      "use strict";
      var Mime = require_Mime();
      module.exports = new Mime(require_standard(), require_other());
    }
  });

  // node_modules/@cloudflare/kv-asset-handler/dist/types.js
  var require_types = __commonJS({
    "node_modules/@cloudflare/kv-asset-handler/dist/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InternalError = exports.NotFoundError = exports.MethodNotAllowedError = exports.KVError = void 0;
      var KVError = class extends Error {
        constructor(message, status = 500) {
          super(message);
          Object.setPrototypeOf(this, new.target.prototype);
          this.name = KVError.name;
          this.status = status;
        }
      };
      exports.KVError = KVError;
      var MethodNotAllowedError2 = class extends KVError {
        constructor(message = `Not a valid request method`, status = 405) {
          super(message, status);
        }
      };
      exports.MethodNotAllowedError = MethodNotAllowedError2;
      var NotFoundError2 = class extends KVError {
        constructor(message = `Not Found`, status = 404) {
          super(message, status);
        }
      };
      exports.NotFoundError = NotFoundError2;
      var InternalError = class extends KVError {
        constructor(message = `Internal Error in KV Asset Handler`, status = 500) {
          super(message, status);
        }
      };
      exports.InternalError = InternalError;
    }
  });

  // node_modules/@cloudflare/kv-asset-handler/dist/index.js
  var require_dist = __commonJS({
    "node_modules/@cloudflare/kv-asset-handler/dist/index.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InternalError = exports.NotFoundError = exports.MethodNotAllowedError = exports.serveSinglePageApp = exports.mapRequestToAsset = exports.getAssetFromKV = void 0;
      var mime = require_mime();
      var types_1 = require_types();
      Object.defineProperty(exports, "MethodNotAllowedError", { enumerable: true, get: function() {
        return types_1.MethodNotAllowedError;
      } });
      Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
        return types_1.NotFoundError;
      } });
      Object.defineProperty(exports, "InternalError", { enumerable: true, get: function() {
        return types_1.InternalError;
      } });
      var defaultCacheControl = {
        browserTTL: null,
        edgeTTL: 2 * 60 * 60 * 24,
        bypassCache: false
      };
      var parseStringAsObject = (maybeString) => typeof maybeString === "string" ? JSON.parse(maybeString) : maybeString;
      var getAssetFromKVDefaultOptions = {
        ASSET_NAMESPACE: typeof __STATIC_CONTENT !== "undefined" ? __STATIC_CONTENT : void 0,
        ASSET_MANIFEST: typeof __STATIC_CONTENT_MANIFEST !== "undefined" ? parseStringAsObject(__STATIC_CONTENT_MANIFEST) : void 0,
        cacheControl: defaultCacheControl,
        defaultMimeType: "text/plain",
        defaultDocument: "index.html"
      };
      function assignOptions(options) {
        return Object.assign({}, getAssetFromKVDefaultOptions, options);
      }
      var mapRequestToAsset = (request, options) => {
        options = assignOptions(options);
        const parsedUrl = new URL(request.url);
        let pathname = parsedUrl.pathname;
        if (pathname.endsWith("/")) {
          pathname = pathname.concat(options.defaultDocument);
        } else if (!mime.getType(pathname)) {
          pathname = pathname.concat("/" + options.defaultDocument);
        }
        parsedUrl.pathname = pathname;
        return new Request(parsedUrl.toString(), request);
      };
      exports.mapRequestToAsset = mapRequestToAsset;
      function serveSinglePageApp(request, options) {
        options = assignOptions(options);
        request = mapRequestToAsset(request, options);
        const parsedUrl = new URL(request.url);
        if (parsedUrl.pathname.endsWith(".html")) {
          return new Request(`${parsedUrl.origin}/${options.defaultDocument}`, request);
        } else {
          return request;
        }
      }
      exports.serveSinglePageApp = serveSinglePageApp;
      var getAssetFromKV2 = (event, options) => __awaiter(void 0, void 0, void 0, function* () {
        options = assignOptions(options);
        const request = event.request;
        const ASSET_NAMESPACE = options.ASSET_NAMESPACE;
        const ASSET_MANIFEST = parseStringAsObject(options.ASSET_MANIFEST);
        if (typeof ASSET_NAMESPACE === "undefined") {
          throw new types_1.InternalError(`there is no KV namespace bound to the script`);
        }
        const rawPathKey = new URL(request.url).pathname.replace(/^\/+/, "");
        let pathIsEncoded = false;
        let requestKey;
        if (options.mapRequestToAsset) {
          requestKey = options.mapRequestToAsset(request);
        } else if (ASSET_MANIFEST[rawPathKey]) {
          requestKey = request;
        } else if (ASSET_MANIFEST[decodeURIComponent(rawPathKey)]) {
          pathIsEncoded = true;
          requestKey = request;
        } else {
          const mappedRequest = mapRequestToAsset(request);
          const mappedRawPathKey = new URL(mappedRequest.url).pathname.replace(/^\/+/, "");
          if (ASSET_MANIFEST[decodeURIComponent(mappedRawPathKey)]) {
            pathIsEncoded = true;
            requestKey = mappedRequest;
          } else {
            requestKey = mapRequestToAsset(request, options);
          }
        }
        const SUPPORTED_METHODS = ["GET", "HEAD"];
        if (!SUPPORTED_METHODS.includes(requestKey.method)) {
          throw new types_1.MethodNotAllowedError(`${requestKey.method} is not a valid request method`);
        }
        const parsedUrl = new URL(requestKey.url);
        const pathname = pathIsEncoded ? decodeURIComponent(parsedUrl.pathname) : parsedUrl.pathname;
        let pathKey = pathname.replace(/^\/+/, "");
        const cache = caches.default;
        let mimeType = mime.getType(pathKey) || options.defaultMimeType;
        if (mimeType.startsWith("text") || mimeType === "application/javascript") {
          mimeType += "; charset=utf-8";
        }
        let shouldEdgeCache = false;
        if (typeof ASSET_MANIFEST !== "undefined") {
          if (ASSET_MANIFEST[pathKey]) {
            pathKey = ASSET_MANIFEST[pathKey];
            shouldEdgeCache = true;
          }
        }
        let cacheKey = new Request(`${parsedUrl.origin}/${pathKey}`, request);
        const evalCacheOpts = (() => {
          switch (typeof options.cacheControl) {
            case "function":
              return options.cacheControl(request);
            case "object":
              return options.cacheControl;
            default:
              return defaultCacheControl;
          }
        })();
        const formatETag = (entityId = pathKey, validatorType = "strong") => {
          if (!entityId) {
            return "";
          }
          switch (validatorType) {
            case "weak":
              if (!entityId.startsWith("W/")) {
                return `W/${entityId}`;
              }
              return entityId;
            case "strong":
              if (entityId.startsWith(`W/"`)) {
                entityId = entityId.replace("W/", "");
              }
              if (!entityId.endsWith(`"`)) {
                entityId = `"${entityId}"`;
              }
              return entityId;
            default:
              return "";
          }
        };
        options.cacheControl = Object.assign({}, defaultCacheControl, evalCacheOpts);
        if (options.cacheControl.bypassCache || options.cacheControl.edgeTTL === null || request.method == "HEAD") {
          shouldEdgeCache = false;
        }
        const shouldSetBrowserCache = typeof options.cacheControl.browserTTL === "number";
        let response = null;
        if (shouldEdgeCache) {
          response = yield cache.match(cacheKey);
        }
        if (response) {
          if (response.status > 300 && response.status < 400) {
            if (response.body && "cancel" in Object.getPrototypeOf(response.body)) {
              response.body.cancel();
              console.log("Body exists and environment supports readable streams. Body cancelled");
            } else {
              console.log("Environment doesnt support readable streams");
            }
            response = new Response(null, response);
          } else {
            let opts = {
              headers: new Headers(response.headers),
              status: 0,
              statusText: ""
            };
            opts.headers.set("cf-cache-status", "HIT");
            if (response.status) {
              opts.status = response.status;
              opts.statusText = response.statusText;
            } else if (opts.headers.has("Content-Range")) {
              opts.status = 206;
              opts.statusText = "Partial Content";
            } else {
              opts.status = 200;
              opts.statusText = "OK";
            }
            response = new Response(response.body, opts);
          }
        } else {
          const body = yield ASSET_NAMESPACE.get(pathKey, "arrayBuffer");
          if (body === null) {
            throw new types_1.NotFoundError(`could not find ${pathKey} in your content namespace`);
          }
          response = new Response(body);
          if (shouldEdgeCache) {
            response.headers.set("Accept-Ranges", "bytes");
            response.headers.set("Content-Length", body.length);
            if (!response.headers.has("etag")) {
              response.headers.set("etag", formatETag(pathKey, "strong"));
            }
            response.headers.set("Cache-Control", `max-age=${options.cacheControl.edgeTTL}`);
            event.waitUntil(cache.put(cacheKey, response.clone()));
            response.headers.set("CF-Cache-Status", "MISS");
          }
        }
        response.headers.set("Content-Type", mimeType);
        if (response.status === 304) {
          let etag = formatETag(response.headers.get("etag"), "strong");
          let ifNoneMatch = cacheKey.headers.get("if-none-match");
          let proxyCacheStatus = response.headers.get("CF-Cache-Status");
          if (etag) {
            if (ifNoneMatch && ifNoneMatch === etag && proxyCacheStatus === "MISS") {
              response.headers.set("CF-Cache-Status", "EXPIRED");
            } else {
              response.headers.set("CF-Cache-Status", "REVALIDATED");
            }
            response.headers.set("etag", formatETag(etag, "weak"));
          }
        }
        if (shouldSetBrowserCache) {
          response.headers.set("Cache-Control", `max-age=${options.cacheControl.browserTTL}`);
        } else {
          response.headers.delete("Cache-Control");
        }
        return response;
      });
      exports.getAssetFromKV = getAssetFromKV2;
    }
  });

  // node_modules/cookie/index.js
  var require_cookie = __commonJS({
    "node_modules/cookie/index.js"(exports) {
      "use strict";
      exports.parse = parse;
      exports.serialize = serialize;
      var decode = decodeURIComponent;
      var encode = encodeURIComponent;
      var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
      function parse(str, options) {
        if (typeof str !== "string") {
          throw new TypeError("argument str must be a string");
        }
        var obj = {};
        var opt = options || {};
        var pairs = str.split(";");
        var dec = opt.decode || decode;
        for (var i = 0; i < pairs.length; i++) {
          var pair = pairs[i];
          var index = pair.indexOf("=");
          if (index < 0) {
            continue;
          }
          var key = pair.substring(0, index).trim();
          if (obj[key] == void 0) {
            var val = pair.substring(index + 1, pair.length).trim();
            if (val[0] === '"') {
              val = val.slice(1, -1);
            }
            obj[key] = tryDecode(val, dec);
          }
        }
        return obj;
      }
      function serialize(name, val, options) {
        var opt = options || {};
        var enc = opt.encode || encode;
        if (typeof enc !== "function") {
          throw new TypeError("option encode is invalid");
        }
        if (!fieldContentRegExp.test(name)) {
          throw new TypeError("argument name is invalid");
        }
        var value = enc(val);
        if (value && !fieldContentRegExp.test(value)) {
          throw new TypeError("argument val is invalid");
        }
        var str = name + "=" + value;
        if (opt.maxAge != null) {
          var maxAge = opt.maxAge - 0;
          if (isNaN(maxAge) || !isFinite(maxAge)) {
            throw new TypeError("option maxAge is invalid");
          }
          str += "; Max-Age=" + Math.floor(maxAge);
        }
        if (opt.domain) {
          if (!fieldContentRegExp.test(opt.domain)) {
            throw new TypeError("option domain is invalid");
          }
          str += "; Domain=" + opt.domain;
        }
        if (opt.path) {
          if (!fieldContentRegExp.test(opt.path)) {
            throw new TypeError("option path is invalid");
          }
          str += "; Path=" + opt.path;
        }
        if (opt.expires) {
          if (typeof opt.expires.toUTCString !== "function") {
            throw new TypeError("option expires is invalid");
          }
          str += "; Expires=" + opt.expires.toUTCString();
        }
        if (opt.httpOnly) {
          str += "; HttpOnly";
        }
        if (opt.secure) {
          str += "; Secure";
        }
        if (opt.sameSite) {
          var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
          switch (sameSite) {
            case true:
              str += "; SameSite=Strict";
              break;
            case "lax":
              str += "; SameSite=Lax";
              break;
            case "strict":
              str += "; SameSite=Strict";
              break;
            case "none":
              str += "; SameSite=None";
              break;
            default:
              throw new TypeError("option sameSite is invalid");
          }
        }
        return str;
      }
      function tryDecode(str, decode2) {
        try {
          return decode2(str);
        } catch (e) {
          return str;
        }
      }
    }
  });

  // node_modules/@remix-run/server-runtime/warnings.js
  var require_warnings = __commonJS({
    "node_modules/@remix-run/server-runtime/warnings.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var alreadyWarned = {};
      function warnOnce(condition, message) {
        if (!condition && !alreadyWarned[message]) {
          alreadyWarned[message] = true;
          console.warn(message);
        }
      }
      exports.warnOnce = warnOnce;
    }
  });

  // node_modules/@remix-run/server-runtime/cookies.js
  var require_cookies = __commonJS({
    "node_modules/@remix-run/server-runtime/cookies.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var cookie = require_cookie();
      var warnings = require_warnings();
      var createCookieFactory = ({
        sign,
        unsign
      }) => (name, cookieOptions = {}) => {
        let {
          secrets,
          ...options
        } = {
          secrets: [],
          path: "/",
          sameSite: "lax",
          ...cookieOptions
        };
        warnOnceAboutExpiresCookie(name, options.expires);
        return {
          get name() {
            return name;
          },
          get isSigned() {
            return secrets.length > 0;
          },
          get expires() {
            return typeof options.maxAge !== "undefined" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;
          },
          async parse(cookieHeader, parseOptions) {
            if (!cookieHeader)
              return null;
            let cookies = cookie.parse(cookieHeader, {
              ...options,
              ...parseOptions
            });
            return name in cookies ? cookies[name] === "" ? "" : await decodeCookieValue(unsign, cookies[name], secrets) : null;
          },
          async serialize(value, serializeOptions) {
            return cookie.serialize(name, value === "" ? "" : await encodeCookieValue(sign, value, secrets), {
              ...options,
              ...serializeOptions
            });
          }
        };
      };
      var isCookie2 = (object2) => {
        return object2 != null && typeof object2.name === "string" && typeof object2.isSigned === "boolean" && typeof object2.parse === "function" && typeof object2.serialize === "function";
      };
      async function encodeCookieValue(sign, value, secrets) {
        let encoded = encodeData(value);
        if (secrets.length > 0) {
          encoded = await sign(encoded, secrets[0]);
        }
        return encoded;
      }
      async function decodeCookieValue(unsign, value, secrets) {
        if (secrets.length > 0) {
          for (let secret of secrets) {
            let unsignedValue = await unsign(value, secret);
            if (unsignedValue !== false) {
              return decodeData(unsignedValue);
            }
          }
          return null;
        }
        return decodeData(value);
      }
      function encodeData(value) {
        return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));
      }
      function decodeData(value) {
        try {
          return JSON.parse(decodeURIComponent(myEscape(atob(value))));
        } catch (error) {
          return {};
        }
      }
      function myEscape(value) {
        let str = value.toString();
        let result = "";
        let index = 0;
        let chr, code;
        while (index < str.length) {
          chr = str.charAt(index++);
          if (/[\w*+\-./@]/.exec(chr)) {
            result += chr;
          } else {
            code = chr.charCodeAt(0);
            if (code < 256) {
              result += "%" + hex(code, 2);
            } else {
              result += "%u" + hex(code, 4).toUpperCase();
            }
          }
        }
        return result;
      }
      function hex(code, length) {
        let result = code.toString(16);
        while (result.length < length)
          result = "0" + result;
        return result;
      }
      function myUnescape(value) {
        let str = value.toString();
        let result = "";
        let index = 0;
        let chr, part;
        while (index < str.length) {
          chr = str.charAt(index++);
          if (chr === "%") {
            if (str.charAt(index) === "u") {
              part = str.slice(index + 1, index + 5);
              if (/^[\da-f]{4}$/i.exec(part)) {
                result += String.fromCharCode(parseInt(part, 16));
                index += 5;
                continue;
              }
            } else {
              part = str.slice(index, index + 2);
              if (/^[\da-f]{2}$/i.exec(part)) {
                result += String.fromCharCode(parseInt(part, 16));
                index += 2;
                continue;
              }
            }
          }
          result += chr;
        }
        return result;
      }
      function warnOnceAboutExpiresCookie(name, expires) {
        warnings.warnOnce(!expires, `The "${name}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`);
      }
      exports.createCookieFactory = createCookieFactory;
      exports.isCookie = isCookie2;
    }
  });

  // node_modules/@web3-storage/multipart-parser/esm/src/utils.js
  function stringToArray(s) {
    const utf8 = unescape(encodeURIComponent(s));
    return Uint8Array.from(utf8, (_, i) => utf8.charCodeAt(i));
  }
  function arrayToString(a) {
    const utf8 = String.fromCharCode.apply(null, a);
    return decodeURIComponent(escape(utf8));
  }
  function mergeArrays(...arrays) {
    const out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0));
    let offset = 0;
    for (const arr of arrays) {
      out.set(arr, offset);
      offset += arr.length;
    }
    return out;
  }
  function arraysEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  var init_utils = __esm({
    "node_modules/@web3-storage/multipart-parser/esm/src/utils.js"() {
    }
  });

  // node_modules/@web3-storage/multipart-parser/esm/src/search.js
  function coerce(a) {
    if (a instanceof Uint8Array) {
      return (index) => a[index];
    }
    return a;
  }
  function jsmemcmp(buf1, pos1, buf2, pos2, len) {
    const fn1 = coerce(buf1);
    const fn2 = coerce(buf2);
    for (let i = 0; i < len; ++i) {
      if (fn1(pos1 + i) !== fn2(pos2 + i)) {
        return false;
      }
    }
    return true;
  }
  function createOccurenceTable(s) {
    const table = new Array(256).fill(s.length);
    if (s.length > 1) {
      for (let i = 0; i < s.length - 1; i++) {
        table[s[i]] = s.length - 1 - i;
      }
    }
    return table;
  }
  var MATCH, StreamSearch, ReadableStreamSearch, EOQ, QueueableStreamSearch;
  var init_search = __esm({
    "node_modules/@web3-storage/multipart-parser/esm/src/search.js"() {
      init_utils();
      MATCH = Symbol("Match");
      StreamSearch = class {
        constructor(needle) {
          this._lookbehind = new Uint8Array();
          if (typeof needle === "string") {
            this._needle = needle = stringToArray(needle);
          } else {
            this._needle = needle;
          }
          this._lastChar = needle[needle.length - 1];
          this._occ = createOccurenceTable(needle);
        }
        feed(chunk) {
          let pos = 0;
          let tokens;
          const allTokens = [];
          while (pos !== chunk.length) {
            ;
            [pos, ...tokens] = this._feed(chunk, pos);
            allTokens.push(...tokens);
          }
          return allTokens;
        }
        end() {
          const tail = this._lookbehind;
          this._lookbehind = new Uint8Array();
          return tail;
        }
        _feed(data, bufPos) {
          const tokens = [];
          let pos = -this._lookbehind.length;
          if (pos < 0) {
            while (pos < 0 && pos <= data.length - this._needle.length) {
              const ch = this._charAt(data, pos + this._needle.length - 1);
              if (ch === this._lastChar && this._memcmp(data, pos, this._needle.length - 1)) {
                if (pos > -this._lookbehind.length) {
                  tokens.push(this._lookbehind.slice(0, this._lookbehind.length + pos));
                }
                tokens.push(MATCH);
                this._lookbehind = new Uint8Array();
                return [
                  pos + this._needle.length,
                  ...tokens
                ];
              } else {
                pos += this._occ[ch];
              }
            }
            if (pos < 0) {
              while (pos < 0 && !this._memcmp(data, pos, data.length - pos)) {
                pos++;
              }
            }
            if (pos >= 0) {
              tokens.push(this._lookbehind);
              this._lookbehind = new Uint8Array();
            } else {
              const bytesToCutOff = this._lookbehind.length + pos;
              if (bytesToCutOff > 0) {
                tokens.push(this._lookbehind.slice(0, bytesToCutOff));
                this._lookbehind = this._lookbehind.slice(bytesToCutOff);
              }
              this._lookbehind = Uint8Array.from(new Array(this._lookbehind.length + data.length), (_, i) => this._charAt(data, i - this._lookbehind.length));
              return [
                data.length,
                ...tokens
              ];
            }
          }
          pos += bufPos;
          while (pos <= data.length - this._needle.length) {
            const ch = data[pos + this._needle.length - 1];
            if (ch === this._lastChar && data[pos] === this._needle[0] && jsmemcmp(this._needle, 0, data, pos, this._needle.length - 1)) {
              if (pos > bufPos) {
                tokens.push(data.slice(bufPos, pos));
              }
              tokens.push(MATCH);
              return [
                pos + this._needle.length,
                ...tokens
              ];
            } else {
              pos += this._occ[ch];
            }
          }
          if (pos < data.length) {
            while (pos < data.length && (data[pos] !== this._needle[0] || !jsmemcmp(data, pos, this._needle, 0, data.length - pos))) {
              ++pos;
            }
            if (pos < data.length) {
              this._lookbehind = data.slice(pos);
            }
          }
          if (pos > 0) {
            tokens.push(data.slice(bufPos, pos < data.length ? pos : data.length));
          }
          return [
            data.length,
            ...tokens
          ];
        }
        _charAt(data, pos) {
          if (pos < 0) {
            return this._lookbehind[this._lookbehind.length + pos];
          }
          return data[pos];
        }
        _memcmp(data, pos, len) {
          return jsmemcmp(this._charAt.bind(this, data), pos, this._needle, 0, len);
        }
      };
      ReadableStreamSearch = class {
        constructor(needle, _readableStream) {
          this._readableStream = _readableStream;
          this._search = new StreamSearch(needle);
        }
        async *[Symbol.asyncIterator]() {
          const reader = this._readableStream.getReader();
          try {
            while (true) {
              const result = await reader.read();
              if (result.done) {
                break;
              }
              yield* this._search.feed(result.value);
            }
            const tail = this._search.end();
            if (tail.length) {
              yield tail;
            }
          } finally {
            reader.releaseLock();
          }
        }
      };
      EOQ = Symbol("End of Queue");
      QueueableStreamSearch = class {
        constructor(needle) {
          this._chunksQueue = [];
          this._closed = false;
          this._search = new StreamSearch(needle);
        }
        push(...chunks) {
          if (this._closed) {
            throw new Error("cannot call push after close");
          }
          this._chunksQueue.push(...chunks);
          if (this._notify) {
            this._notify();
          }
        }
        close() {
          if (this._closed) {
            throw new Error("close was already called");
          }
          this._closed = true;
          this._chunksQueue.push(EOQ);
          if (this._notify) {
            this._notify();
          }
        }
        async *[Symbol.asyncIterator]() {
          while (true) {
            let chunk;
            while (!(chunk = this._chunksQueue.shift())) {
              await new Promise((resolve) => this._notify = resolve);
              this._notify = void 0;
            }
            if (chunk === EOQ) {
              break;
            }
            yield* this._search.feed(chunk);
          }
          const tail = this._search.end();
          if (tail.length) {
            yield tail;
          }
        }
      };
    }
  });

  // node_modules/@web3-storage/multipart-parser/esm/src/index.js
  var src_exports = {};
  __export(src_exports, {
    iterateMultipart: () => iterateMultipart,
    streamMultipart: () => streamMultipart
  });
  function parseContentDisposition(header) {
    const parts = header.split(";").map((part) => part.trim());
    if (parts.shift() !== "form-data") {
      throw new Error('malformed content-disposition header: missing "form-data" in `' + JSON.stringify(parts) + "`");
    }
    const out = {};
    for (const part of parts) {
      const kv = part.split("=", 2);
      if (kv.length !== 2) {
        throw new Error("malformed content-disposition header: key-value pair not found - " + part + " in `" + header + "`");
      }
      const [name, value] = kv;
      if (value[0] === '"' && value[value.length - 1] === '"') {
        out[name] = value.slice(1, -1).replace(/\\"/g, '"');
      } else if (value[0] !== '"' && value[value.length - 1] !== '"') {
        out[name] = value;
      } else if (value[0] === '"' && value[value.length - 1] !== '"' || value[0] !== '"' && value[value.length - 1] === '"') {
        throw new Error("malformed content-disposition header: mismatched quotations in `" + header + "`");
      }
    }
    if (!out.name) {
      throw new Error("malformed content-disposition header: missing field name in `" + header + "`");
    }
    return out;
  }
  function parsePartHeaders(lines) {
    const entries = [];
    let disposition = false;
    let line;
    while (typeof (line = lines.shift()) !== "undefined") {
      const colon = line.indexOf(":");
      if (colon === -1) {
        throw new Error("malformed multipart-form header: missing colon");
      }
      const header = line.slice(0, colon).trim().toLowerCase();
      const value = line.slice(colon + 1).trim();
      switch (header) {
        case "content-disposition":
          disposition = true;
          entries.push(...Object.entries(parseContentDisposition(value)));
          break;
        case "content-type":
          entries.push([
            "contentType",
            value
          ]);
      }
    }
    if (!disposition) {
      throw new Error("malformed multipart-form header: missing content-disposition");
    }
    return Object.fromEntries(entries);
  }
  async function readHeaderLines(it, needle) {
    let firstChunk = true;
    let lastTokenWasMatch = false;
    const headerLines = [[]];
    const crlfSearch = new StreamSearch(CRLF);
    for (; ; ) {
      const result = await it.next();
      if (result.done) {
        throw new Error("malformed multipart-form data: unexpected end of stream");
      }
      if (firstChunk && result.value !== MATCH && arraysEqual(result.value.slice(0, 2), dash)) {
        return [
          void 0,
          new Uint8Array()
        ];
      }
      let chunk;
      if (result.value !== MATCH) {
        chunk = result.value;
      } else if (!lastTokenWasMatch) {
        chunk = needle;
      } else {
        throw new Error("malformed multipart-form data: unexpected boundary");
      }
      if (!chunk.length) {
        continue;
      }
      if (firstChunk) {
        firstChunk = false;
      }
      const tokens = crlfSearch.feed(chunk);
      for (const [i, token] of tokens.entries()) {
        const isMatch = token === MATCH;
        if (!isMatch && !token.length) {
          continue;
        }
        if (lastTokenWasMatch && isMatch) {
          tokens.push(crlfSearch.end());
          return [
            headerLines.filter((chunks) => chunks.length).map(mergeArrays2).map(arrayToString),
            mergeArrays(...tokens.slice(i + 1).map((token2) => token2 === MATCH ? CRLF : token2))
          ];
        }
        if (lastTokenWasMatch = isMatch) {
          headerLines.push([]);
        } else {
          headerLines[headerLines.length - 1].push(token);
        }
      }
    }
  }
  async function* streamMultipart(body, boundary) {
    const needle = mergeArrays(dash, stringToArray(boundary));
    const it = new ReadableStreamSearch(needle, body)[Symbol.asyncIterator]();
    for (; ; ) {
      const result = await it.next();
      if (result.done) {
        return;
      }
      if (result.value === MATCH) {
        break;
      }
    }
    const crlfSearch = new StreamSearch(CRLF);
    for (; ; ) {
      let feedChunk = function(chunk) {
        const chunks = [];
        for (const token of crlfSearch.feed(chunk)) {
          if (trailingCRLF) {
            chunks.push(CRLF);
          }
          if (!(trailingCRLF = token === MATCH)) {
            chunks.push(token);
          }
        }
        return mergeArrays(...chunks);
      };
      const [headerLines, tail] = await readHeaderLines(it, needle);
      if (!headerLines) {
        return;
      }
      async function nextToken() {
        const result = await it.next();
        if (result.done) {
          throw new Error("malformed multipart-form data: unexpected end of stream");
        }
        return result;
      }
      let trailingCRLF = false;
      let done = false;
      async function nextChunk() {
        const result = await nextToken();
        let chunk;
        if (result.value !== MATCH) {
          chunk = result.value;
        } else if (!trailingCRLF) {
          chunk = CRLF;
        } else {
          done = true;
          return { value: crlfSearch.end() };
        }
        return { value: feedChunk(chunk) };
      }
      const bufferedChunks = [{ value: feedChunk(tail) }];
      yield {
        ...parsePartHeaders(headerLines),
        data: {
          [Symbol.asyncIterator]() {
            return this;
          },
          async next() {
            for (; ; ) {
              const result = bufferedChunks.shift();
              if (!result) {
                break;
              }
              if (result.value.length > 0) {
                return result;
              }
            }
            for (; ; ) {
              if (done) {
                return {
                  done,
                  value: void 0
                };
              }
              const result = await nextChunk();
              if (result.value.length > 0) {
                return result;
              }
            }
          }
        }
      };
      while (!done) {
        bufferedChunks.push(await nextChunk());
      }
    }
  }
  async function* iterateMultipart(body, boundary) {
    for await (const part of streamMultipart(body, boundary)) {
      const chunks = [];
      for await (const chunk of part.data) {
        chunks.push(chunk);
      }
      yield {
        ...part,
        data: mergeArrays(...chunks)
      };
    }
  }
  var mergeArrays2, dash, CRLF;
  var init_src = __esm({
    "node_modules/@web3-storage/multipart-parser/esm/src/index.js"() {
      init_search();
      init_utils();
      mergeArrays2 = Function.prototype.apply.bind(mergeArrays, void 0);
      dash = stringToArray("--");
      CRLF = stringToArray("\r\n");
    }
  });

  // node_modules/@remix-run/server-runtime/formData.js
  var require_formData = __commonJS({
    "node_modules/@remix-run/server-runtime/formData.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var multipartParser = (init_src(), __toCommonJS(src_exports));
      function composeUploadHandlers(...handlers) {
        return async (part) => {
          for (let handler of handlers) {
            let value = await handler(part);
            if (typeof value !== "undefined" && value !== null) {
              return value;
            }
          }
          return void 0;
        };
      }
      async function parseMultipartFormData(request, uploadHandler) {
        let contentType = request.headers.get("Content-Type") || "";
        let [type, boundary] = contentType.split(/\s*;\s*boundary=/);
        if (!request.body || !boundary || type !== "multipart/form-data") {
          throw new TypeError("Could not parse content as FormData.");
        }
        let formData = new FormData();
        let parts = multipartParser.streamMultipart(request.body, boundary);
        for await (let part of parts) {
          if (part.done)
            break;
          if (typeof part.filename === "string") {
            part.filename = part.filename.split(/[/\\]/).pop();
          }
          let value = await uploadHandler(part);
          if (typeof value !== "undefined" && value !== null) {
            formData.append(part.name, value);
          }
        }
        return formData;
      }
      exports.composeUploadHandlers = composeUploadHandlers;
      exports.parseMultipartFormData = parseMultipartFormData;
    }
  });

  // node_modules/@remix-run/server-runtime/responses.js
  var require_responses = __commonJS({
    "node_modules/@remix-run/server-runtime/responses.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var json2 = (data, init = {}) => {
        let responseInit = typeof init === "number" ? {
          status: init
        } : init;
        let headers2 = new Headers(responseInit.headers);
        if (!headers2.has("Content-Type")) {
          headers2.set("Content-Type", "application/json; charset=utf-8");
        }
        return new Response(JSON.stringify(data), {
          ...responseInit,
          headers: headers2
        });
      };
      var redirect2 = (url, init = 302) => {
        let responseInit = init;
        if (typeof responseInit === "number") {
          responseInit = {
            status: responseInit
          };
        } else if (typeof responseInit.status === "undefined") {
          responseInit.status = 302;
        }
        let headers2 = new Headers(responseInit.headers);
        headers2.set("Location", url);
        return new Response(null, {
          ...responseInit,
          headers: headers2
        });
      };
      function isResponse(value) {
        return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
      }
      var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
      function isRedirectResponse(response) {
        return redirectStatusCodes.has(response.status);
      }
      function isCatchResponse(response) {
        return response.headers.get("X-Remix-Catch") != null;
      }
      exports.isCatchResponse = isCatchResponse;
      exports.isRedirectResponse = isRedirectResponse;
      exports.isResponse = isResponse;
      exports.json = json2;
      exports.redirect = redirect2;
    }
  });

  // node_modules/@remix-run/server-runtime/data.js
  var require_data = __commonJS({
    "node_modules/@remix-run/server-runtime/data.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var responses = require_responses();
      async function callRouteAction({
        loadContext,
        match,
        request
      }) {
        let action2 = match.route.module.action;
        if (!action2) {
          let response = new Response(null, {
            status: 405
          });
          response.headers.set("X-Remix-Catch", "yes");
          return response;
        }
        let result;
        try {
          result = await action2({
            request: stripDataParam(stripIndexParam(request)),
            context: loadContext,
            params: match.params
          });
        } catch (error) {
          if (!responses.isResponse(error)) {
            throw error;
          }
          if (!responses.isRedirectResponse(error)) {
            error.headers.set("X-Remix-Catch", "yes");
          }
          result = error;
        }
        if (result === void 0) {
          throw new Error(`You defined an action for route "${match.route.id}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
        }
        return responses.isResponse(result) ? result : responses.json(result);
      }
      async function callRouteLoader({
        loadContext,
        match,
        request
      }) {
        let loader = match.route.module.loader;
        if (!loader) {
          throw new Error(`You made a ${request.method} request to ${request.url} but did not provide a default component or \`loader\` for route "${match.route.id}", so there is no way to handle the request.`);
        }
        let result;
        try {
          result = await loader({
            request: stripDataParam(stripIndexParam(request)),
            context: loadContext,
            params: match.params
          });
        } catch (error) {
          if (!responses.isResponse(error)) {
            throw error;
          }
          if (!responses.isRedirectResponse(error)) {
            error.headers.set("X-Remix-Catch", "yes");
          }
          result = error;
        }
        if (result === void 0) {
          throw new Error(`You defined a loader for route "${match.route.id}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`);
        }
        return responses.isResponse(result) ? result : responses.json(result);
      }
      function stripIndexParam(request) {
        let url = new URL(request.url);
        let indexValues = url.searchParams.getAll("index");
        url.searchParams.delete("index");
        let indexValuesToKeep = [];
        for (let indexValue of indexValues) {
          if (indexValue) {
            indexValuesToKeep.push(indexValue);
          }
        }
        for (let toKeep of indexValuesToKeep) {
          url.searchParams.append("index", toKeep);
        }
        return new Request(url.href, request);
      }
      function stripDataParam(request) {
        let url = new URL(request.url);
        url.searchParams.delete("_data");
        return new Request(url.href, request);
      }
      function extractData(response) {
        let contentType = response.headers.get("Content-Type");
        if (contentType && /\bapplication\/json\b/.test(contentType)) {
          return response.json();
        }
        return response.text();
      }
      exports.callRouteAction = callRouteAction;
      exports.callRouteLoader = callRouteLoader;
      exports.extractData = extractData;
    }
  });

  // node_modules/@remix-run/server-runtime/entry.js
  var require_entry = __commonJS({
    "node_modules/@remix-run/server-runtime/entry.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function createEntryMatches(matches, routes2) {
        return matches.map((match) => ({
          params: match.params,
          pathname: match.pathname,
          route: routes2[match.route.id]
        }));
      }
      function createEntryRouteModules(manifest) {
        return Object.keys(manifest).reduce((memo, routeId) => {
          memo[routeId] = manifest[routeId].module;
          return memo;
        }, {});
      }
      exports.createEntryMatches = createEntryMatches;
      exports.createEntryRouteModules = createEntryRouteModules;
    }
  });

  // node_modules/@remix-run/server-runtime/errors.js
  var require_errors = __commonJS({
    "node_modules/@remix-run/server-runtime/errors.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      async function serializeError(error) {
        return {
          message: error.message,
          stack: error.stack
        };
      }
      exports.serializeError = serializeError;
    }
  });

  // node_modules/set-cookie-parser/lib/set-cookie.js
  var require_set_cookie = __commonJS({
    "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
      "use strict";
      var defaultParseOptions = {
        decodeValues: true,
        map: false,
        silent: false
      };
      function isNonEmptyString(str) {
        return typeof str === "string" && !!str.trim();
      }
      function parseString(setCookieValue, options) {
        var parts = setCookieValue.split(";").filter(isNonEmptyString);
        var nameValue = parts.shift().split("=");
        var name = nameValue.shift();
        var value = nameValue.join("=");
        options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
        try {
          value = options.decodeValues ? decodeURIComponent(value) : value;
        } catch (e) {
          console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
        }
        var cookie = {
          name,
          value
        };
        parts.forEach(function(part) {
          var sides = part.split("=");
          var key = sides.shift().trimLeft().toLowerCase();
          var value2 = sides.join("=");
          if (key === "expires") {
            cookie.expires = new Date(value2);
          } else if (key === "max-age") {
            cookie.maxAge = parseInt(value2, 10);
          } else if (key === "secure") {
            cookie.secure = true;
          } else if (key === "httponly") {
            cookie.httpOnly = true;
          } else if (key === "samesite") {
            cookie.sameSite = value2;
          } else {
            cookie[key] = value2;
          }
        });
        return cookie;
      }
      function parse(input, options) {
        options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
        if (!input) {
          if (!options.map) {
            return [];
          } else {
            return {};
          }
        }
        if (input.headers && input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else if (input.headers) {
          var sch = input.headers[Object.keys(input.headers).find(function(key) {
            return key.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options.silent) {
            console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
          }
          input = sch;
        }
        if (!Array.isArray(input)) {
          input = [input];
        }
        options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
        if (!options.map) {
          return input.filter(isNonEmptyString).map(function(str) {
            return parseString(str, options);
          });
        } else {
          var cookies = {};
          return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
            var cookie = parseString(str, options);
            cookies2[cookie.name] = cookie;
            return cookies2;
          }, cookies);
        }
      }
      function splitCookiesString(cookiesString) {
        if (Array.isArray(cookiesString)) {
          return cookiesString;
        }
        if (typeof cookiesString !== "string") {
          return [];
        }
        var cookiesStrings = [];
        var pos = 0;
        var start;
        var ch;
        var lastComma;
        var nextStart;
        var cookiesSeparatorFound;
        function skipWhitespace() {
          while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
            pos += 1;
          }
          return pos < cookiesString.length;
        }
        function notSpecialChar() {
          ch = cookiesString.charAt(pos);
          return ch !== "=" && ch !== ";" && ch !== ",";
        }
        while (pos < cookiesString.length) {
          start = pos;
          cookiesSeparatorFound = false;
          while (skipWhitespace()) {
            ch = cookiesString.charAt(pos);
            if (ch === ",") {
              lastComma = pos;
              pos += 1;
              skipWhitespace();
              nextStart = pos;
              while (pos < cookiesString.length && notSpecialChar()) {
                pos += 1;
              }
              if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
                cookiesSeparatorFound = true;
                pos = nextStart;
                cookiesStrings.push(cookiesString.substring(start, lastComma));
                start = pos;
              } else {
                pos = lastComma + 1;
              }
            } else {
              pos += 1;
            }
          }
          if (!cookiesSeparatorFound || pos >= cookiesString.length) {
            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
          }
        }
        return cookiesStrings;
      }
      module.exports = parse;
      module.exports.parse = parse;
      module.exports.parseString = parseString;
      module.exports.splitCookiesString = splitCookiesString;
    }
  });

  // node_modules/@remix-run/server-runtime/headers.js
  var require_headers = __commonJS({
    "node_modules/@remix-run/server-runtime/headers.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var setCookieParser = require_set_cookie();
      function getDocumentHeaders(build, matches, routeLoaderResponses, actionResponse) {
        return matches.reduce((parentHeaders, match, index) => {
          let routeModule = build.routes[match.route.id].module;
          let routeLoaderResponse = routeLoaderResponses[match.route.id];
          let loaderHeaders = routeLoaderResponse ? routeLoaderResponse.headers : new Headers();
          let actionHeaders = actionResponse ? actionResponse.headers : new Headers();
          let headers2 = new Headers(routeModule.headers ? typeof routeModule.headers === "function" ? routeModule.headers({
            loaderHeaders,
            parentHeaders,
            actionHeaders
          }) : routeModule.headers : void 0);
          prependCookies(actionHeaders, headers2);
          prependCookies(loaderHeaders, headers2);
          prependCookies(parentHeaders, headers2);
          return headers2;
        }, new Headers());
      }
      function prependCookies(parentHeaders, childHeaders) {
        let parentSetCookieString = parentHeaders.get("Set-Cookie");
        if (parentSetCookieString) {
          let cookies = setCookieParser.splitCookiesString(parentSetCookieString);
          cookies.forEach((cookie) => {
            childHeaders.append("Set-Cookie", cookie);
          });
        }
      }
      exports.getDocumentHeaders = getDocumentHeaders;
    }
  });

  // node_modules/@remix-run/server-runtime/mode.js
  var require_mode = __commonJS({
    "node_modules/@remix-run/server-runtime/mode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ServerMode = void 0;
      (function(ServerMode) {
        ServerMode["Development"] = "development";
        ServerMode["Production"] = "production";
        ServerMode["Test"] = "test";
      })(exports.ServerMode || (exports.ServerMode = {}));
      function isServerMode(value) {
        return value === exports.ServerMode.Development || value === exports.ServerMode.Production || value === exports.ServerMode.Test;
      }
      exports.isServerMode = isServerMode;
    }
  });

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var ReactVersion = "18.2.0";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: null
          };
          var ReactCurrentActQueue = {
            current: null,
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
          };
          var ReactCurrentOwner = {
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
          }
          function warn(format) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format, args);
              }
            }
          }
          function error(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            isMounted: function(publicInstance) {
              return false;
            },
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var assign = Object.assign;
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component.prototype.isReactComponent = {};
          Component.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
              throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component.prototype;
          function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent;
          assign(pureComponentPrototype, Component.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var isArrayImpl = Array.isArray;
          function isArray(a) {
            return isArrayImpl(a);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config) {
            {
              if (hasOwnProperty.call(config, "ref")) {
                var getter3 = Object.getOwnPropertyDescriptor(config, "ref").get;
                if (getter3 && getter3.isReactWarning) {
                  return false;
                }
              }
            }
            return config.ref !== void 0;
          }
          function hasValidKey(config) {
            {
              if (hasOwnProperty.call(config, "key")) {
                var getter3 = Object.getOwnPropertyDescriptor(config, "key").get;
                if (getter3 && getter3.isReactWarning) {
                  return false;
                }
              }
            }
            return config.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config) {
            {
              if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              $$typeof: REACT_ELEMENT_TYPE,
              type,
              key,
              ref,
              props,
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement2(type, config, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self2 = null;
            var source = null;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config);
                }
              }
              if (hasValidKey(config)) {
                {
                  checkKeyStringCoercion(config.key);
                }
                key = "" + config.key;
              }
              self2 = config.__self === void 0 ? null : config.__self;
              source = config.__source === void 0 ? null : config.__source;
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            {
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement(element, config, children) {
            if (element === null || element === void 0) {
              throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config)) {
                {
                  checkKeyStringCoercion(config.key);
                }
                key = "" + config.key;
              }
              var defaultProps;
              if (element.type && element.type.defaultProps) {
                defaultProps = element.type.defaultProps;
              }
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config[propName] === void 0 && defaultProps !== void 0) {
                    props[propName] = defaultProps[propName];
                  } else {
                    props[propName] = config[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self2, source, owner, props);
          }
          function isValidElement(object2) {
            return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape2(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index) {
            if (typeof element === "object" && element !== null && element.key != null) {
              {
                checkKeyStringCoercion(element.key);
              }
              return escape2("" + element.key);
            }
            return index.toString(36);
          }
          function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (isArray(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array2, escapedChildKey, "", function(c) {
                  return c;
                });
              } else if (mappedChild != null) {
                if (isValidElement(mappedChild)) {
                  {
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                      checkKeyStringCoercion(mappedChild.key);
                    }
                  }
                  mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
                }
                array2.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray(children)) {
              for (var i = 0; i < children.length; i++) {
                child = children[i];
                nextName = nextNamePrefix + getElementKey(child, i);
                subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
                }
              } else if (type === "object") {
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray2(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement(children)) {
              throw new Error("React.Children.only expected to receive a single React element child.");
            }
            return children;
          }
          function createContext(defaultValue) {
            var context = {
              $$typeof: REACT_CONTEXT_TYPE,
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              _threadCount: 0,
              Provider: null,
              Consumer: null,
              _defaultValue: null,
              _globalName: null
            };
            context.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                  },
                  set: function(_Provider) {
                    context.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context._currentValue;
                  },
                  set: function(_currentValue) {
                    context._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context._threadCount;
                  },
                  set: function(_threadCount) {
                    context._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context.Consumer = Consumer;
            }
            {
              context._currentRenderer = null;
              context._currentRenderer2 = null;
            }
            return context;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              thenable.then(function(moduleObject2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = moduleObject2;
                }
              }, function(error2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error2;
                }
              });
              if (payload._status === Uninitialized) {
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
              }
            }
            if (payload._status === Resolved) {
              var moduleObject = payload._result;
              {
                if (moduleObject === void 0) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
                }
              }
              {
                if (!("default" in moduleObject)) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                }
              }
              return moduleObject.default;
            } else {
              throw payload._result;
            }
          }
          function lazy(ctor) {
            var payload = {
              _status: Uninitialized,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps;
                  },
                  set: function(newDefaultProps) {
                    error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef(render) {
            {
              if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render !== "function") {
                error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
              } else {
                if (render.length !== 0 && render.length !== 2) {
                  error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render != null) {
                if (render.defaultProps != null || render.propTypes != null) {
                  error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!render.name && !render.displayName) {
                    render.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function memo(type, compare) {
            {
              if (!isValidElementType(type)) {
                error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare === void 0 ? null : compare
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!type.name && !type.displayName) {
                    type.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
              if (dispatcher === null) {
                error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext(Context) {
            var dispatcher = resolveDispatcher();
            {
              if (Context._context !== void 0) {
                var realContext = Context._context;
                if (realContext.Consumer === Context) {
                  error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context) {
                  error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context);
          }
          function useState3(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
          }
          function useReducer(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
          }
          function useRef2(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect2(create10, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create10, deps);
          }
          function useInsertionEffect(create10, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create10, deps);
          }
          function useLayoutEffect(create10, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create10, deps);
          }
          function useCallback(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo(create10, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create10, deps);
          }
          function useImperativeHandle(ref, create10, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create10, deps);
          }
          function useDebugValue(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          function useTransition2() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
          }
          function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
          }
          function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has4 = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has4(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement2.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i = 2; i < arguments.length; i++) {
                validateChildKeys(arguments[i], type);
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement.apply(this, arguments);
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
              ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              scope();
            } finally {
              ReactCurrentBatchConfig.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module && module[requireString];
                enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var actScopeDepth = 0;
          var didWarnNoAwaitAct = false;
          function act(callback) {
            {
              var prevActScopeDepth = actScopeDepth;
              actScopeDepth++;
              if (ReactCurrentActQueue.current === null) {
                ReactCurrentActQueue.current = [];
              }
              var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
              var result;
              try {
                ReactCurrentActQueue.isBatchingLegacy = true;
                result = callback();
                if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                  var queue = ReactCurrentActQueue.current;
                  if (queue !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue);
                  }
                }
              } catch (error2) {
                popActScope(prevActScopeDepth);
                throw error2;
              } finally {
                ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
              }
              if (result !== null && typeof result === "object" && typeof result.then === "function") {
                var thenableResult = result;
                var wasAwaited = false;
                var thenable = {
                  then: function(resolve, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue2) {
                      popActScope(prevActScopeDepth);
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                      } else {
                        resolve(returnValue2);
                      }
                    }, function(error2) {
                      popActScope(prevActScopeDepth);
                      reject(error2);
                    });
                  }
                };
                {
                  if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                    Promise.resolve().then(function() {
                    }).then(function() {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true;
                        error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                      }
                    });
                  }
                }
                return thenable;
              } else {
                var returnValue = result;
                popActScope(prevActScopeDepth);
                if (actScopeDepth === 0) {
                  var _queue = ReactCurrentActQueue.current;
                  if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                  }
                  var _thenable = {
                    then: function(resolve, reject) {
                      if (ReactCurrentActQueue.current === null) {
                        ReactCurrentActQueue.current = [];
                        recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                      } else {
                        resolve(returnValue);
                      }
                    }
                  };
                  return _thenable;
                } else {
                  var _thenable2 = {
                    then: function(resolve, reject) {
                      resolve(returnValue);
                    }
                  };
                  return _thenable2;
                }
              }
            }
          }
          function popActScope(prevActScopeDepth) {
            {
              if (prevActScopeDepth !== actScopeDepth - 1) {
                error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
              actScopeDepth = prevActScopeDepth;
            }
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                try {
                  flushActQueue(queue);
                  enqueueTask(function() {
                    if (queue.length === 0) {
                      ReactCurrentActQueue.current = null;
                      resolve(returnValue);
                    } else {
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    }
                  });
                } catch (error2) {
                  reject(error2);
                }
              } else {
                resolve(returnValue);
              }
            }
          }
          var isFlushing = false;
          function flushActQueue(queue) {
            {
              if (!isFlushing) {
                isFlushing = true;
                var i = 0;
                try {
                  for (; i < queue.length; i++) {
                    var callback = queue[i];
                    do {
                      callback = callback(true);
                    } while (callback !== null);
                  }
                  queue.length = 0;
                } catch (error2) {
                  queue = queue.slice(i + 1);
                  throw error2;
                } finally {
                  isFlushing = false;
                }
              }
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray: toArray2,
            only: onlyChild
          };
          exports.Children = Children;
          exports.Component = Component;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.Profiler = REACT_PROFILER_TYPE;
          exports.PureComponent = PureComponent;
          exports.StrictMode = REACT_STRICT_MODE_TYPE;
          exports.Suspense = REACT_SUSPENSE_TYPE;
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports.cloneElement = cloneElement$1;
          exports.createContext = createContext;
          exports.createElement = createElement$1;
          exports.createFactory = createFactory;
          exports.createRef = createRef;
          exports.forwardRef = forwardRef;
          exports.isValidElement = isValidElement;
          exports.lazy = lazy;
          exports.memo = memo;
          exports.startTransition = startTransition;
          exports.unstable_act = act;
          exports.useCallback = useCallback;
          exports.useContext = useContext;
          exports.useDebugValue = useDebugValue;
          exports.useDeferredValue = useDeferredValue;
          exports.useEffect = useEffect2;
          exports.useId = useId;
          exports.useImperativeHandle = useImperativeHandle;
          exports.useInsertionEffect = useInsertionEffect;
          exports.useLayoutEffect = useLayoutEffect;
          exports.useMemo = useMemo;
          exports.useReducer = useReducer;
          exports.useRef = useRef2;
          exports.useState = useState3;
          exports.useSyncExternalStore = useSyncExternalStore;
          exports.useTransition = useTransition2;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/history/umd/history.development.js
  var require_history_development = __commonJS({
    "node_modules/history/umd/history.development.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.HistoryLibrary = {}));
      })(exports, function(exports2) {
        "use strict";
        function _extends6() {
          _extends6 = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends6.apply(this, arguments);
        }
        exports2.Action = void 0;
        (function(Action) {
          Action["Pop"] = "POP";
          Action["Push"] = "PUSH";
          Action["Replace"] = "REPLACE";
        })(exports2.Action || (exports2.Action = {}));
        var readOnly = function(obj) {
          return Object.freeze(obj);
        };
        function warning(cond, message) {
          if (!cond) {
            if (typeof console !== "undefined")
              console.warn(message);
            try {
              throw new Error(message);
            } catch (e) {
            }
          }
        }
        var BeforeUnloadEventType = "beforeunload";
        var HashChangeEventType = "hashchange";
        var PopStateEventType = "popstate";
        function createBrowserHistory(options) {
          if (options === void 0) {
            options = {};
          }
          var _options = options, _options$window = _options.window, window2 = _options$window === void 0 ? document.defaultView : _options$window;
          var globalHistory = window2.history;
          function getIndexAndLocation() {
            var _window$location = window2.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;
            var state = globalHistory.state || {};
            return [state.idx, readOnly({
              pathname,
              search,
              hash,
              state: state.usr || null,
              key: state.key || "default"
            })];
          }
          var blockedPopTx = null;
          function handlePop() {
            if (blockedPopTx) {
              blockers.call(blockedPopTx);
              blockedPopTx = null;
            } else {
              var nextAction = exports2.Action.Pop;
              var _getIndexAndLocation = getIndexAndLocation(), nextIndex = _getIndexAndLocation[0], nextLocation = _getIndexAndLocation[1];
              if (blockers.length) {
                if (nextIndex != null) {
                  var delta = index - nextIndex;
                  if (delta) {
                    blockedPopTx = {
                      action: nextAction,
                      location: nextLocation,
                      retry: function retry() {
                        go(delta * -1);
                      }
                    };
                    go(delta);
                  }
                } else {
                  warning(false, "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.");
                }
              } else {
                applyTx(nextAction);
              }
            }
          }
          window2.addEventListener(PopStateEventType, handlePop);
          var action2 = exports2.Action.Pop;
          var _getIndexAndLocation2 = getIndexAndLocation(), index = _getIndexAndLocation2[0], location = _getIndexAndLocation2[1];
          var listeners = createEvents();
          var blockers = createEvents();
          if (index == null) {
            index = 0;
            globalHistory.replaceState(_extends6({}, globalHistory.state, {
              idx: index
            }), "");
          }
          function createHref(to) {
            return typeof to === "string" ? to : createPath(to);
          }
          function getNextLocation(to, state) {
            if (state === void 0) {
              state = null;
            }
            return readOnly(_extends6({
              pathname: location.pathname,
              hash: "",
              search: ""
            }, typeof to === "string" ? parsePath(to) : to, {
              state,
              key: createKey()
            }));
          }
          function getHistoryStateAndUrl(nextLocation, index2) {
            return [{
              usr: nextLocation.state,
              key: nextLocation.key,
              idx: index2
            }, createHref(nextLocation)];
          }
          function allowTx(action3, location2, retry) {
            return !blockers.length || (blockers.call({
              action: action3,
              location: location2,
              retry
            }), false);
          }
          function applyTx(nextAction) {
            action2 = nextAction;
            var _getIndexAndLocation3 = getIndexAndLocation();
            index = _getIndexAndLocation3[0];
            location = _getIndexAndLocation3[1];
            listeners.call({
              action: action2,
              location
            });
          }
          function push(to, state) {
            var nextAction = exports2.Action.Push;
            var nextLocation = getNextLocation(to, state);
            function retry() {
              push(to, state);
            }
            if (allowTx(nextAction, nextLocation, retry)) {
              var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr[0], url = _getHistoryStateAndUr[1];
              try {
                globalHistory.pushState(historyState, "", url);
              } catch (error) {
                window2.location.assign(url);
              }
              applyTx(nextAction);
            }
          }
          function replace(to, state) {
            var nextAction = exports2.Action.Replace;
            var nextLocation = getNextLocation(to, state);
            function retry() {
              replace(to, state);
            }
            if (allowTx(nextAction, nextLocation, retry)) {
              var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr2[0], url = _getHistoryStateAndUr2[1];
              globalHistory.replaceState(historyState, "", url);
              applyTx(nextAction);
            }
          }
          function go(delta) {
            globalHistory.go(delta);
          }
          var history = {
            get action() {
              return action2;
            },
            get location() {
              return location;
            },
            createHref,
            push,
            replace,
            go,
            back: function back() {
              go(-1);
            },
            forward: function forward() {
              go(1);
            },
            listen: function listen(listener) {
              return listeners.push(listener);
            },
            block: function block(blocker) {
              var unblock = blockers.push(blocker);
              if (blockers.length === 1) {
                window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
              }
              return function() {
                unblock();
                if (!blockers.length) {
                  window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
                }
              };
            }
          };
          return history;
        }
        function createHashHistory(options) {
          if (options === void 0) {
            options = {};
          }
          var _options2 = options, _options2$window = _options2.window, window2 = _options2$window === void 0 ? document.defaultView : _options2$window;
          var globalHistory = window2.history;
          function getIndexAndLocation() {
            var _parsePath = parsePath(window2.location.hash.substr(1)), _parsePath$pathname = _parsePath.pathname, pathname = _parsePath$pathname === void 0 ? "/" : _parsePath$pathname, _parsePath$search = _parsePath.search, search = _parsePath$search === void 0 ? "" : _parsePath$search, _parsePath$hash = _parsePath.hash, hash = _parsePath$hash === void 0 ? "" : _parsePath$hash;
            var state = globalHistory.state || {};
            return [state.idx, readOnly({
              pathname,
              search,
              hash,
              state: state.usr || null,
              key: state.key || "default"
            })];
          }
          var blockedPopTx = null;
          function handlePop() {
            if (blockedPopTx) {
              blockers.call(blockedPopTx);
              blockedPopTx = null;
            } else {
              var nextAction = exports2.Action.Pop;
              var _getIndexAndLocation4 = getIndexAndLocation(), nextIndex = _getIndexAndLocation4[0], nextLocation = _getIndexAndLocation4[1];
              if (blockers.length) {
                if (nextIndex != null) {
                  var delta = index - nextIndex;
                  if (delta) {
                    blockedPopTx = {
                      action: nextAction,
                      location: nextLocation,
                      retry: function retry() {
                        go(delta * -1);
                      }
                    };
                    go(delta);
                  }
                } else {
                  warning(false, "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.");
                }
              } else {
                applyTx(nextAction);
              }
            }
          }
          window2.addEventListener(PopStateEventType, handlePop);
          window2.addEventListener(HashChangeEventType, function() {
            var _getIndexAndLocation5 = getIndexAndLocation(), nextLocation = _getIndexAndLocation5[1];
            if (createPath(nextLocation) !== createPath(location)) {
              handlePop();
            }
          });
          var action2 = exports2.Action.Pop;
          var _getIndexAndLocation6 = getIndexAndLocation(), index = _getIndexAndLocation6[0], location = _getIndexAndLocation6[1];
          var listeners = createEvents();
          var blockers = createEvents();
          if (index == null) {
            index = 0;
            globalHistory.replaceState(_extends6({}, globalHistory.state, {
              idx: index
            }), "");
          }
          function getBaseHref() {
            var base = document.querySelector("base");
            var href = "";
            if (base && base.getAttribute("href")) {
              var url = window2.location.href;
              var hashIndex = url.indexOf("#");
              href = hashIndex === -1 ? url : url.slice(0, hashIndex);
            }
            return href;
          }
          function createHref(to) {
            return getBaseHref() + "#" + (typeof to === "string" ? to : createPath(to));
          }
          function getNextLocation(to, state) {
            if (state === void 0) {
              state = null;
            }
            return readOnly(_extends6({
              pathname: location.pathname,
              hash: "",
              search: ""
            }, typeof to === "string" ? parsePath(to) : to, {
              state,
              key: createKey()
            }));
          }
          function getHistoryStateAndUrl(nextLocation, index2) {
            return [{
              usr: nextLocation.state,
              key: nextLocation.key,
              idx: index2
            }, createHref(nextLocation)];
          }
          function allowTx(action3, location2, retry) {
            return !blockers.length || (blockers.call({
              action: action3,
              location: location2,
              retry
            }), false);
          }
          function applyTx(nextAction) {
            action2 = nextAction;
            var _getIndexAndLocation7 = getIndexAndLocation();
            index = _getIndexAndLocation7[0];
            location = _getIndexAndLocation7[1];
            listeners.call({
              action: action2,
              location
            });
          }
          function push(to, state) {
            var nextAction = exports2.Action.Push;
            var nextLocation = getNextLocation(to, state);
            function retry() {
              push(to, state);
            }
            warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
            if (allowTx(nextAction, nextLocation, retry)) {
              var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr3[0], url = _getHistoryStateAndUr3[1];
              try {
                globalHistory.pushState(historyState, "", url);
              } catch (error) {
                window2.location.assign(url);
              }
              applyTx(nextAction);
            }
          }
          function replace(to, state) {
            var nextAction = exports2.Action.Replace;
            var nextLocation = getNextLocation(to, state);
            function retry() {
              replace(to, state);
            }
            warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.replace(" + JSON.stringify(to) + ")");
            if (allowTx(nextAction, nextLocation, retry)) {
              var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr4[0], url = _getHistoryStateAndUr4[1];
              globalHistory.replaceState(historyState, "", url);
              applyTx(nextAction);
            }
          }
          function go(delta) {
            globalHistory.go(delta);
          }
          var history = {
            get action() {
              return action2;
            },
            get location() {
              return location;
            },
            createHref,
            push,
            replace,
            go,
            back: function back() {
              go(-1);
            },
            forward: function forward() {
              go(1);
            },
            listen: function listen(listener) {
              return listeners.push(listener);
            },
            block: function block(blocker) {
              var unblock = blockers.push(blocker);
              if (blockers.length === 1) {
                window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
              }
              return function() {
                unblock();
                if (!blockers.length) {
                  window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
                }
              };
            }
          };
          return history;
        }
        function createMemoryHistory(options) {
          if (options === void 0) {
            options = {};
          }
          var _options3 = options, _options3$initialEntr = _options3.initialEntries, initialEntries = _options3$initialEntr === void 0 ? ["/"] : _options3$initialEntr, initialIndex = _options3.initialIndex;
          var entries = initialEntries.map(function(entry2) {
            var location2 = readOnly(_extends6({
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: createKey()
            }, typeof entry2 === "string" ? parsePath(entry2) : entry2));
            warning(location2.pathname.charAt(0) === "/", "Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: " + JSON.stringify(entry2) + ")");
            return location2;
          });
          var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);
          var action2 = exports2.Action.Pop;
          var location = entries[index];
          var listeners = createEvents();
          var blockers = createEvents();
          function createHref(to) {
            return typeof to === "string" ? to : createPath(to);
          }
          function getNextLocation(to, state) {
            if (state === void 0) {
              state = null;
            }
            return readOnly(_extends6({
              pathname: location.pathname,
              search: "",
              hash: ""
            }, typeof to === "string" ? parsePath(to) : to, {
              state,
              key: createKey()
            }));
          }
          function allowTx(action3, location2, retry) {
            return !blockers.length || (blockers.call({
              action: action3,
              location: location2,
              retry
            }), false);
          }
          function applyTx(nextAction, nextLocation) {
            action2 = nextAction;
            location = nextLocation;
            listeners.call({
              action: action2,
              location
            });
          }
          function push(to, state) {
            var nextAction = exports2.Action.Push;
            var nextLocation = getNextLocation(to, state);
            function retry() {
              push(to, state);
            }
            warning(location.pathname.charAt(0) === "/", "Relative pathnames are not supported in memory history.push(" + JSON.stringify(to) + ")");
            if (allowTx(nextAction, nextLocation, retry)) {
              index += 1;
              entries.splice(index, entries.length, nextLocation);
              applyTx(nextAction, nextLocation);
            }
          }
          function replace(to, state) {
            var nextAction = exports2.Action.Replace;
            var nextLocation = getNextLocation(to, state);
            function retry() {
              replace(to, state);
            }
            warning(location.pathname.charAt(0) === "/", "Relative pathnames are not supported in memory history.replace(" + JSON.stringify(to) + ")");
            if (allowTx(nextAction, nextLocation, retry)) {
              entries[index] = nextLocation;
              applyTx(nextAction, nextLocation);
            }
          }
          function go(delta) {
            var nextIndex = clamp(index + delta, 0, entries.length - 1);
            var nextAction = exports2.Action.Pop;
            var nextLocation = entries[nextIndex];
            function retry() {
              go(delta);
            }
            if (allowTx(nextAction, nextLocation, retry)) {
              index = nextIndex;
              applyTx(nextAction, nextLocation);
            }
          }
          var history = {
            get index() {
              return index;
            },
            get action() {
              return action2;
            },
            get location() {
              return location;
            },
            createHref,
            push,
            replace,
            go,
            back: function back() {
              go(-1);
            },
            forward: function forward() {
              go(1);
            },
            listen: function listen(listener) {
              return listeners.push(listener);
            },
            block: function block(blocker) {
              return blockers.push(blocker);
            }
          };
          return history;
        }
        function clamp(n, lowerBound, upperBound) {
          return Math.min(Math.max(n, lowerBound), upperBound);
        }
        function promptBeforeUnload(event) {
          event.preventDefault();
          event.returnValue = "";
        }
        function createEvents() {
          var handlers = [];
          return {
            get length() {
              return handlers.length;
            },
            push: function push(fn) {
              handlers.push(fn);
              return function() {
                handlers = handlers.filter(function(handler) {
                  return handler !== fn;
                });
              };
            },
            call: function call(arg) {
              handlers.forEach(function(fn) {
                return fn && fn(arg);
              });
            }
          };
        }
        function createKey() {
          return Math.random().toString(36).substr(2, 8);
        }
        function createPath(_ref) {
          var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? "/" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? "" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? "" : _ref$hash;
          if (search && search !== "?")
            pathname += search.charAt(0) === "?" ? search : "?" + search;
          if (hash && hash !== "#")
            pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
          return pathname;
        }
        function parsePath(path) {
          var parsedPath = {};
          if (path) {
            var hashIndex = path.indexOf("#");
            if (hashIndex >= 0) {
              parsedPath.hash = path.substr(hashIndex);
              path = path.substr(0, hashIndex);
            }
            var searchIndex = path.indexOf("?");
            if (searchIndex >= 0) {
              parsedPath.search = path.substr(searchIndex);
              path = path.substr(0, searchIndex);
            }
            if (path) {
              parsedPath.pathname = path;
            }
          }
          return parsedPath;
        }
        exports2.createBrowserHistory = createBrowserHistory;
        exports2.createHashHistory = createHashHistory;
        exports2.createMemoryHistory = createMemoryHistory;
        exports2.createPath = createPath;
        exports2.parsePath = parsePath;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/history/main.js
  var require_main = __commonJS({
    "node_modules/history/main.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_history_development();
      }
    }
  });

  // node_modules/react-router/umd/react-router.development.js
  var require_react_router_development = __commonJS({
    "node_modules/react-router/umd/react-router.development.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_main(), require_react()) : typeof define === "function" && define.amd ? define(["exports", "history", "react"], factory) : (global2 = global2 || self, factory(global2.ReactRouter = {}, global2.HistoryLibrary, global2.React));
      })(exports, function(exports2, history, React4) {
        "use strict";
        const NavigationContext = /* @__PURE__ */ React4.createContext(null);
        {
          NavigationContext.displayName = "Navigation";
        }
        const LocationContext = /* @__PURE__ */ React4.createContext(null);
        {
          LocationContext.displayName = "Location";
        }
        const RouteContext = /* @__PURE__ */ React4.createContext({
          outlet: null,
          matches: []
        });
        {
          RouteContext.displayName = "Route";
        }
        function invariant(cond, message) {
          if (!cond)
            throw new Error(message);
        }
        function warning(cond, message) {
          if (!cond) {
            if (typeof console !== "undefined")
              console.warn(message);
            try {
              throw new Error(message);
            } catch (e) {
            }
          }
        }
        const alreadyWarned = {};
        function warningOnce(key, cond, message) {
          if (!cond && !alreadyWarned[key]) {
            alreadyWarned[key] = true;
            warning(false, message);
          }
        }
        function generatePath(path, params) {
          if (params === void 0) {
            params = {};
          }
          return path.replace(/:(\w+)/g, (_, key) => {
            !(params[key] != null) ? invariant(false, 'Missing ":' + key + '" param') : void 0;
            return params[key];
          }).replace(/\/*\*$/, (_) => params["*"] == null ? "" : params["*"].replace(/^\/*/, "/"));
        }
        function matchRoutes(routes2, locationArg, basename) {
          if (basename === void 0) {
            basename = "/";
          }
          let location = typeof locationArg === "string" ? history.parsePath(locationArg) : locationArg;
          let pathname = stripBasename(location.pathname || "/", basename);
          if (pathname == null) {
            return null;
          }
          let branches = flattenRoutes(routes2);
          rankRouteBranches(branches);
          let matches = null;
          for (let i = 0; matches == null && i < branches.length; ++i) {
            matches = matchRouteBranch(branches[i], pathname);
          }
          return matches;
        }
        function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
          if (branches === void 0) {
            branches = [];
          }
          if (parentsMeta === void 0) {
            parentsMeta = [];
          }
          if (parentPath === void 0) {
            parentPath = "";
          }
          routes2.forEach((route, index) => {
            let meta2 = {
              relativePath: route.path || "",
              caseSensitive: route.caseSensitive === true,
              childrenIndex: index,
              route
            };
            if (meta2.relativePath.startsWith("/")) {
              !meta2.relativePath.startsWith(parentPath) ? invariant(false, 'Absolute route path "' + meta2.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.") : void 0;
              meta2.relativePath = meta2.relativePath.slice(parentPath.length);
            }
            let path = joinPaths([parentPath, meta2.relativePath]);
            let routesMeta = parentsMeta.concat(meta2);
            if (route.children && route.children.length > 0) {
              !(route.index !== true) ? invariant(false, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')) : void 0;
              flattenRoutes(route.children, branches, routesMeta, path);
            }
            if (route.path == null && !route.index) {
              return;
            }
            branches.push({
              path,
              score: computeScore(path, route.index),
              routesMeta
            });
          });
          return branches;
        }
        function rankRouteBranches(branches) {
          branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta2) => meta2.childrenIndex), b.routesMeta.map((meta2) => meta2.childrenIndex)));
        }
        const paramRe = /^:\w+$/;
        const dynamicSegmentValue = 3;
        const indexRouteValue = 2;
        const emptySegmentValue = 1;
        const staticSegmentValue = 10;
        const splatPenalty = -2;
        const isSplat = (s) => s === "*";
        function computeScore(path, index) {
          let segments = path.split("/");
          let initialScore = segments.length;
          if (segments.some(isSplat)) {
            initialScore += splatPenalty;
          }
          if (index) {
            initialScore += indexRouteValue;
          }
          return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
        }
        function compareIndexes(a, b) {
          let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
          return siblings ? a[a.length - 1] - b[b.length - 1] : 0;
        }
        function matchRouteBranch(branch, pathname) {
          let {
            routesMeta
          } = branch;
          let matchedParams = {};
          let matchedPathname = "/";
          let matches = [];
          for (let i = 0; i < routesMeta.length; ++i) {
            let meta2 = routesMeta[i];
            let end = i === routesMeta.length - 1;
            let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
            let match = matchPath({
              path: meta2.relativePath,
              caseSensitive: meta2.caseSensitive,
              end
            }, remainingPathname);
            if (!match)
              return null;
            Object.assign(matchedParams, match.params);
            let route = meta2.route;
            matches.push({
              params: matchedParams,
              pathname: joinPaths([matchedPathname, match.pathname]),
              pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
              route
            });
            if (match.pathnameBase !== "/") {
              matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
            }
          }
          return matches;
        }
        function matchPath(pattern, pathname) {
          if (typeof pattern === "string") {
            pattern = {
              path: pattern,
              caseSensitive: false,
              end: true
            };
          }
          let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
          let match = pathname.match(matcher);
          if (!match)
            return null;
          let matchedPathname = match[0];
          let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
          let captureGroups = match.slice(1);
          let params = paramNames.reduce((memo, paramName, index) => {
            if (paramName === "*") {
              let splatValue = captureGroups[index] || "";
              pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
            }
            memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
            return memo;
          }, {});
          return {
            params,
            pathname: matchedPathname,
            pathnameBase,
            pattern
          };
        }
        function compilePath(path, caseSensitive, end) {
          if (caseSensitive === void 0) {
            caseSensitive = false;
          }
          if (end === void 0) {
            end = true;
          }
          warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
          let paramNames = [];
          let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_, paramName) => {
            paramNames.push(paramName);
            return "([^\\/]+)";
          });
          if (path.endsWith("*")) {
            paramNames.push("*");
            regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
          } else {
            regexpSource += end ? "\\/*$" : "(?:(?=[.~-]|%[0-9A-F]{2})|\\b|\\/|$)";
          }
          let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
          return [matcher, paramNames];
        }
        function safelyDecodeURIComponent(value, paramName) {
          try {
            return decodeURIComponent(value);
          } catch (error) {
            warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
            return value;
          }
        }
        function resolvePath(to, fromPathname) {
          if (fromPathname === void 0) {
            fromPathname = "/";
          }
          let {
            pathname: toPathname,
            search = "",
            hash = ""
          } = typeof to === "string" ? history.parsePath(to) : to;
          let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
          return {
            pathname,
            search: normalizeSearch(search),
            hash: normalizeHash(hash)
          };
        }
        function resolvePathname(relativePath, fromPathname) {
          let segments = fromPathname.replace(/\/+$/, "").split("/");
          let relativeSegments = relativePath.split("/");
          relativeSegments.forEach((segment) => {
            if (segment === "..") {
              if (segments.length > 1)
                segments.pop();
            } else if (segment !== ".") {
              segments.push(segment);
            }
          });
          return segments.length > 1 ? segments.join("/") : "/";
        }
        function resolveTo(toArg, routePathnames, locationPathname) {
          let to = typeof toArg === "string" ? history.parsePath(toArg) : toArg;
          let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname;
          let from;
          if (toPathname == null) {
            from = locationPathname;
          } else {
            let routePathnameIndex = routePathnames.length - 1;
            if (toPathname.startsWith("..")) {
              let toSegments = toPathname.split("/");
              while (toSegments[0] === "..") {
                toSegments.shift();
                routePathnameIndex -= 1;
              }
              to.pathname = toSegments.join("/");
            }
            from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
          }
          let path = resolvePath(to, from);
          if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
            path.pathname += "/";
          }
          return path;
        }
        function getToPathname(to) {
          return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? history.parsePath(to).pathname : to.pathname;
        }
        function stripBasename(pathname, basename) {
          if (basename === "/")
            return pathname;
          if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
            return null;
          }
          let nextChar = pathname.charAt(basename.length);
          if (nextChar && nextChar !== "/") {
            return null;
          }
          return pathname.slice(basename.length) || "/";
        }
        const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
        const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
        const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
        const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
        function useHref2(to) {
          !useInRouterContext() ? invariant(false, "useHref() may be used only in the context of a <Router> component.") : void 0;
          let {
            basename,
            navigator
          } = React4.useContext(NavigationContext);
          let {
            hash,
            pathname,
            search
          } = useResolvedPath2(to);
          let joinedPathname = pathname;
          if (basename !== "/") {
            let toPathname = getToPathname(to);
            let endsWithSlash = toPathname != null && toPathname.endsWith("/");
            joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
          }
          return navigator.createHref({
            pathname: joinedPathname,
            search,
            hash
          });
        }
        function useInRouterContext() {
          return React4.useContext(LocationContext) != null;
        }
        function useLocation2() {
          !useInRouterContext() ? invariant(false, "useLocation() may be used only in the context of a <Router> component.") : void 0;
          return React4.useContext(LocationContext).location;
        }
        function useNavigationType2() {
          return React4.useContext(LocationContext).navigationType;
        }
        function useMatch(pattern) {
          !useInRouterContext() ? invariant(false, "useMatch() may be used only in the context of a <Router> component.") : void 0;
          let {
            pathname
          } = useLocation2();
          return React4.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);
        }
        function useNavigate2() {
          !useInRouterContext() ? invariant(false, "useNavigate() may be used only in the context of a <Router> component.") : void 0;
          let {
            basename,
            navigator
          } = React4.useContext(NavigationContext);
          let {
            matches
          } = React4.useContext(RouteContext);
          let {
            pathname: locationPathname
          } = useLocation2();
          let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
          let activeRef = React4.useRef(false);
          React4.useEffect(() => {
            activeRef.current = true;
          });
          let navigate = React4.useCallback(function(to, options) {
            if (options === void 0) {
              options = {};
            }
            warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered.");
            if (!activeRef.current)
              return;
            if (typeof to === "number") {
              navigator.go(to);
              return;
            }
            let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
            if (basename !== "/") {
              path.pathname = joinPaths([basename, path.pathname]);
            }
            (!!options.replace ? navigator.replace : navigator.push)(path, options.state);
          }, [basename, navigator, routePathnamesJson, locationPathname]);
          return navigate;
        }
        const OutletContext = /* @__PURE__ */ React4.createContext(null);
        function useOutletContext2() {
          return React4.useContext(OutletContext);
        }
        function useOutlet2(context) {
          let outlet = React4.useContext(RouteContext).outlet;
          if (outlet) {
            return /* @__PURE__ */ React4.createElement(OutletContext.Provider, {
              value: context
            }, outlet);
          }
          return outlet;
        }
        function useParams2() {
          let {
            matches
          } = React4.useContext(RouteContext);
          let routeMatch = matches[matches.length - 1];
          return routeMatch ? routeMatch.params : {};
        }
        function useResolvedPath2(to) {
          let {
            matches
          } = React4.useContext(RouteContext);
          let {
            pathname: locationPathname
          } = useLocation2();
          let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
          return React4.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
        }
        function useRoutes(routes2, locationArg) {
          !useInRouterContext() ? invariant(false, "useRoutes() may be used only in the context of a <Router> component.") : void 0;
          let {
            matches: parentMatches
          } = React4.useContext(RouteContext);
          let routeMatch = parentMatches[parentMatches.length - 1];
          let parentParams = routeMatch ? routeMatch.params : {};
          let parentPathname = routeMatch ? routeMatch.pathname : "/";
          let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
          let parentRoute = routeMatch && routeMatch.route;
          {
            let parentPath = parentRoute && parentRoute.path || "";
            warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
          }
          let locationFromContext = useLocation2();
          let location;
          if (locationArg) {
            var _parsedLocationArg$pa;
            let parsedLocationArg = typeof locationArg === "string" ? history.parsePath(locationArg) : locationArg;
            !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')) : void 0;
            location = parsedLocationArg;
          } else {
            location = locationFromContext;
          }
          let pathname = location.pathname || "/";
          let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
          let matches = matchRoutes(routes2, {
            pathname: remainingPathname
          });
          {
            warning(parentRoute || matches != null, 'No routes matched location "' + location.pathname + location.search + location.hash + '" ');
            warning(matches == null || matches[matches.length - 1].route.element !== void 0, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.');
          }
          return _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
            params: Object.assign({}, parentParams, match.params),
            pathname: joinPaths([parentPathnameBase, match.pathname]),
            pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
          })), parentMatches);
        }
        function _renderMatches(matches, parentMatches) {
          if (parentMatches === void 0) {
            parentMatches = [];
          }
          if (matches == null)
            return null;
          return matches.reduceRight((outlet, match, index) => {
            return /* @__PURE__ */ React4.createElement(RouteContext.Provider, {
              children: match.route.element !== void 0 ? match.route.element : outlet,
              value: {
                outlet,
                matches: parentMatches.concat(matches.slice(0, index + 1))
              }
            });
          }, null);
        }
        function MemoryRouter(_ref) {
          let {
            basename,
            children,
            initialEntries,
            initialIndex
          } = _ref;
          let historyRef = React4.useRef();
          if (historyRef.current == null) {
            historyRef.current = history.createMemoryHistory({
              initialEntries,
              initialIndex
            });
          }
          let history$1 = historyRef.current;
          let [state, setState] = React4.useState({
            action: history$1.action,
            location: history$1.location
          });
          React4.useLayoutEffect(() => history$1.listen(setState), [history$1]);
          return /* @__PURE__ */ React4.createElement(Router, {
            basename,
            children,
            location: state.location,
            navigationType: state.action,
            navigator: history$1
          });
        }
        function Navigate(_ref2) {
          let {
            to,
            replace,
            state
          } = _ref2;
          !useInRouterContext() ? invariant(false, "<Navigate> may be used only in the context of a <Router> component.") : void 0;
          warning(!React4.useContext(NavigationContext).static, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
          let navigate = useNavigate2();
          React4.useEffect(() => {
            navigate(to, {
              replace,
              state
            });
          });
          return null;
        }
        function Outlet2(props) {
          return useOutlet2(props.context);
        }
        function Route(_props) {
          invariant(false, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.");
        }
        function Router(_ref3) {
          let {
            basename: basenameProp = "/",
            children = null,
            location: locationProp,
            navigationType = history.Action.Pop,
            navigator,
            static: staticProp = false
          } = _ref3;
          !!useInRouterContext() ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : void 0;
          let basename = normalizePathname(basenameProp);
          let navigationContext = React4.useMemo(() => ({
            basename,
            navigator,
            static: staticProp
          }), [basename, navigator, staticProp]);
          if (typeof locationProp === "string") {
            locationProp = history.parsePath(locationProp);
          }
          let {
            pathname = "/",
            search = "",
            hash = "",
            state = null,
            key = "default"
          } = locationProp;
          let location = React4.useMemo(() => {
            let trailingPathname = stripBasename(pathname, basename);
            if (trailingPathname == null) {
              return null;
            }
            return {
              pathname: trailingPathname,
              search,
              hash,
              state,
              key
            };
          }, [basename, pathname, search, hash, state, key]);
          warning(location != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything.");
          if (location == null) {
            return null;
          }
          return /* @__PURE__ */ React4.createElement(NavigationContext.Provider, {
            value: navigationContext
          }, /* @__PURE__ */ React4.createElement(LocationContext.Provider, {
            children,
            value: {
              location,
              navigationType
            }
          }));
        }
        function Routes(_ref4) {
          let {
            children,
            location
          } = _ref4;
          return useRoutes(createRoutesFromChildren(children), location);
        }
        function createRoutesFromChildren(children) {
          let routes2 = [];
          React4.Children.forEach(children, (element) => {
            if (!/* @__PURE__ */ React4.isValidElement(element)) {
              return;
            }
            if (element.type === React4.Fragment) {
              routes2.push.apply(routes2, createRoutesFromChildren(element.props.children));
              return;
            }
            !(element.type === Route) ? invariant(false, "[" + (typeof element.type === "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : void 0;
            let route = {
              caseSensitive: element.props.caseSensitive,
              element: element.props.element,
              index: element.props.index,
              path: element.props.path
            };
            if (element.props.children) {
              route.children = createRoutesFromChildren(element.props.children);
            }
            routes2.push(route);
          });
          return routes2;
        }
        function renderMatches(matches) {
          return _renderMatches(matches);
        }
        Object.defineProperty(exports2, "NavigationType", {
          enumerable: true,
          get: function() {
            return history.Action;
          }
        });
        Object.defineProperty(exports2, "createPath", {
          enumerable: true,
          get: function() {
            return history.createPath;
          }
        });
        Object.defineProperty(exports2, "parsePath", {
          enumerable: true,
          get: function() {
            return history.parsePath;
          }
        });
        exports2.MemoryRouter = MemoryRouter;
        exports2.Navigate = Navigate;
        exports2.Outlet = Outlet2;
        exports2.Route = Route;
        exports2.Router = Router;
        exports2.Routes = Routes;
        exports2.UNSAFE_LocationContext = LocationContext;
        exports2.UNSAFE_NavigationContext = NavigationContext;
        exports2.UNSAFE_RouteContext = RouteContext;
        exports2.createRoutesFromChildren = createRoutesFromChildren;
        exports2.generatePath = generatePath;
        exports2.matchPath = matchPath;
        exports2.matchRoutes = matchRoutes;
        exports2.renderMatches = renderMatches;
        exports2.resolvePath = resolvePath;
        exports2.useHref = useHref2;
        exports2.useInRouterContext = useInRouterContext;
        exports2.useLocation = useLocation2;
        exports2.useMatch = useMatch;
        exports2.useNavigate = useNavigate2;
        exports2.useNavigationType = useNavigationType2;
        exports2.useOutlet = useOutlet2;
        exports2.useOutletContext = useOutletContext2;
        exports2.useParams = useParams2;
        exports2.useResolvedPath = useResolvedPath2;
        exports2.useRoutes = useRoutes;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/react-router/main.js
  var require_main2 = __commonJS({
    "node_modules/react-router/main.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_router_development();
      }
    }
  });

  // node_modules/react-router-dom/umd/react-router-dom.development.js
  var require_react_router_dom_development = __commonJS({
    "node_modules/react-router-dom/umd/react-router-dom.development.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_react(), require_main(), require_main2()) : typeof define === "function" && define.amd ? define(["exports", "react", "history", "react-router"], factory) : (global2 = global2 || self, factory(global2.ReactRouterDOM = {}, global2.React, global2.HistoryLibrary, global2.ReactRouter));
      })(exports, function(exports2, React4, history, reactRouter) {
        "use strict";
        function _extends6() {
          _extends6 = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends6.apply(this, arguments);
        }
        function _objectWithoutPropertiesLoose2(source, excluded) {
          if (source == null)
            return {};
          var target = {};
          var sourceKeys = Object.keys(source);
          var key, i;
          for (i = 0; i < sourceKeys.length; i++) {
            key = sourceKeys[i];
            if (excluded.indexOf(key) >= 0)
              continue;
            target[key] = source[key];
          }
          return target;
        }
        const _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
        function warning(cond, message) {
          if (!cond) {
            if (typeof console !== "undefined")
              console.warn(message);
            try {
              throw new Error(message);
            } catch (e) {
            }
          }
        }
        function BrowserRouter(_ref) {
          let {
            basename,
            children,
            window: window2
          } = _ref;
          let historyRef = React4.useRef();
          if (historyRef.current == null) {
            historyRef.current = history.createBrowserHistory({
              window: window2
            });
          }
          let history$1 = historyRef.current;
          let [state, setState] = React4.useState({
            action: history$1.action,
            location: history$1.location
          });
          React4.useLayoutEffect(() => history$1.listen(setState), [history$1]);
          return /* @__PURE__ */ React4.createElement(reactRouter.Router, {
            basename,
            children,
            location: state.location,
            navigationType: state.action,
            navigator: history$1
          });
        }
        function HashRouter(_ref2) {
          let {
            basename,
            children,
            window: window2
          } = _ref2;
          let historyRef = React4.useRef();
          if (historyRef.current == null) {
            historyRef.current = history.createHashHistory({
              window: window2
            });
          }
          let history$1 = historyRef.current;
          let [state, setState] = React4.useState({
            action: history$1.action,
            location: history$1.location
          });
          React4.useLayoutEffect(() => history$1.listen(setState), [history$1]);
          return /* @__PURE__ */ React4.createElement(reactRouter.Router, {
            basename,
            children,
            location: state.location,
            navigationType: state.action,
            navigator: history$1
          });
        }
        function HistoryRouter(_ref3) {
          let {
            basename,
            children,
            history: history2
          } = _ref3;
          const [state, setState] = React4.useState({
            action: history2.action,
            location: history2.location
          });
          React4.useLayoutEffect(() => history2.listen(setState), [history2]);
          return /* @__PURE__ */ React4.createElement(reactRouter.Router, {
            basename,
            children,
            location: state.location,
            navigationType: state.action,
            navigator: history2
          });
        }
        {
          HistoryRouter.displayName = "unstable_HistoryRouter";
        }
        function isModifiedEvent(event) {
          return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
        }
        const Link2 = /* @__PURE__ */ React4.forwardRef(function LinkWithRef(_ref4, ref) {
          let {
            onClick,
            reloadDocument,
            replace = false,
            state,
            target,
            to
          } = _ref4, rest = _objectWithoutPropertiesLoose2(_ref4, _excluded);
          let href = reactRouter.useHref(to);
          let internalOnClick = useLinkClickHandler(to, {
            replace,
            state,
            target
          });
          function handleClick(event) {
            if (onClick)
              onClick(event);
            if (!event.defaultPrevented && !reloadDocument) {
              internalOnClick(event);
            }
          }
          return /* @__PURE__ */ React4.createElement("a", _extends6({}, rest, {
            href,
            onClick: handleClick,
            ref,
            target
          }));
        });
        {
          Link2.displayName = "Link";
        }
        const NavLink2 = /* @__PURE__ */ React4.forwardRef(function NavLinkWithRef(_ref5, ref) {
          let {
            "aria-current": ariaCurrentProp = "page",
            caseSensitive = false,
            className: classNameProp = "",
            end = false,
            style: styleProp,
            to,
            children
          } = _ref5, rest = _objectWithoutPropertiesLoose2(_ref5, _excluded2);
          let location = reactRouter.useLocation();
          let path = reactRouter.useResolvedPath(to);
          let locationPathname = location.pathname;
          let toPathname = path.pathname;
          if (!caseSensitive) {
            locationPathname = locationPathname.toLowerCase();
            toPathname = toPathname.toLowerCase();
          }
          let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
          let ariaCurrent = isActive ? ariaCurrentProp : void 0;
          let className;
          if (typeof classNameProp === "function") {
            className = classNameProp({
              isActive
            });
          } else {
            className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
          }
          let style = typeof styleProp === "function" ? styleProp({
            isActive
          }) : styleProp;
          return /* @__PURE__ */ React4.createElement(Link2, _extends6({}, rest, {
            "aria-current": ariaCurrent,
            className,
            ref,
            style,
            to
          }), typeof children === "function" ? children({
            isActive
          }) : children);
        });
        {
          NavLink2.displayName = "NavLink";
        }
        function useLinkClickHandler(to, _temp) {
          let {
            target,
            replace: replaceProp,
            state
          } = _temp === void 0 ? {} : _temp;
          let navigate = reactRouter.useNavigate();
          let location = reactRouter.useLocation();
          let path = reactRouter.useResolvedPath(to);
          return React4.useCallback((event) => {
            if (event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
              event.preventDefault();
              let replace = !!replaceProp || reactRouter.createPath(location) === reactRouter.createPath(path);
              navigate(to, {
                replace,
                state
              });
            }
          }, [location, navigate, path, replaceProp, state, target, to]);
        }
        function useSearchParams2(defaultInit) {
          warning(typeof URLSearchParams !== "undefined", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\n\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.");
          let defaultSearchParamsRef = React4.useRef(createSearchParams(defaultInit));
          let location = reactRouter.useLocation();
          let searchParams = React4.useMemo(() => {
            let searchParams2 = createSearchParams(location.search);
            for (let key of defaultSearchParamsRef.current.keys()) {
              if (!searchParams2.has(key)) {
                defaultSearchParamsRef.current.getAll(key).forEach((value) => {
                  searchParams2.append(key, value);
                });
              }
            }
            return searchParams2;
          }, [location.search]);
          let navigate = reactRouter.useNavigate();
          let setSearchParams = React4.useCallback((nextInit, navigateOptions) => {
            navigate("?" + createSearchParams(nextInit), navigateOptions);
          }, [navigate]);
          return [searchParams, setSearchParams];
        }
        function createSearchParams(init) {
          if (init === void 0) {
            init = "";
          }
          return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
            let value = init[key];
            return memo.concat(Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);
          }, []));
        }
        Object.defineProperty(exports2, "MemoryRouter", {
          enumerable: true,
          get: function() {
            return reactRouter.MemoryRouter;
          }
        });
        Object.defineProperty(exports2, "Navigate", {
          enumerable: true,
          get: function() {
            return reactRouter.Navigate;
          }
        });
        Object.defineProperty(exports2, "NavigationType", {
          enumerable: true,
          get: function() {
            return reactRouter.NavigationType;
          }
        });
        Object.defineProperty(exports2, "Outlet", {
          enumerable: true,
          get: function() {
            return reactRouter.Outlet;
          }
        });
        Object.defineProperty(exports2, "Route", {
          enumerable: true,
          get: function() {
            return reactRouter.Route;
          }
        });
        Object.defineProperty(exports2, "Router", {
          enumerable: true,
          get: function() {
            return reactRouter.Router;
          }
        });
        Object.defineProperty(exports2, "Routes", {
          enumerable: true,
          get: function() {
            return reactRouter.Routes;
          }
        });
        Object.defineProperty(exports2, "UNSAFE_LocationContext", {
          enumerable: true,
          get: function() {
            return reactRouter.UNSAFE_LocationContext;
          }
        });
        Object.defineProperty(exports2, "UNSAFE_NavigationContext", {
          enumerable: true,
          get: function() {
            return reactRouter.UNSAFE_NavigationContext;
          }
        });
        Object.defineProperty(exports2, "UNSAFE_RouteContext", {
          enumerable: true,
          get: function() {
            return reactRouter.UNSAFE_RouteContext;
          }
        });
        Object.defineProperty(exports2, "createPath", {
          enumerable: true,
          get: function() {
            return reactRouter.createPath;
          }
        });
        Object.defineProperty(exports2, "createRoutesFromChildren", {
          enumerable: true,
          get: function() {
            return reactRouter.createRoutesFromChildren;
          }
        });
        Object.defineProperty(exports2, "generatePath", {
          enumerable: true,
          get: function() {
            return reactRouter.generatePath;
          }
        });
        Object.defineProperty(exports2, "matchPath", {
          enumerable: true,
          get: function() {
            return reactRouter.matchPath;
          }
        });
        Object.defineProperty(exports2, "matchRoutes", {
          enumerable: true,
          get: function() {
            return reactRouter.matchRoutes;
          }
        });
        Object.defineProperty(exports2, "parsePath", {
          enumerable: true,
          get: function() {
            return reactRouter.parsePath;
          }
        });
        Object.defineProperty(exports2, "renderMatches", {
          enumerable: true,
          get: function() {
            return reactRouter.renderMatches;
          }
        });
        Object.defineProperty(exports2, "resolvePath", {
          enumerable: true,
          get: function() {
            return reactRouter.resolvePath;
          }
        });
        Object.defineProperty(exports2, "useHref", {
          enumerable: true,
          get: function() {
            return reactRouter.useHref;
          }
        });
        Object.defineProperty(exports2, "useInRouterContext", {
          enumerable: true,
          get: function() {
            return reactRouter.useInRouterContext;
          }
        });
        Object.defineProperty(exports2, "useLocation", {
          enumerable: true,
          get: function() {
            return reactRouter.useLocation;
          }
        });
        Object.defineProperty(exports2, "useMatch", {
          enumerable: true,
          get: function() {
            return reactRouter.useMatch;
          }
        });
        Object.defineProperty(exports2, "useNavigate", {
          enumerable: true,
          get: function() {
            return reactRouter.useNavigate;
          }
        });
        Object.defineProperty(exports2, "useNavigationType", {
          enumerable: true,
          get: function() {
            return reactRouter.useNavigationType;
          }
        });
        Object.defineProperty(exports2, "useOutlet", {
          enumerable: true,
          get: function() {
            return reactRouter.useOutlet;
          }
        });
        Object.defineProperty(exports2, "useOutletContext", {
          enumerable: true,
          get: function() {
            return reactRouter.useOutletContext;
          }
        });
        Object.defineProperty(exports2, "useParams", {
          enumerable: true,
          get: function() {
            return reactRouter.useParams;
          }
        });
        Object.defineProperty(exports2, "useResolvedPath", {
          enumerable: true,
          get: function() {
            return reactRouter.useResolvedPath;
          }
        });
        Object.defineProperty(exports2, "useRoutes", {
          enumerable: true,
          get: function() {
            return reactRouter.useRoutes;
          }
        });
        exports2.BrowserRouter = BrowserRouter;
        exports2.HashRouter = HashRouter;
        exports2.Link = Link2;
        exports2.NavLink = NavLink2;
        exports2.createSearchParams = createSearchParams;
        exports2.unstable_HistoryRouter = HistoryRouter;
        exports2.useLinkClickHandler = useLinkClickHandler;
        exports2.useSearchParams = useSearchParams2;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/react-router-dom/main.js
  var require_main3 = __commonJS({
    "node_modules/react-router-dom/main.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_router_dom_development();
      }
    }
  });

  // node_modules/@remix-run/server-runtime/routeMatching.js
  var require_routeMatching = __commonJS({
    "node_modules/@remix-run/server-runtime/routeMatching.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var reactRouterDom = require_main3();
      function matchServerRoutes(routes2, pathname) {
        let matches = reactRouterDom.matchRoutes(routes2, pathname);
        if (!matches)
          return null;
        return matches.map((match) => ({
          params: match.params,
          pathname: match.pathname,
          route: match.route
        }));
      }
      exports.matchServerRoutes = matchServerRoutes;
    }
  });

  // node_modules/@remix-run/server-runtime/routes.js
  var require_routes = __commonJS({
    "node_modules/@remix-run/server-runtime/routes.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function createRoutes(manifest, parentId) {
        return Object.entries(manifest).filter(([, route]) => route.parentId === parentId).map(([id, route]) => ({
          ...route,
          children: createRoutes(manifest, id)
        }));
      }
      exports.createRoutes = createRoutes;
    }
  });

  // node_modules/jsesc/jsesc.js
  var require_jsesc = __commonJS({
    "node_modules/jsesc/jsesc.js"(exports, module) {
      "use strict";
      var object2 = {};
      var hasOwnProperty = object2.hasOwnProperty;
      var forOwn = (object3, callback) => {
        for (const key in object3) {
          if (hasOwnProperty.call(object3, key)) {
            callback(key, object3[key]);
          }
        }
      };
      var extend = (destination, source) => {
        if (!source) {
          return destination;
        }
        forOwn(source, (key, value) => {
          destination[key] = value;
        });
        return destination;
      };
      var forEach2 = (array2, callback) => {
        const length = array2.length;
        let index = -1;
        while (++index < length) {
          callback(array2[index]);
        }
      };
      var fourHexEscape = (hex) => {
        return "\\u" + ("0000" + hex).slice(-4);
      };
      var hexadecimal = (code, lowercase) => {
        let hexadecimal2 = code.toString(16);
        if (lowercase)
          return hexadecimal2;
        return hexadecimal2.toUpperCase();
      };
      var toString2 = object2.toString;
      var isArray = Array.isArray;
      var isBuffer = (value) => {
        return typeof Buffer === "function" && Buffer.isBuffer(value);
      };
      var isObject2 = (value) => {
        return toString2.call(value) == "[object Object]";
      };
      var isString = (value) => {
        return typeof value == "string" || toString2.call(value) == "[object String]";
      };
      var isNumber = (value) => {
        return typeof value == "number" || toString2.call(value) == "[object Number]";
      };
      var isFunction = (value) => {
        return typeof value == "function";
      };
      var isMap = (value) => {
        return toString2.call(value) == "[object Map]";
      };
      var isSet = (value) => {
        return toString2.call(value) == "[object Set]";
      };
      var singleEscapes = {
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t"
      };
      var regexSingleEscape = /[\\\b\f\n\r\t]/;
      var regexDigit = /[0-9]/;
      var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
      var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
      var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
      var jsesc = (argument, options) => {
        const increaseIndentation = () => {
          oldIndent = indent;
          ++options.indentLevel;
          indent = options.indent.repeat(options.indentLevel);
        };
        const defaults = {
          "escapeEverything": false,
          "minimal": false,
          "isScriptContext": false,
          "quotes": "single",
          "wrap": false,
          "es6": false,
          "json": false,
          "compact": true,
          "lowercaseHex": false,
          "numbers": "decimal",
          "indent": "	",
          "indentLevel": 0,
          "__inline1__": false,
          "__inline2__": false
        };
        const json2 = options && options.json;
        if (json2) {
          defaults.quotes = "double";
          defaults.wrap = true;
        }
        options = extend(defaults, options);
        if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
          options.quotes = "single";
        }
        const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
        const compact = options.compact;
        const lowercaseHex = options.lowercaseHex;
        let indent = options.indent.repeat(options.indentLevel);
        let oldIndent = "";
        const inline1 = options.__inline1__;
        const inline2 = options.__inline2__;
        const newLine = compact ? "" : "\n";
        let result;
        let isEmpty = true;
        const useBinNumbers = options.numbers == "binary";
        const useOctNumbers = options.numbers == "octal";
        const useDecNumbers = options.numbers == "decimal";
        const useHexNumbers = options.numbers == "hexadecimal";
        if (json2 && argument && isFunction(argument.toJSON)) {
          argument = argument.toJSON();
        }
        if (!isString(argument)) {
          if (isMap(argument)) {
            if (argument.size == 0) {
              return "new Map()";
            }
            if (!compact) {
              options.__inline1__ = true;
              options.__inline2__ = false;
            }
            return "new Map(" + jsesc(Array.from(argument), options) + ")";
          }
          if (isSet(argument)) {
            if (argument.size == 0) {
              return "new Set()";
            }
            return "new Set(" + jsesc(Array.from(argument), options) + ")";
          }
          if (isBuffer(argument)) {
            if (argument.length == 0) {
              return "Buffer.from([])";
            }
            return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
          }
          if (isArray(argument)) {
            result = [];
            options.wrap = true;
            if (inline1) {
              options.__inline1__ = false;
              options.__inline2__ = true;
            }
            if (!inline2) {
              increaseIndentation();
            }
            forEach2(argument, (value) => {
              isEmpty = false;
              if (inline2) {
                options.__inline2__ = false;
              }
              result.push((compact || inline2 ? "" : indent) + jsesc(value, options));
            });
            if (isEmpty) {
              return "[]";
            }
            if (inline2) {
              return "[" + result.join(", ") + "]";
            }
            return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
          } else if (isNumber(argument)) {
            if (json2) {
              return JSON.stringify(argument);
            }
            if (useDecNumbers) {
              return String(argument);
            }
            if (useHexNumbers) {
              let hexadecimal2 = argument.toString(16);
              if (!lowercaseHex) {
                hexadecimal2 = hexadecimal2.toUpperCase();
              }
              return "0x" + hexadecimal2;
            }
            if (useBinNumbers) {
              return "0b" + argument.toString(2);
            }
            if (useOctNumbers) {
              return "0o" + argument.toString(8);
            }
          } else if (!isObject2(argument)) {
            if (json2) {
              return JSON.stringify(argument) || "null";
            }
            return String(argument);
          } else {
            result = [];
            options.wrap = true;
            increaseIndentation();
            forOwn(argument, (key, value) => {
              isEmpty = false;
              result.push((compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value, options));
            });
            if (isEmpty) {
              return "{}";
            }
            return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
          }
        }
        const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
        result = argument.replace(regex, (char, pair, lone, quoteChar, index, string2) => {
          if (pair) {
            if (options.minimal)
              return pair;
            const first = pair.charCodeAt(0);
            const second = pair.charCodeAt(1);
            if (options.es6) {
              const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
              const hex2 = hexadecimal(codePoint, lowercaseHex);
              return "\\u{" + hex2 + "}";
            }
            return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
          }
          if (lone) {
            return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
          }
          if (char == "\0" && !json2 && !regexDigit.test(string2.charAt(index + 1))) {
            return "\\0";
          }
          if (quoteChar) {
            if (quoteChar == quote || options.escapeEverything) {
              return "\\" + quoteChar;
            }
            return quoteChar;
          }
          if (regexSingleEscape.test(char)) {
            return singleEscapes[char];
          }
          if (options.minimal && !regexWhitespace.test(char)) {
            return char;
          }
          const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
          if (json2 || hex.length > 2) {
            return fourHexEscape(hex);
          }
          return "\\x" + ("00" + hex).slice(-2);
        });
        if (quote == "`") {
          result = result.replace(/\$\{/g, "\\${");
        }
        if (options.isScriptContext) {
          result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json2 ? "\\u003C!--" : "\\x3C!--");
        }
        if (options.wrap) {
          result = quote + result + quote;
        }
        return result;
      };
      jsesc.version = "3.0.2";
      module.exports = jsesc;
    }
  });

  // node_modules/@remix-run/server-runtime/serverHandoff.js
  var require_serverHandoff = __commonJS({
    "node_modules/@remix-run/server-runtime/serverHandoff.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var jsesc = require_jsesc();
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var jsesc__default = /* @__PURE__ */ _interopDefaultLegacy(jsesc);
      function createServerHandoffString(serverHandoff) {
        return jsesc__default["default"](serverHandoff, {
          isScriptContext: true
        });
      }
      exports.createServerHandoffString = createServerHandoffString;
    }
  });

  // node_modules/@remix-run/server-runtime/server.js
  var require_server = __commonJS({
    "node_modules/@remix-run/server-runtime/server.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var data = require_data();
      var entry2 = require_entry();
      var errors = require_errors();
      var headers2 = require_headers();
      var mode = require_mode();
      var routeMatching = require_routeMatching();
      var routes2 = require_routes();
      var responses = require_responses();
      var serverHandoff = require_serverHandoff();
      var createRequestHandler2 = (build, mode$1) => {
        let routes$1 = routes2.createRoutes(build.routes);
        let serverMode = mode.isServerMode(mode$1) ? mode$1 : mode.ServerMode.Production;
        return async function requestHandler(request, loadContext) {
          let url = new URL(request.url);
          let matches = routeMatching.matchServerRoutes(routes$1, url.pathname);
          let response;
          if (url.searchParams.has("_data")) {
            response = await handleDataRequest({
              request,
              loadContext,
              matches,
              handleDataRequest: build.entry.module.handleDataRequest,
              serverMode
            });
          } else if (matches && !matches[matches.length - 1].route.module.default) {
            response = await handleResourceRequest({
              request,
              loadContext,
              matches,
              serverMode
            });
          } else {
            response = await handleDocumentRequest({
              build,
              loadContext,
              matches,
              request,
              routes: routes$1,
              serverMode
            });
          }
          if (request.method === "HEAD") {
            return new Response(null, {
              headers: response.headers,
              status: response.status,
              statusText: response.statusText
            });
          }
          return response;
        };
      };
      async function handleDataRequest({
        handleDataRequest: handleDataRequest2,
        loadContext,
        matches,
        request,
        serverMode
      }) {
        if (!isValidRequestMethod(request)) {
          return errorBoundaryError(new Error(`Invalid request method "${request.method}"`), 405);
        }
        let url = new URL(request.url);
        if (!matches) {
          return errorBoundaryError(new Error(`No route matches URL "${url.pathname}"`), 404);
        }
        let response;
        let match;
        try {
          if (isActionRequest(request)) {
            match = getRequestMatch(url, matches);
            response = await data.callRouteAction({
              loadContext,
              match,
              request
            });
          } else {
            let routeId = url.searchParams.get("_data");
            if (!routeId) {
              return errorBoundaryError(new Error(`Missing route id in ?_data`), 403);
            }
            let tempMatch = matches.find((match2) => match2.route.id === routeId);
            if (!tempMatch) {
              return errorBoundaryError(new Error(`Route "${routeId}" does not match URL "${url.pathname}"`), 403);
            }
            match = tempMatch;
            response = await data.callRouteLoader({
              loadContext,
              match,
              request
            });
          }
          if (responses.isRedirectResponse(response)) {
            let headers3 = new Headers(response.headers);
            headers3.set("X-Remix-Redirect", headers3.get("Location"));
            headers3.delete("Location");
            if (response.headers.get("Set-Cookie") !== null) {
              headers3.set("X-Remix-Revalidate", "yes");
            }
            return new Response(null, {
              status: 204,
              headers: headers3
            });
          }
          if (handleDataRequest2) {
            response = await handleDataRequest2(response, {
              context: loadContext,
              params: match.params,
              request
            });
          }
          return response;
        } catch (error) {
          if (serverMode !== mode.ServerMode.Test) {
            console.error(error);
          }
          if (serverMode === mode.ServerMode.Development) {
            return errorBoundaryError(error, 500);
          }
          return errorBoundaryError(new Error("Unexpected Server Error"), 500);
        }
      }
      async function handleDocumentRequest({
        build,
        loadContext,
        matches,
        request,
        routes: routes3,
        serverMode
      }) {
        let url = new URL(request.url);
        let appState = {
          trackBoundaries: true,
          trackCatchBoundaries: true,
          catchBoundaryRouteId: null,
          renderBoundaryRouteId: null,
          loaderBoundaryRouteId: null,
          error: void 0,
          catch: void 0
        };
        if (!isValidRequestMethod(request)) {
          matches = null;
          appState.trackCatchBoundaries = false;
          appState.catch = {
            data: null,
            status: 405,
            statusText: "Method Not Allowed"
          };
        } else if (!matches) {
          appState.trackCatchBoundaries = false;
          appState.catch = {
            data: null,
            status: 404,
            statusText: "Not Found"
          };
        }
        let actionStatus;
        let actionData;
        let actionMatch;
        let actionResponse;
        if (matches && isActionRequest(request)) {
          actionMatch = getRequestMatch(url, matches);
          try {
            actionResponse = await data.callRouteAction({
              loadContext,
              match: actionMatch,
              request
            });
            if (responses.isRedirectResponse(actionResponse)) {
              return actionResponse;
            }
            actionStatus = {
              status: actionResponse.status,
              statusText: actionResponse.statusText
            };
            if (responses.isCatchResponse(actionResponse)) {
              appState.catchBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "CatchBoundary");
              appState.trackCatchBoundaries = false;
              appState.catch = {
                ...actionStatus,
                data: await data.extractData(actionResponse)
              };
            } else {
              actionData = {
                [actionMatch.route.id]: await data.extractData(actionResponse)
              };
            }
          } catch (error) {
            appState.loaderBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "ErrorBoundary");
            appState.trackBoundaries = false;
            appState.error = await errors.serializeError(error);
            if (serverMode !== mode.ServerMode.Test) {
              console.error(`There was an error running the action for route ${actionMatch.route.id}`);
            }
          }
        }
        let routeModules = entry2.createEntryRouteModules(build.routes);
        let matchesToLoad = matches || [];
        if (appState.catch) {
          matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad, "CatchBoundary").slice(0, -1);
        } else if (appState.error) {
          matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad, "ErrorBoundary").slice(0, -1);
        }
        let loaderRequest = new Request(request.url, {
          body: null,
          headers: request.headers,
          method: request.method,
          redirect: request.redirect,
          signal: request.signal
        });
        let routeLoaderResults = await Promise.allSettled(matchesToLoad.map((match) => match.route.module.loader ? data.callRouteLoader({
          loadContext,
          match,
          request: loaderRequest
        }) : Promise.resolve(void 0)));
        let actionCatch = appState.catch;
        let actionError = appState.error;
        let actionCatchBoundaryRouteId = appState.catchBoundaryRouteId;
        let actionLoaderBoundaryRouteId = appState.loaderBoundaryRouteId;
        appState.catch = void 0;
        appState.error = void 0;
        let routeLoaderResponses = {};
        let loaderStatusCodes = [];
        let routeData = {};
        for (let index = 0; index < matchesToLoad.length; index++) {
          let match = matchesToLoad[index];
          let result = routeLoaderResults[index];
          let error = result.status === "rejected" ? result.reason : void 0;
          let response = result.status === "fulfilled" ? result.value : void 0;
          let isRedirect = response ? responses.isRedirectResponse(response) : false;
          let isCatch = response ? responses.isCatchResponse(response) : false;
          if (appState.catch || appState.error) {
            break;
          }
          if (!actionCatch && !actionError && response && isRedirect) {
            return response;
          }
          if (match.route.module.CatchBoundary) {
            appState.catchBoundaryRouteId = match.route.id;
          }
          if (match.route.module.ErrorBoundary) {
            appState.loaderBoundaryRouteId = match.route.id;
          }
          if (error) {
            loaderStatusCodes.push(500);
            appState.trackBoundaries = false;
            appState.error = await errors.serializeError(error);
            if (serverMode !== mode.ServerMode.Test) {
              console.error(`There was an error running the data loader for route ${match.route.id}`);
            }
            break;
          } else if (response) {
            routeLoaderResponses[match.route.id] = response;
            loaderStatusCodes.push(response.status);
            if (isCatch) {
              appState.trackCatchBoundaries = false;
              appState.catch = {
                data: await data.extractData(response),
                status: response.status,
                statusText: response.statusText
              };
              break;
            } else {
              routeData[match.route.id] = await data.extractData(response);
            }
          }
        }
        if (!appState.catch) {
          appState.catchBoundaryRouteId = actionCatchBoundaryRouteId;
        }
        if (!appState.error) {
          appState.loaderBoundaryRouteId = actionLoaderBoundaryRouteId;
        }
        appState.catch = actionCatch || appState.catch;
        appState.error = actionError || appState.error;
        let renderableMatches = getRenderableMatches(matches, appState);
        if (!renderableMatches) {
          renderableMatches = [];
          let root = routes3[0];
          if (root !== null && root !== void 0 && root.module.CatchBoundary) {
            appState.catchBoundaryRouteId = "root";
            renderableMatches.push({
              params: {},
              pathname: "",
              route: routes3[0]
            });
          }
        }
        let notOkResponse = actionStatus && actionStatus.status !== 200 ? actionStatus.status : loaderStatusCodes.find((status) => status !== 200);
        let responseStatusCode = appState.error ? 500 : typeof notOkResponse === "number" ? notOkResponse : appState.catch ? appState.catch.status : 200;
        let responseHeaders = headers2.getDocumentHeaders(build, renderableMatches, routeLoaderResponses, actionResponse);
        let entryMatches = entry2.createEntryMatches(renderableMatches, build.assets.routes);
        let serverHandoff$1 = {
          actionData,
          appState,
          matches: entryMatches,
          routeData
        };
        let entryContext = {
          ...serverHandoff$1,
          manifest: build.assets,
          routeModules,
          serverHandoffString: serverHandoff.createServerHandoffString(serverHandoff$1)
        };
        let handleDocumentRequest2 = build.entry.module.default;
        try {
          return await handleDocumentRequest2(request, responseStatusCode, responseHeaders, entryContext);
        } catch (error) {
          responseStatusCode = 500;
          appState.trackBoundaries = false;
          appState.error = await errors.serializeError(error);
          entryContext.serverHandoffString = serverHandoff.createServerHandoffString(serverHandoff$1);
          try {
            return await handleDocumentRequest2(request, responseStatusCode, responseHeaders, entryContext);
          } catch (error2) {
            if (serverMode !== mode.ServerMode.Test) {
              console.error(error2);
            }
            let message = "Unexpected Server Error";
            if (serverMode === mode.ServerMode.Development) {
              message += `

${String(error2)}`;
            }
            return new Response(message, {
              status: 500,
              headers: {
                "Content-Type": "text/plain"
              }
            });
          }
        }
      }
      async function handleResourceRequest({
        loadContext,
        matches,
        request,
        serverMode
      }) {
        let match = matches.slice(-1)[0];
        try {
          if (isActionRequest(request)) {
            return await data.callRouteAction({
              match,
              loadContext,
              request
            });
          } else {
            return await data.callRouteLoader({
              match,
              loadContext,
              request
            });
          }
        } catch (error) {
          if (serverMode !== mode.ServerMode.Test) {
            console.error(error);
          }
          let message = "Unexpected Server Error";
          if (serverMode === mode.ServerMode.Development) {
            message += `

${String(error)}`;
          }
          return new Response(message, {
            status: 500,
            headers: {
              "Content-Type": "text/plain"
            }
          });
        }
      }
      var validActionMethods = /* @__PURE__ */ new Set(["POST", "PUT", "PATCH", "DELETE"]);
      function isActionRequest({
        method
      }) {
        return validActionMethods.has(method.toUpperCase());
      }
      var validRequestMethods = /* @__PURE__ */ new Set(["GET", "HEAD", ...validActionMethods]);
      function isValidRequestMethod({
        method
      }) {
        return validRequestMethods.has(method.toUpperCase());
      }
      async function errorBoundaryError(error, status) {
        return responses.json(await errors.serializeError(error), {
          status,
          headers: {
            "X-Remix-Error": "yes"
          }
        });
      }
      function isIndexRequestUrl(url) {
        for (let param of url.searchParams.getAll("index")) {
          if (param === "") {
            return true;
          }
        }
        return false;
      }
      function getRequestMatch(url, matches) {
        let match = matches.slice(-1)[0];
        if (!isIndexRequestUrl(url) && match.route.id.endsWith("/index")) {
          return matches.slice(-2)[0];
        }
        return match;
      }
      function getDeepestRouteIdWithBoundary(matches, key) {
        let matched = getMatchesUpToDeepestBoundary(matches, key).slice(-1)[0];
        return matched ? matched.route.id : null;
      }
      function getMatchesUpToDeepestBoundary(matches, key) {
        let deepestBoundaryIndex = -1;
        matches.forEach((match, index) => {
          if (match.route.module[key]) {
            deepestBoundaryIndex = index;
          }
        });
        if (deepestBoundaryIndex === -1) {
          return [];
        }
        return matches.slice(0, deepestBoundaryIndex + 1);
      }
      function getRenderableMatches(matches, appState) {
        if (!matches) {
          return null;
        }
        if (!appState.catch && !appState.error) {
          return matches;
        }
        let lastRenderableIndex = -1;
        matches.forEach((match, index) => {
          let id = match.route.id;
          if (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id || appState.catchBoundaryRouteId === id) {
            lastRenderableIndex = index;
          }
        });
        return matches.slice(0, lastRenderableIndex + 1);
      }
      exports.createRequestHandler = createRequestHandler2;
    }
  });

  // node_modules/@remix-run/server-runtime/sessions.js
  var require_sessions = __commonJS({
    "node_modules/@remix-run/server-runtime/sessions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var cookies = require_cookies();
      var warnings = require_warnings();
      function flash(name) {
        return `__flash_${name}__`;
      }
      var createSession2 = (initialData = {}, id = "") => {
        let map2 = new Map(Object.entries(initialData));
        return {
          get id() {
            return id;
          },
          get data() {
            return Object.fromEntries(map2);
          },
          has(name) {
            return map2.has(name) || map2.has(flash(name));
          },
          get(name) {
            if (map2.has(name))
              return map2.get(name);
            let flashName = flash(name);
            if (map2.has(flashName)) {
              let value = map2.get(flashName);
              map2.delete(flashName);
              return value;
            }
            return void 0;
          },
          set(name, value) {
            map2.set(name, value);
          },
          flash(name, value) {
            map2.set(flash(name), value);
          },
          unset(name) {
            map2.delete(name);
          }
        };
      };
      var isSession2 = (object2) => {
        return object2 != null && typeof object2.id === "string" && typeof object2.data !== "undefined" && typeof object2.has === "function" && typeof object2.get === "function" && typeof object2.set === "function" && typeof object2.flash === "function" && typeof object2.unset === "function";
      };
      var createSessionStorageFactory = (createCookie2) => ({
        cookie: cookieArg,
        createData,
        readData,
        updateData,
        deleteData
      }) => {
        let cookie = cookies.isCookie(cookieArg) ? cookieArg : createCookie2((cookieArg === null || cookieArg === void 0 ? void 0 : cookieArg.name) || "__session", cookieArg);
        warnOnceAboutSigningSessionCookie(cookie);
        return {
          async getSession(cookieHeader, options) {
            let id = cookieHeader && await cookie.parse(cookieHeader, options);
            let data = id && await readData(id);
            return createSession2(data || {}, id || "");
          },
          async commitSession(session, options) {
            let {
              id,
              data
            } = session;
            if (id) {
              await updateData(id, data, cookie.expires);
            } else {
              id = await createData(data, cookie.expires);
            }
            return cookie.serialize(id, options);
          },
          async destroySession(session, options) {
            await deleteData(session.id);
            return cookie.serialize("", {
              ...options,
              expires: new Date(0)
            });
          }
        };
      };
      function warnOnceAboutSigningSessionCookie(cookie) {
        warnings.warnOnce(cookie.isSigned, `The "${cookie.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/api/remix#signing-cookies for more information.`);
      }
      exports.createSession = createSession2;
      exports.createSessionStorageFactory = createSessionStorageFactory;
      exports.isSession = isSession2;
      exports.warnOnceAboutSigningSessionCookie = warnOnceAboutSigningSessionCookie;
    }
  });

  // node_modules/@remix-run/server-runtime/sessions/cookieStorage.js
  var require_cookieStorage = __commonJS({
    "node_modules/@remix-run/server-runtime/sessions/cookieStorage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var cookies = require_cookies();
      var sessions = require_sessions();
      var createCookieSessionStorageFactory = (createCookie2) => ({
        cookie: cookieArg
      } = {}) => {
        let cookie = cookies.isCookie(cookieArg) ? cookieArg : createCookie2((cookieArg === null || cookieArg === void 0 ? void 0 : cookieArg.name) || "__session", cookieArg);
        sessions.warnOnceAboutSigningSessionCookie(cookie);
        return {
          async getSession(cookieHeader, options) {
            return sessions.createSession(cookieHeader && await cookie.parse(cookieHeader, options) || {});
          },
          async commitSession(session, options) {
            let serializedCookie = await cookie.serialize(session.data, options);
            if (serializedCookie.length > 4096) {
              throw new Error("Cookie length will exceed browser maximum. Length: " + serializedCookie.length);
            }
            return serializedCookie;
          },
          async destroySession(_session, options) {
            return cookie.serialize("", {
              ...options,
              expires: new Date(0)
            });
          }
        };
      };
      exports.createCookieSessionStorageFactory = createCookieSessionStorageFactory;
    }
  });

  // node_modules/@remix-run/server-runtime/sessions/memoryStorage.js
  var require_memoryStorage = __commonJS({
    "node_modules/@remix-run/server-runtime/sessions/memoryStorage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var createMemorySessionStorageFactory = (createSessionStorage2) => ({
        cookie
      } = {}) => {
        let uniqueId = 0;
        let map2 = /* @__PURE__ */ new Map();
        return createSessionStorage2({
          cookie,
          async createData(data, expires) {
            let id = (++uniqueId).toString();
            map2.set(id, {
              data,
              expires
            });
            return id;
          },
          async readData(id) {
            if (map2.has(id)) {
              let {
                data,
                expires
              } = map2.get(id);
              if (!expires || expires > new Date()) {
                return data;
              }
              if (expires)
                map2.delete(id);
            }
            return null;
          },
          async updateData(id, data, expires) {
            map2.set(id, {
              data,
              expires
            });
          },
          async deleteData(id) {
            map2.delete(id);
          }
        });
      };
      exports.createMemorySessionStorageFactory = createMemorySessionStorageFactory;
    }
  });

  // node_modules/@remix-run/server-runtime/upload/errors.js
  var require_errors2 = __commonJS({
    "node_modules/@remix-run/server-runtime/upload/errors.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var MaxPartSizeExceededError = class extends Error {
        constructor(field, maxBytes) {
          super(`Field "${field}" exceeded upload size of ${maxBytes} bytes.`);
          this.field = field;
          this.maxBytes = maxBytes;
        }
      };
      exports.MaxPartSizeExceededError = MaxPartSizeExceededError;
    }
  });

  // node_modules/@remix-run/server-runtime/upload/memoryUploadHandler.js
  var require_memoryUploadHandler = __commonJS({
    "node_modules/@remix-run/server-runtime/upload/memoryUploadHandler.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var errors = require_errors2();
      function createMemoryUploadHandler({
        filter,
        maxPartSize = 3e6
      } = {}) {
        return async ({
          filename,
          contentType,
          name,
          data
        }) => {
          if (filter && !await filter({
            filename,
            contentType,
            name
          })) {
            return void 0;
          }
          let size = 0;
          let chunks = [];
          for await (let chunk of data) {
            size += chunk.byteLength;
            if (size > maxPartSize) {
              throw new errors.MaxPartSizeExceededError(name, maxPartSize);
            }
            chunks.push(chunk);
          }
          if (typeof filename === "string") {
            return new File(chunks, filename, {
              type: contentType
            });
          }
          return await new Blob(chunks, {
            type: contentType
          }).text();
        };
      }
      exports.createMemoryUploadHandler = createMemoryUploadHandler;
    }
  });

  // node_modules/@remix-run/server-runtime/index.js
  var require_server_runtime = __commonJS({
    "node_modules/@remix-run/server-runtime/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var cookies = require_cookies();
      var formData = require_formData();
      var responses = require_responses();
      var server = require_server();
      var sessions = require_sessions();
      var cookieStorage = require_cookieStorage();
      var memoryStorage = require_memoryStorage();
      var memoryUploadHandler = require_memoryUploadHandler();
      var errors = require_errors2();
      exports.createCookieFactory = cookies.createCookieFactory;
      exports.isCookie = cookies.isCookie;
      exports.unstable_composeUploadHandlers = formData.composeUploadHandlers;
      exports.unstable_parseMultipartFormData = formData.parseMultipartFormData;
      exports.json = responses.json;
      exports.redirect = responses.redirect;
      exports.createRequestHandler = server.createRequestHandler;
      exports.createSession = sessions.createSession;
      exports.createSessionStorageFactory = sessions.createSessionStorageFactory;
      exports.isSession = sessions.isSession;
      exports.createCookieSessionStorageFactory = cookieStorage.createCookieSessionStorageFactory;
      exports.createMemorySessionStorageFactory = memoryStorage.createMemorySessionStorageFactory;
      exports.unstable_createMemoryUploadHandler = memoryUploadHandler.createMemoryUploadHandler;
      exports.MaxPartSizeExceededError = errors.MaxPartSizeExceededError;
    }
  });

  // node_modules/@remix-run/cloudflare/crypto.js
  var require_crypto = __commonJS({
    "node_modules/@remix-run/cloudflare/crypto.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var encoder = new TextEncoder();
      var sign = async (value, secret) => {
        let key = await createKey(secret, ["sign"]);
        let data = encoder.encode(value);
        let signature = await crypto.subtle.sign("HMAC", key, data);
        let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, "");
        return value + "." + hash;
      };
      var unsign = async (signed, secret) => {
        let index = signed.lastIndexOf(".");
        let value = signed.slice(0, index);
        let hash = signed.slice(index + 1);
        let key = await createKey(secret, ["verify"]);
        let data = encoder.encode(value);
        let signature = byteStringToUint8Array(atob(hash));
        let valid = await crypto.subtle.verify("HMAC", key, signature, data);
        return valid ? value : false;
      };
      async function createKey(secret, usages) {
        let key = await crypto.subtle.importKey("raw", encoder.encode(secret), {
          name: "HMAC",
          hash: "SHA-256"
        }, false, usages);
        return key;
      }
      function byteStringToUint8Array(byteString) {
        let array2 = new Uint8Array(byteString.length);
        for (let i = 0; i < byteString.length; i++) {
          array2[i] = byteString.charCodeAt(i);
        }
        return array2;
      }
      exports.sign = sign;
      exports.unsign = unsign;
    }
  });

  // node_modules/@remix-run/cloudflare/implementations.js
  var require_implementations = __commonJS({
    "node_modules/@remix-run/cloudflare/implementations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var serverRuntime = require_server_runtime();
      var crypto2 = require_crypto();
      var createCookie2 = serverRuntime.createCookieFactory({
        sign: crypto2.sign,
        unsign: crypto2.unsign
      });
      var createCookieSessionStorage2 = serverRuntime.createCookieSessionStorageFactory(createCookie2);
      var createSessionStorage2 = serverRuntime.createSessionStorageFactory(createCookie2);
      var createMemorySessionStorage2 = serverRuntime.createMemorySessionStorageFactory(createSessionStorage2);
      exports.createCookie = createCookie2;
      exports.createCookieSessionStorage = createCookieSessionStorage2;
      exports.createMemorySessionStorage = createMemorySessionStorage2;
      exports.createSessionStorage = createSessionStorage2;
    }
  });

  // node_modules/@remix-run/cloudflare/sessions/cloudflareKVSessionStorage.js
  var require_cloudflareKVSessionStorage = __commonJS({
    "node_modules/@remix-run/cloudflare/sessions/cloudflareKVSessionStorage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var implementations = require_implementations();
      function createCloudflareKVSessionStorage2({
        cookie,
        kv
      }) {
        return implementations.createSessionStorage({
          cookie,
          async createData(data, expires) {
            while (true) {
              let randomBytes = new Uint8Array(8);
              crypto.getRandomValues(randomBytes);
              let id = [...randomBytes].map((x) => x.toString(16).padStart(2, "0")).join("");
              if (await kv.get(id, "json")) {
                continue;
              }
              await kv.put(id, JSON.stringify(data), {
                expiration: expires ? Math.round(expires.getTime() / 1e3) : void 0
              });
              return id;
            }
          },
          async readData(id) {
            let session = await kv.get(id);
            if (!session) {
              return null;
            }
            return JSON.parse(session);
          },
          async updateData(id, data, expires) {
            await kv.put(id, JSON.stringify(data), {
              expiration: expires ? Math.round(expires.getTime() / 1e3) : void 0
            });
          },
          async deleteData(id) {
            await kv.delete(id);
          }
        });
      }
      exports.createCloudflareKVSessionStorage = createCloudflareKVSessionStorage2;
    }
  });

  // node_modules/@remix-run/cloudflare/index.js
  var require_cloudflare = __commonJS({
    "node_modules/@remix-run/cloudflare/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var cloudflareKVSessionStorage = require_cloudflareKVSessionStorage();
      var implementations = require_implementations();
      var serverRuntime = require_server_runtime();
      exports.createCloudflareKVSessionStorage = cloudflareKVSessionStorage.createCloudflareKVSessionStorage;
      exports.createCookie = implementations.createCookie;
      exports.createCookieSessionStorage = implementations.createCookieSessionStorage;
      exports.createMemorySessionStorage = implementations.createMemorySessionStorage;
      exports.createSessionStorage = implementations.createSessionStorage;
      Object.defineProperty(exports, "MaxPartSizeExceededError", {
        enumerable: true,
        get: function() {
          return serverRuntime.MaxPartSizeExceededError;
        }
      });
      Object.defineProperty(exports, "createRequestHandler", {
        enumerable: true,
        get: function() {
          return serverRuntime.createRequestHandler;
        }
      });
      Object.defineProperty(exports, "createSession", {
        enumerable: true,
        get: function() {
          return serverRuntime.createSession;
        }
      });
      Object.defineProperty(exports, "isCookie", {
        enumerable: true,
        get: function() {
          return serverRuntime.isCookie;
        }
      });
      Object.defineProperty(exports, "isSession", {
        enumerable: true,
        get: function() {
          return serverRuntime.isSession;
        }
      });
      Object.defineProperty(exports, "json", {
        enumerable: true,
        get: function() {
          return serverRuntime.json;
        }
      });
      Object.defineProperty(exports, "redirect", {
        enumerable: true,
        get: function() {
          return serverRuntime.redirect;
        }
      });
      Object.defineProperty(exports, "unstable_composeUploadHandlers", {
        enumerable: true,
        get: function() {
          return serverRuntime.unstable_composeUploadHandlers;
        }
      });
      Object.defineProperty(exports, "unstable_createMemoryUploadHandler", {
        enumerable: true,
        get: function() {
          return serverRuntime.unstable_createMemoryUploadHandler;
        }
      });
      Object.defineProperty(exports, "unstable_parseMultipartFormData", {
        enumerable: true,
        get: function() {
          return serverRuntime.unstable_parseMultipartFormData;
        }
      });
    }
  });

  // node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
  var require_react_dom_server_legacy_browser_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React4 = require_react();
          var ReactVersion = "18.2.0";
          var ReactSharedInternals = React4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function warn(format) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format, args);
              }
            }
          }
          function error(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          function scheduleWork(callback) {
            callback();
          }
          function beginWriting(destination) {
          }
          function writeChunk(destination, chunk) {
            writeChunkAndReturn(destination, chunk);
          }
          function writeChunkAndReturn(destination, chunk) {
            return destination.push(chunk);
          }
          function completeWriting(destination) {
          }
          function close(destination) {
            destination.push(null);
          }
          function stringToChunk(content) {
            return content;
          }
          function stringToPrecomputedChunk(content) {
            return content;
          }
          function closeWithError(destination, error2) {
            destination.destroy(error2);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkAttributeStringCoercion(value, attributeName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkCSSPropertyStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkHtmlStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  return prefix2 !== "data-" && prefix2 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function getPropertyInfo(name) {
            return properties.hasOwnProperty(name) ? properties[name] : null;
          }
          function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name = _ref[0], attributeName = _ref[1];
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
          });
          [
            "allowFullScreen",
            "async",
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            "itemScope"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
          });
          [
            "checked",
            "multiple",
            "muted",
            "selected"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
          });
          [
            "capture",
            "download"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
          });
          [
            "cols",
            "rows",
            "size",
            "span"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
          });
          ["rowSpan", "start"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
          });
          var isUnitlessNumber = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix2, key) {
            return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes2 = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes2.forEach(function(prefix2) {
              isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
            });
          });
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var ariaProperties = {
            "aria-current": 0,
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            "aria-hidden": 0,
            "aria-invalid": 0,
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          function validateProperty(tagName, name) {
            {
              if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
                return true;
              }
              if (rARIACamel.test(name)) {
                var ariaName = "aria-" + name.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                  warnedProperties[name] = true;
                  return true;
                }
                if (name !== correctName) {
                  error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
              if (rARIA.test(name)) {
                var lowerCasedName = name.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name] = true;
                  return false;
                }
                if (name !== standardName) {
                  error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid = validateProperty(type, key);
                if (!isValid) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var possibleStandardNames = {
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name, value, eventRegistry) {
              if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
                return true;
              }
              var lowerCasedName = name.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (eventRegistry != null) {
                var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
                if (registrationNameDependencies.hasOwnProperty(name)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
                if (registrationName != null) {
                  error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                  warnedProperties$1[name] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name)) {
                  error("Unknown event handler property `%s`. It will be ignored.", name);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name)) {
                if (INVALID_EVENT_NAME_REGEX.test(name)) {
                  error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
                error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "number" && isNaN(value)) {
                error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
                warnedProperties$1[name] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name) {
                  error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (!isReserved && name !== lowerCasedName) {
                error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                if (value) {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
                } else {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                warnedProperties$1[name] = true;
                return false;
              }
              if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
                warnedProperties$1[name] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid = validateProperty$1(type, key, props[key], eventRegistry);
                if (!isValid) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry);
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string2) {
              return string2.replace(hyphenPattern, function(_, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern, "ms-")));
            };
            var warnBadVendoredStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name, value) {
              if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                return;
              }
              warnedStyleValues[value] = true;
              error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name, value) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error("`NaN` is an invalid value for the `%s` css style property.", name);
            };
            var warnStyleValueIsInfinity = function(name, value) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error("`Infinity` is an invalid value for the `%s` css style property.", name);
            };
            warnValidStyle = function(name, value) {
              if (name.indexOf("-") > -1) {
                warnHyphenatedStyleName(name);
              } else if (badVendoredStyleNamePattern.test(name)) {
                warnBadVendoredStyleName(name);
              } else if (badStyleValueWithSemicolonPattern.test(value)) {
                warnStyleValueWithSemicolon(name, value);
              }
              if (typeof value === "number") {
                if (isNaN(value)) {
                  warnStyleValueIsNaN(name, value);
                } else if (!isFinite(value)) {
                  warnStyleValueIsInfinity(name, value);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          var matchHtmlRegExp = /["'&<>]/;
          function escapeHtml(string2) {
            {
              checkHtmlStringCoercion(string2);
            }
            var str = "" + string2;
            var match = matchHtmlRegExp.exec(str);
            if (!match) {
              return str;
            }
            var escape2;
            var html = "";
            var index;
            var lastIndex = 0;
            for (index = match.index; index < str.length; index++) {
              switch (str.charCodeAt(index)) {
                case 34:
                  escape2 = "&quot;";
                  break;
                case 38:
                  escape2 = "&amp;";
                  break;
                case 39:
                  escape2 = "&#x27;";
                  break;
                case 60:
                  escape2 = "&lt;";
                  break;
                case 62:
                  escape2 = "&gt;";
                  break;
                default:
                  continue;
              }
              if (lastIndex !== index) {
                html += str.substring(lastIndex, index);
              }
              lastIndex = index + 1;
              html += escape2;
            }
            return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
          }
          function escapeTextForBrowser(text) {
            if (typeof text === "boolean" || typeof text === "number") {
              return "" + text;
            }
            return escapeHtml(text);
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern$1 = /^ms-/;
          function hyphenateStyleName(name) {
            return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
          }
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray(a) {
            return isArrayImpl(a);
          }
          var startInlineScript = stringToPrecomputedChunk("<script>");
          var endInlineScript = stringToPrecomputedChunk("<\/script>");
          var startScriptSrc = stringToPrecomputedChunk('<script src="');
          var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
          var endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>');
          function escapeBootstrapScriptContent(scriptText) {
            {
              checkHtmlStringCoercion(scriptText);
            }
            return ("" + scriptText).replace(scriptRegex, scriptReplacer);
          }
          var scriptRegex = /(<\/|<)(s)(cript)/gi;
          var scriptReplacer = function(match, prefix2, s, suffix) {
            return "" + prefix2 + (s === "s" ? "\\u0073" : "\\u0053") + suffix;
          };
          function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
            var idPrefix2 = identifierPrefix === void 0 ? "" : identifierPrefix;
            var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
            var bootstrapChunks = [];
            if (bootstrapScriptContent !== void 0) {
              bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
            }
            if (bootstrapScripts !== void 0) {
              for (var i = 0; i < bootstrapScripts.length; i++) {
                bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
              }
            }
            if (bootstrapModules !== void 0) {
              for (var _i = 0; _i < bootstrapModules.length; _i++) {
                bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
              }
            }
            return {
              bootstrapChunks,
              startInlineScript: inlineScriptWithNonce,
              placeholderPrefix: stringToPrecomputedChunk(idPrefix2 + "P:"),
              segmentPrefix: stringToPrecomputedChunk(idPrefix2 + "S:"),
              boundaryPrefix: idPrefix2 + "B:",
              idPrefix: idPrefix2,
              nextSuspenseID: 0,
              sentCompleteSegmentFunction: false,
              sentCompleteBoundaryFunction: false,
              sentClientRenderFunction: false
            };
          }
          var ROOT_HTML_MODE = 0;
          var HTML_MODE = 1;
          var SVG_MODE = 2;
          var MATHML_MODE = 3;
          var HTML_TABLE_MODE = 4;
          var HTML_TABLE_BODY_MODE = 5;
          var HTML_TABLE_ROW_MODE = 6;
          var HTML_COLGROUP_MODE = 7;
          function createFormatContext(insertionMode, selectedValue) {
            return {
              insertionMode,
              selectedValue
            };
          }
          function getChildFormatContext(parentContext, type, props) {
            switch (type) {
              case "select":
                return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
              case "svg":
                return createFormatContext(SVG_MODE, null);
              case "math":
                return createFormatContext(MATHML_MODE, null);
              case "foreignObject":
                return createFormatContext(HTML_MODE, null);
              case "table":
                return createFormatContext(HTML_TABLE_MODE, null);
              case "thead":
              case "tbody":
              case "tfoot":
                return createFormatContext(HTML_TABLE_BODY_MODE, null);
              case "colgroup":
                return createFormatContext(HTML_COLGROUP_MODE, null);
              case "tr":
                return createFormatContext(HTML_TABLE_ROW_MODE, null);
            }
            if (parentContext.insertionMode >= HTML_TABLE_MODE) {
              return createFormatContext(HTML_MODE, null);
            }
            if (parentContext.insertionMode === ROOT_HTML_MODE) {
              return createFormatContext(HTML_MODE, null);
            }
            return parentContext;
          }
          var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
          function assignSuspenseBoundaryID(responseState) {
            var generatedID = responseState.nextSuspenseID++;
            return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
          }
          function makeId(responseState, treeId, localId) {
            var idPrefix2 = responseState.idPrefix;
            var id = ":" + idPrefix2 + "R" + treeId;
            if (localId > 0) {
              id += "H" + localId.toString(32);
            }
            return id + ":";
          }
          function encodeHTMLTextNode(text) {
            return escapeTextForBrowser(text);
          }
          var textSeparator = stringToPrecomputedChunk("<!-- -->");
          function pushTextInstance(target, text, responseState, textEmbedded) {
            if (text === "") {
              return textEmbedded;
            }
            if (textEmbedded) {
              target.push(textSeparator);
            }
            target.push(stringToChunk(encodeHTMLTextNode(text)));
            return true;
          }
          function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
            if (lastPushedText && textEmbedded) {
              target.push(textSeparator);
            }
          }
          var styleNameCache = /* @__PURE__ */ new Map();
          function processStyleName(styleName) {
            var chunk = styleNameCache.get(styleName);
            if (chunk !== void 0) {
              return chunk;
            }
            var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
            styleNameCache.set(styleName, result);
            return result;
          }
          var styleAttributeStart = stringToPrecomputedChunk(' style="');
          var styleAssign = stringToPrecomputedChunk(":");
          var styleSeparator = stringToPrecomputedChunk(";");
          function pushStyle(target, responseState, style) {
            if (typeof style !== "object") {
              throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
            var isFirst = true;
            for (var styleName in style) {
              if (!hasOwnProperty.call(style, styleName)) {
                continue;
              }
              var styleValue = style[styleName];
              if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
                continue;
              }
              var nameChunk = void 0;
              var valueChunk = void 0;
              var isCustomProperty = styleName.indexOf("--") === 0;
              if (isCustomProperty) {
                nameChunk = stringToChunk(escapeTextForBrowser(styleName));
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              } else {
                {
                  warnValidStyle$1(styleName, styleValue);
                }
                nameChunk = processStyleName(styleName);
                if (typeof styleValue === "number") {
                  if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                    valueChunk = stringToChunk(styleValue + "px");
                  } else {
                    valueChunk = stringToChunk("" + styleValue);
                  }
                } else {
                  {
                    checkCSSPropertyStringCoercion(styleValue, styleName);
                  }
                  valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
                }
              }
              if (isFirst) {
                isFirst = false;
                target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
              } else {
                target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
              }
            }
            if (!isFirst) {
              target.push(attributeEnd);
            }
          }
          var attributeSeparator = stringToPrecomputedChunk(" ");
          var attributeAssign = stringToPrecomputedChunk('="');
          var attributeEnd = stringToPrecomputedChunk('"');
          var attributeEmptyString = stringToPrecomputedChunk('=""');
          function pushAttribute(target, responseState, name, value) {
            switch (name) {
              case "style": {
                pushStyle(target, responseState, value);
                return;
              }
              case "defaultValue":
              case "defaultChecked":
              case "innerHTML":
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                return;
            }
            if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
              return;
            }
            var propertyInfo = getPropertyInfo(name);
            if (propertyInfo !== null) {
              switch (typeof value) {
                case "function":
                case "symbol":
                  return;
                case "boolean": {
                  if (!propertyInfo.acceptsBooleans) {
                    return;
                  }
                }
              }
              var attributeName = propertyInfo.attributeName;
              var attributeNameChunk = stringToChunk(attributeName);
              switch (propertyInfo.type) {
                case BOOLEAN:
                  if (value) {
                    target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                  }
                  return;
                case OVERLOADED_BOOLEAN:
                  if (value === true) {
                    target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                  } else if (value === false)
                    ;
                  else {
                    target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                  }
                  return;
                case NUMERIC:
                  if (!isNaN(value)) {
                    target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                  }
                  break;
                case POSITIVE_NUMERIC:
                  if (!isNaN(value) && value >= 1) {
                    target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                  }
                  break;
                default:
                  if (propertyInfo.sanitizeURL) {
                    {
                      checkAttributeStringCoercion(value, attributeName);
                    }
                    value = "" + value;
                    sanitizeURL(value);
                  }
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
            } else if (isAttributeNameSafe(name)) {
              switch (typeof value) {
                case "function":
                case "symbol":
                  return;
                case "boolean": {
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  if (prefix2 !== "data-" && prefix2 !== "aria-") {
                    return;
                  }
                }
              }
              target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
            }
          }
          var endOfStartTag = stringToPrecomputedChunk(">");
          var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
          function pushInnerHTML(target, innerHTML, children) {
            if (innerHTML != null) {
              if (children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
              var html = innerHTML.__html;
              if (html !== null && html !== void 0) {
                {
                  checkHtmlStringCoercion(html);
                }
                target.push(stringToChunk("" + html));
              }
            }
          }
          var didWarnDefaultInputValue = false;
          var didWarnDefaultChecked = false;
          var didWarnDefaultSelectValue = false;
          var didWarnDefaultTextareaValue = false;
          var didWarnInvalidOptionChildren = false;
          var didWarnInvalidOptionInnerHTML = false;
          var didWarnSelectedSetOnOption = false;
          function checkSelectProp(props, propName) {
            {
              var value = props[propName];
              if (value != null) {
                var array2 = isArray(value);
                if (props.multiple && !array2) {
                  error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
                } else if (!props.multiple && array2) {
                  error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
                }
              }
            }
          }
          function pushStartSelect(target, props, responseState) {
            {
              checkControlledValueProps("select", props);
              checkSelectProp(props, "value");
              checkSelectProp(props, "defaultValue");
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
                error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnDefaultSelectValue = true;
              }
            }
            target.push(startChunkForTag("select"));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target.push(endOfStartTag);
            pushInnerHTML(target, innerHTML, children);
            return children;
          }
          function flattenOptionChildren(children) {
            var content = "";
            React4.Children.forEach(children, function(child) {
              if (child == null) {
                return;
              }
              content += child;
              {
                if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                  didWarnInvalidOptionChildren = true;
                  error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                }
              }
            });
            return content;
          }
          var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
          function pushStartOption(target, props, responseState, formatContext) {
            var selectedValue = formatContext.selectedValue;
            target.push(startChunkForTag("option"));
            var children = null;
            var value = null;
            var selected = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "selected":
                    selected = propValue;
                    {
                      if (!didWarnSelectedSetOnOption) {
                        error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                        didWarnSelectedSetOnOption = true;
                      }
                    }
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "value":
                    value = propValue;
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            if (selectedValue != null) {
              var stringValue;
              if (value !== null) {
                {
                  checkAttributeStringCoercion(value, "value");
                }
                stringValue = "" + value;
              } else {
                {
                  if (innerHTML !== null) {
                    if (!didWarnInvalidOptionInnerHTML) {
                      didWarnInvalidOptionInnerHTML = true;
                      error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                    }
                  }
                }
                stringValue = flattenOptionChildren(children);
              }
              if (isArray(selectedValue)) {
                for (var i = 0; i < selectedValue.length; i++) {
                  {
                    checkAttributeStringCoercion(selectedValue[i], "value");
                  }
                  var v = "" + selectedValue[i];
                  if (v === stringValue) {
                    target.push(selectedMarkerAttribute);
                    break;
                  }
                }
              } else {
                {
                  checkAttributeStringCoercion(selectedValue, "select.value");
                }
                if ("" + selectedValue === stringValue) {
                  target.push(selectedMarkerAttribute);
                }
              }
            } else if (selected) {
              target.push(selectedMarkerAttribute);
            }
            target.push(endOfStartTag);
            pushInnerHTML(target, innerHTML, children);
            return children;
          }
          function pushInput(target, props, responseState) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
                error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                didWarnDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
                error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                didWarnDefaultInputValue = true;
              }
            }
            target.push(startChunkForTag("input"));
            var value = null;
            var defaultValue = null;
            var checked = null;
            var defaultChecked = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  case "defaultChecked":
                    defaultChecked = propValue;
                    break;
                  case "defaultValue":
                    defaultValue = propValue;
                    break;
                  case "checked":
                    checked = propValue;
                    break;
                  case "value":
                    value = propValue;
                    break;
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            if (checked !== null) {
              pushAttribute(target, responseState, "checked", checked);
            } else if (defaultChecked !== null) {
              pushAttribute(target, responseState, "checked", defaultChecked);
            }
            if (value !== null) {
              pushAttribute(target, responseState, "value", value);
            } else if (defaultValue !== null) {
              pushAttribute(target, responseState, "value", defaultValue);
            }
            target.push(endOfStartTagSelfClosing);
            return null;
          }
          function pushStartTextArea(target, props, responseState) {
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
                error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnDefaultTextareaValue = true;
              }
            }
            target.push(startChunkForTag("textarea"));
            var value = null;
            var defaultValue = null;
            var children = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "value":
                    value = propValue;
                    break;
                  case "defaultValue":
                    defaultValue = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            if (value === null && defaultValue !== null) {
              value = defaultValue;
            }
            target.push(endOfStartTag);
            if (children != null) {
              {
                error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
              }
              if (value != null) {
                throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
              }
              if (isArray(children)) {
                if (children.length > 1) {
                  throw new Error("<textarea> can only have at most one child.");
                }
                {
                  checkHtmlStringCoercion(children[0]);
                }
                value = "" + children[0];
              }
              {
                checkHtmlStringCoercion(children);
              }
              value = "" + children;
            }
            if (typeof value === "string" && value[0] === "\n") {
              target.push(leadingNewline);
            }
            if (value !== null) {
              {
                checkAttributeStringCoercion(value, "value");
              }
              target.push(stringToChunk(encodeHTMLTextNode("" + value)));
            }
            return null;
          }
          function pushSelfClosing(target, props, tag, responseState) {
            target.push(startChunkForTag(tag));
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target.push(endOfStartTagSelfClosing);
            return null;
          }
          function pushStartMenuItem(target, props, responseState) {
            target.push(startChunkForTag("menuitem"));
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target.push(endOfStartTag);
            return null;
          }
          function pushStartTitle(target, props, responseState) {
            target.push(startChunkForTag("title"));
            var children = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target.push(endOfStartTag);
            {
              var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
              if (Array.isArray(children) && children.length > 1) {
                error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
              } else if (child != null && child.$$typeof != null) {
                error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
              } else if (child != null && typeof child !== "string" && typeof child !== "number") {
                error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
              }
            }
            return children;
          }
          function pushStartGenericElement(target, props, tag, responseState) {
            target.push(startChunkForTag(tag));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target.push(endOfStartTag);
            pushInnerHTML(target, innerHTML, children);
            if (typeof children === "string") {
              target.push(stringToChunk(encodeHTMLTextNode(children)));
              return null;
            }
            return children;
          }
          function pushStartCustomElement(target, props, tag, responseState) {
            target.push(startChunkForTag(tag));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "style":
                    pushStyle(target, responseState, propValue);
                    break;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                    break;
                  default:
                    if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                      target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                    }
                    break;
                }
              }
            }
            target.push(endOfStartTag);
            pushInnerHTML(target, innerHTML, children);
            return children;
          }
          var leadingNewline = stringToPrecomputedChunk("\n");
          function pushStartPreformattedElement(target, props, tag, responseState) {
            target.push(startChunkForTag(tag));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target.push(endOfStartTag);
            if (innerHTML != null) {
              if (children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
              var html = innerHTML.__html;
              if (html !== null && html !== void 0) {
                if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                  target.push(leadingNewline, stringToChunk(html));
                } else {
                  {
                    checkHtmlStringCoercion(html);
                  }
                  target.push(stringToChunk("" + html));
                }
              }
            }
            if (typeof children === "string" && children[0] === "\n") {
              target.push(leadingNewline);
            }
            return children;
          }
          var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
          var validatedTagCache = /* @__PURE__ */ new Map();
          function startChunkForTag(tag) {
            var tagStartChunk = validatedTagCache.get(tag);
            if (tagStartChunk === void 0) {
              if (!VALID_TAG_REGEX.test(tag)) {
                throw new Error("Invalid tag: " + tag);
              }
              tagStartChunk = stringToPrecomputedChunk("<" + tag);
              validatedTagCache.set(tag, tagStartChunk);
            }
            return tagStartChunk;
          }
          var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
          function pushStartInstance(target, type, props, responseState, formatContext) {
            {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, null);
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
              if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
                if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
            }
            switch (type) {
              case "select":
                return pushStartSelect(target, props, responseState);
              case "option":
                return pushStartOption(target, props, responseState, formatContext);
              case "textarea":
                return pushStartTextArea(target, props, responseState);
              case "input":
                return pushInput(target, props, responseState);
              case "menuitem":
                return pushStartMenuItem(target, props, responseState);
              case "title":
                return pushStartTitle(target, props, responseState);
              case "listing":
              case "pre": {
                return pushStartPreformattedElement(target, props, type, responseState);
              }
              case "area":
              case "base":
              case "br":
              case "col":
              case "embed":
              case "hr":
              case "img":
              case "keygen":
              case "link":
              case "meta":
              case "param":
              case "source":
              case "track":
              case "wbr": {
                return pushSelfClosing(target, props, type, responseState);
              }
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph": {
                return pushStartGenericElement(target, props, type, responseState);
              }
              case "html": {
                if (formatContext.insertionMode === ROOT_HTML_MODE) {
                  target.push(DOCTYPE);
                }
                return pushStartGenericElement(target, props, type, responseState);
              }
              default: {
                if (type.indexOf("-") === -1 && typeof props.is !== "string") {
                  return pushStartGenericElement(target, props, type, responseState);
                } else {
                  return pushStartCustomElement(target, props, type, responseState);
                }
              }
            }
          }
          var endTag1 = stringToPrecomputedChunk("</");
          var endTag2 = stringToPrecomputedChunk(">");
          function pushEndInstance(target, type, props) {
            switch (type) {
              case "area":
              case "base":
              case "br":
              case "col":
              case "embed":
              case "hr":
              case "img":
              case "input":
              case "keygen":
              case "link":
              case "meta":
              case "param":
              case "source":
              case "track":
              case "wbr": {
                break;
              }
              default: {
                target.push(endTag1, stringToChunk(type), endTag2);
              }
            }
          }
          function writeCompletedRoot(destination, responseState) {
            var bootstrapChunks = responseState.bootstrapChunks;
            var i = 0;
            for (; i < bootstrapChunks.length - 1; i++) {
              writeChunk(destination, bootstrapChunks[i]);
            }
            if (i < bootstrapChunks.length) {
              return writeChunkAndReturn(destination, bootstrapChunks[i]);
            }
            return true;
          }
          var placeholder1 = stringToPrecomputedChunk('<template id="');
          var placeholder2 = stringToPrecomputedChunk('"></template>');
          function writePlaceholder(destination, responseState, id) {
            writeChunk(destination, placeholder1);
            writeChunk(destination, responseState.placeholderPrefix);
            var formattedID = stringToChunk(id.toString(16));
            writeChunk(destination, formattedID);
            return writeChunkAndReturn(destination, placeholder2);
          }
          var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
          var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
          var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
          var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
          var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
          var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
          var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
          var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
          var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
          var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
          var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
          function writeStartCompletedSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
          }
          function writeStartPendingSuspenseBoundary(destination, responseState, id) {
            writeChunk(destination, startPendingSuspenseBoundary1);
            if (id === null) {
              throw new Error("An ID must have been assigned before we can complete the boundary.");
            }
            writeChunk(destination, id);
            return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
          }
          function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
            var result;
            result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
            writeChunk(destination, clientRenderedSuspenseBoundaryError1);
            if (errorDigest) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            {
              if (errorMesssage) {
                writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
              }
              if (errorComponentStack) {
                writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
              }
            }
            result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
            return result;
          }
          function writeEndCompletedSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, endSuspenseBoundary);
          }
          function writeEndPendingSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, endSuspenseBoundary);
          }
          function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, endSuspenseBoundary);
          }
          var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
          var startSegmentHTML2 = stringToPrecomputedChunk('">');
          var endSegmentHTML = stringToPrecomputedChunk("</div>");
          var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
          var startSegmentSVG2 = stringToPrecomputedChunk('">');
          var endSegmentSVG = stringToPrecomputedChunk("</svg>");
          var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
          var startSegmentMathML2 = stringToPrecomputedChunk('">');
          var endSegmentMathML = stringToPrecomputedChunk("</math>");
          var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
          var startSegmentTable2 = stringToPrecomputedChunk('">');
          var endSegmentTable = stringToPrecomputedChunk("</table>");
          var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
          var startSegmentTableBody2 = stringToPrecomputedChunk('">');
          var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
          var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
          var startSegmentTableRow2 = stringToPrecomputedChunk('">');
          var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
          var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
          var startSegmentColGroup2 = stringToPrecomputedChunk('">');
          var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
          function writeStartSegment(destination, responseState, formatContext, id) {
            switch (formatContext.insertionMode) {
              case ROOT_HTML_MODE:
              case HTML_MODE: {
                writeChunk(destination, startSegmentHTML);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentHTML2);
              }
              case SVG_MODE: {
                writeChunk(destination, startSegmentSVG);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentSVG2);
              }
              case MATHML_MODE: {
                writeChunk(destination, startSegmentMathML);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentMathML2);
              }
              case HTML_TABLE_MODE: {
                writeChunk(destination, startSegmentTable);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTable2);
              }
              case HTML_TABLE_BODY_MODE: {
                writeChunk(destination, startSegmentTableBody);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTableBody2);
              }
              case HTML_TABLE_ROW_MODE: {
                writeChunk(destination, startSegmentTableRow);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTableRow2);
              }
              case HTML_COLGROUP_MODE: {
                writeChunk(destination, startSegmentColGroup);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentColGroup2);
              }
              default: {
                throw new Error("Unknown insertion mode. This is a bug in React.");
              }
            }
          }
          function writeEndSegment(destination, formatContext) {
            switch (formatContext.insertionMode) {
              case ROOT_HTML_MODE:
              case HTML_MODE: {
                return writeChunkAndReturn(destination, endSegmentHTML);
              }
              case SVG_MODE: {
                return writeChunkAndReturn(destination, endSegmentSVG);
              }
              case MATHML_MODE: {
                return writeChunkAndReturn(destination, endSegmentMathML);
              }
              case HTML_TABLE_MODE: {
                return writeChunkAndReturn(destination, endSegmentTable);
              }
              case HTML_TABLE_BODY_MODE: {
                return writeChunkAndReturn(destination, endSegmentTableBody);
              }
              case HTML_TABLE_ROW_MODE: {
                return writeChunkAndReturn(destination, endSegmentTableRow);
              }
              case HTML_COLGROUP_MODE: {
                return writeChunkAndReturn(destination, endSegmentColGroup);
              }
              default: {
                throw new Error("Unknown insertion mode. This is a bug in React.");
              }
            }
          }
          var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
          var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
          var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
          var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
          var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
          var completeSegmentScript2 = stringToPrecomputedChunk('","');
          var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
          function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
            writeChunk(destination, responseState.startInlineScript);
            if (!responseState.sentCompleteSegmentFunction) {
              responseState.sentCompleteSegmentFunction = true;
              writeChunk(destination, completeSegmentScript1Full);
            } else {
              writeChunk(destination, completeSegmentScript1Partial);
            }
            writeChunk(destination, responseState.segmentPrefix);
            var formattedID = stringToChunk(contentSegmentID.toString(16));
            writeChunk(destination, formattedID);
            writeChunk(destination, completeSegmentScript2);
            writeChunk(destination, responseState.placeholderPrefix);
            writeChunk(destination, formattedID);
            return writeChunkAndReturn(destination, completeSegmentScript3);
          }
          var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
          var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
          var completeBoundaryScript2 = stringToPrecomputedChunk('","');
          var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
          function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
            writeChunk(destination, responseState.startInlineScript);
            if (!responseState.sentCompleteBoundaryFunction) {
              responseState.sentCompleteBoundaryFunction = true;
              writeChunk(destination, completeBoundaryScript1Full);
            } else {
              writeChunk(destination, completeBoundaryScript1Partial);
            }
            if (boundaryID === null) {
              throw new Error("An ID must have been assigned before we can complete the boundary.");
            }
            var formattedContentID = stringToChunk(contentSegmentID.toString(16));
            writeChunk(destination, boundaryID);
            writeChunk(destination, completeBoundaryScript2);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, formattedContentID);
            return writeChunkAndReturn(destination, completeBoundaryScript3);
          }
          var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
          var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
          var clientRenderScript1A = stringToPrecomputedChunk('"');
          var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
          var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
          function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
            writeChunk(destination, responseState.startInlineScript);
            if (!responseState.sentClientRenderFunction) {
              responseState.sentClientRenderFunction = true;
              writeChunk(destination, clientRenderScript1Full);
            } else {
              writeChunk(destination, clientRenderScript1Partial);
            }
            if (boundaryID === null) {
              throw new Error("An ID must have been assigned before we can complete the boundary.");
            }
            writeChunk(destination, boundaryID);
            writeChunk(destination, clientRenderScript1A);
            if (errorDigest || errorMessage || errorComponentStack) {
              writeChunk(destination, clientRenderErrorScriptArgInterstitial);
              writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
            }
            if (errorMessage || errorComponentStack) {
              writeChunk(destination, clientRenderErrorScriptArgInterstitial);
              writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderErrorScriptArgInterstitial);
              writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
            }
            return writeChunkAndReturn(destination, clientRenderScript2);
          }
          var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
          function escapeJSStringsForInstructionScripts(input) {
            var escaped = JSON.stringify(input);
            return escaped.replace(regexForJSStringsInScripts, function(match) {
              switch (match) {
                case "<":
                  return "\\u003c";
                case "\u2028":
                  return "\\u2028";
                case "\u2029":
                  return "\\u2029";
                default: {
                  throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
                }
              }
            });
          }
          function createResponseState$1(generateStaticMarkup, identifierPrefix) {
            var responseState = createResponseState(identifierPrefix, void 0);
            return {
              bootstrapChunks: responseState.bootstrapChunks,
              startInlineScript: responseState.startInlineScript,
              placeholderPrefix: responseState.placeholderPrefix,
              segmentPrefix: responseState.segmentPrefix,
              boundaryPrefix: responseState.boundaryPrefix,
              idPrefix: responseState.idPrefix,
              nextSuspenseID: responseState.nextSuspenseID,
              sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
              sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
              sentClientRenderFunction: responseState.sentClientRenderFunction,
              generateStaticMarkup
            };
          }
          function createRootFormatContext() {
            return {
              insertionMode: HTML_MODE,
              selectedValue: null
            };
          }
          function pushTextInstance$1(target, text, responseState, textEmbedded) {
            if (responseState.generateStaticMarkup) {
              target.push(stringToChunk(escapeTextForBrowser(text)));
              return false;
            } else {
              return pushTextInstance(target, text, responseState, textEmbedded);
            }
          }
          function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {
            if (responseState.generateStaticMarkup) {
              return;
            } else {
              return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);
            }
          }
          function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
            if (responseState.generateStaticMarkup) {
              return true;
            }
            return writeStartCompletedSuspenseBoundary(destination);
          }
          function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
            if (responseState.generateStaticMarkup) {
              return true;
            }
            return writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
          }
          function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
            if (responseState.generateStaticMarkup) {
              return true;
            }
            return writeEndCompletedSuspenseBoundary(destination);
          }
          function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
            if (responseState.generateStaticMarkup) {
              return true;
            }
            return writeEndClientRenderedSuspenseBoundary(destination);
          }
          var assign = Object.assign;
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_SCOPE_TYPE = Symbol.for("react.scope");
          var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
          var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
          var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has4 = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has4(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          function getMaskedContext(type, unmaskedContext) {
            {
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var context = {};
              for (var key in contextTypes) {
                context[key] = unmaskedContext[key];
              }
              {
                var name = getComponentNameFromType(type) || "Unknown";
                checkPropTypes(contextTypes, context, "context", name);
              }
              return context;
            }
          }
          function processChildContext(instance, type, parentContext, childContextTypes) {
            {
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentNameFromType(type) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                }
              }
              {
                var name = getComponentNameFromType(type) || "Unknown";
                checkPropTypes(childContextTypes, childContext, "child context", name);
              }
              return assign({}, parentContext, childContext);
            }
          }
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var rootContextSnapshot = null;
          var currentActiveSnapshot = null;
          function popNode(prev) {
            {
              prev.context._currentValue2 = prev.parentValue;
            }
          }
          function pushNode(next) {
            {
              next.context._currentValue2 = next.value;
            }
          }
          function popToNearestCommonAncestor(prev, next) {
            if (prev === next)
              ;
            else {
              popNode(prev);
              var parentPrev = prev.parent;
              var parentNext = next.parent;
              if (parentPrev === null) {
                if (parentNext !== null) {
                  throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
                }
              } else {
                if (parentNext === null) {
                  throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
                }
                popToNearestCommonAncestor(parentPrev, parentNext);
              }
              pushNode(next);
            }
          }
          function popAllPrevious(prev) {
            popNode(prev);
            var parentPrev = prev.parent;
            if (parentPrev !== null) {
              popAllPrevious(parentPrev);
            }
          }
          function pushAllNext(next) {
            var parentNext = next.parent;
            if (parentNext !== null) {
              pushAllNext(parentNext);
            }
            pushNode(next);
          }
          function popPreviousToCommonLevel(prev, next) {
            popNode(prev);
            var parentPrev = prev.parent;
            if (parentPrev === null) {
              throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
            }
            if (parentPrev.depth === next.depth) {
              popToNearestCommonAncestor(parentPrev, next);
            } else {
              popPreviousToCommonLevel(parentPrev, next);
            }
          }
          function popNextToCommonLevel(prev, next) {
            var parentNext = next.parent;
            if (parentNext === null) {
              throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
            }
            if (prev.depth === parentNext.depth) {
              popToNearestCommonAncestor(prev, parentNext);
            } else {
              popNextToCommonLevel(prev, parentNext);
            }
            pushNode(next);
          }
          function switchContext(newSnapshot) {
            var prev = currentActiveSnapshot;
            var next = newSnapshot;
            if (prev !== next) {
              if (prev === null) {
                pushAllNext(next);
              } else if (next === null) {
                popAllPrevious(prev);
              } else if (prev.depth === next.depth) {
                popToNearestCommonAncestor(prev, next);
              } else if (prev.depth > next.depth) {
                popPreviousToCommonLevel(prev, next);
              } else {
                popNextToCommonLevel(prev, next);
              }
              currentActiveSnapshot = next;
            }
          }
          function pushProvider(context, nextValue) {
            var prevValue;
            {
              prevValue = context._currentValue2;
              context._currentValue2 = nextValue;
              {
                if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
                  error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer2 = rendererSigil;
              }
            }
            var prevNode = currentActiveSnapshot;
            var newNode = {
              parent: prevNode,
              depth: prevNode === null ? 0 : prevNode.depth + 1,
              context,
              parentValue: prevValue,
              value: nextValue
            };
            currentActiveSnapshot = newNode;
            return newNode;
          }
          function popProvider(context) {
            var prevSnapshot = currentActiveSnapshot;
            if (prevSnapshot === null) {
              throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
            }
            {
              if (prevSnapshot.context !== context) {
                error("The parent context is not the expected context. This is probably a bug in React.");
              }
            }
            {
              var _value = prevSnapshot.parentValue;
              if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;
              } else {
                prevSnapshot.context._currentValue2 = _value;
              }
              {
                if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
                  error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer2 = rendererSigil;
              }
            }
            return currentActiveSnapshot = prevSnapshot.parent;
          }
          function getActiveContext() {
            return currentActiveSnapshot;
          }
          function readContext(context) {
            var value = context._currentValue2;
            return value;
          }
          function get(key) {
            return key._reactInternals;
          }
          function set2(key, value) {
            key._reactInternals = value;
          }
          var didWarnAboutNoopUpdateForComponent = {};
          var didWarnAboutDeprecatedWillMount = {};
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentNameFromType(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
          }
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnAboutNoopUpdateForComponent[warningKey]) {
                return;
              }
              error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
              didWarnAboutNoopUpdateForComponent[warningKey] = true;
            }
          }
          var classComponentUpdater = {
            isMounted: function(inst) {
              return false;
            },
            enqueueSetState: function(inst, payload, callback) {
              var internals = get(inst);
              if (internals.queue === null) {
                warnNoop(inst, "setState");
              } else {
                internals.queue.push(payload);
                {
                  if (callback !== void 0 && callback !== null) {
                    warnOnInvalidCallback(callback, "setState");
                  }
                }
              }
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var internals = get(inst);
              internals.replace = true;
              internals.queue = [payload];
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            },
            enqueueForceUpdate: function(inst, callback) {
              var internals = get(inst);
              if (internals.queue === null) {
                warnNoop(inst, "forceUpdate");
              } else {
                {
                  if (callback !== void 0 && callback !== null) {
                    warnOnInvalidCallback(callback, "setState");
                  }
                }
              }
            }
          };
          function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var newState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
            return newState;
          }
          function constructClassInstance(ctor, props, maskedLegacyContext) {
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context = readContext(contextType);
            } else {
              context = maskedLegacyContext;
            }
            var instance = new ctor(props, context);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentNameFromType(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            return instance;
          }
          function checkClassInstance(instance, ctor, newProps) {
            {
              var name = getComponentNameFromType(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
                } else {
                  error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
              }
              if (instance.propTypes) {
                error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
              }
              if (instance.contextType) {
                error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
              }
              {
                if (instance.contextTypes) {
                  error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
              }
              if (instance.defaultProps) {
                error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray(_state))) {
                error("%s.state: must be set to an object or null", name);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
              }
            }
          }
          function callComponentWillMount(type, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              {
                if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  var componentName = getComponentNameFromType(type) || "Unknown";
                  if (!didWarnAboutDeprecatedWillMount[componentName]) {
                    warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", componentName);
                    didWarnAboutDeprecatedWillMount[componentName] = true;
                  }
                }
              }
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
            if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
              var oldQueue = internalInstance.queue;
              var oldReplace = internalInstance.replace;
              internalInstance.queue = null;
              internalInstance.replace = false;
              if (oldReplace && oldQueue.length === 1) {
                inst.state = oldQueue[0];
              } else {
                var nextState = oldReplace ? oldQueue[0] : inst.state;
                var dontMutate = true;
                for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                  var partial = oldQueue[i];
                  var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                  if (partialState != null) {
                    if (dontMutate) {
                      dontMutate = false;
                      nextState = assign({}, nextState, partialState);
                    } else {
                      assign(nextState, partialState);
                    }
                  }
                }
                inst.state = nextState;
              }
            } else {
              internalInstance.queue = null;
            }
          }
          function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
            {
              checkClassInstance(instance, ctor, newProps);
            }
            var initialState = instance.state !== void 0 ? instance.state : null;
            instance.updater = classComponentUpdater;
            instance.props = newProps;
            instance.state = initialState;
            var internalInstance = {
              queue: [],
              replace: false
            };
            set2(instance, internalInstance);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              instance.context = maskedLegacyContext;
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(ctor, instance);
              processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
            }
          }
          var emptyTreeContext = {
            id: 1,
            overflow: ""
          };
          function getTreeId(context) {
            var overflow = context.overflow;
            var idWithLeadingBit = context.id;
            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id.toString(32) + overflow;
          }
          function pushTreeContext(baseContext, totalChildren, index) {
            var baseIdWithLeadingBit = baseContext.id;
            var baseOverflow = baseContext.overflow;
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index + 1;
            var length = getBitLength(totalChildren) + baseLength;
            if (length > 30) {
              var numberOfOverflowBits = baseLength - baseLength % 5;
              var newOverflowBits = (1 << numberOfOverflowBits) - 1;
              var newOverflow = (baseId & newOverflowBits).toString(32);
              var restOfBaseId = baseId >> numberOfOverflowBits;
              var restOfBaseLength = baseLength - numberOfOverflowBits;
              var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
              var restOfNewBits = slot << restOfBaseLength;
              var id = restOfNewBits | restOfBaseId;
              var overflow = newOverflow + baseOverflow;
              return {
                id: 1 << restOfLength | id,
                overflow
              };
            } else {
              var newBits = slot << baseLength;
              var _id = newBits | baseId;
              var _overflow = baseOverflow;
              return {
                id: 1 << length | _id,
                overflow: _overflow
              };
            }
          }
          function getBitLength(number2) {
            return 32 - clz32(number2);
          }
          function getLeadingBit(id) {
            return 1 << getBitLength(id) - 1;
          }
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(x) {
            var asUint = x >>> 0;
            if (asUint === 0) {
              return 32;
            }
            return 31 - (log(asUint) / LN2 | 0) | 0;
          }
          function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          var currentlyRenderingComponent = null;
          var currentlyRenderingTask = null;
          var firstWorkInProgressHook = null;
          var workInProgressHook = null;
          var isReRender = false;
          var didScheduleRenderPhaseUpdate = false;
          var localIdCounter = 0;
          var renderPhaseUpdates = null;
          var numberOfReRenders = 0;
          var RE_RENDER_LIMIT = 25;
          var isInHookUserCodeInDev = false;
          var currentHookNameInDev;
          function resolveCurrentlyRenderingComponent() {
            if (currentlyRenderingComponent === null) {
              throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
            {
              if (isInHookUserCodeInDev) {
                error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
              }
            }
            return currentlyRenderingComponent;
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            if (prevDeps === null) {
              {
                error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
              }
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
              if (objectIs(nextDeps[i], prevDeps[i])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function createHook() {
            if (numberOfReRenders > 0) {
              throw new Error("Rendered more hooks than during the previous render");
            }
            return {
              memoizedState: null,
              queue: null,
              next: null
            };
          }
          function createWorkInProgressHook() {
            if (workInProgressHook === null) {
              if (firstWorkInProgressHook === null) {
                isReRender = false;
                firstWorkInProgressHook = workInProgressHook = createHook();
              } else {
                isReRender = true;
                workInProgressHook = firstWorkInProgressHook;
              }
            } else {
              if (workInProgressHook.next === null) {
                isReRender = false;
                workInProgressHook = workInProgressHook.next = createHook();
              } else {
                isReRender = true;
                workInProgressHook = workInProgressHook.next;
              }
            }
            return workInProgressHook;
          }
          function prepareToUseHooks(task, componentIdentity) {
            currentlyRenderingComponent = componentIdentity;
            currentlyRenderingTask = task;
            {
              isInHookUserCodeInDev = false;
            }
            localIdCounter = 0;
          }
          function finishHooks(Component, props, children, refOrContext) {
            while (didScheduleRenderPhaseUpdate) {
              didScheduleRenderPhaseUpdate = false;
              localIdCounter = 0;
              numberOfReRenders += 1;
              workInProgressHook = null;
              children = Component(props, refOrContext);
            }
            resetHooksState();
            return children;
          }
          function checkDidRenderIdHook() {
            var didRenderIdHook = localIdCounter !== 0;
            return didRenderIdHook;
          }
          function resetHooksState() {
            {
              isInHookUserCodeInDev = false;
            }
            currentlyRenderingComponent = null;
            currentlyRenderingTask = null;
            didScheduleRenderPhaseUpdate = false;
            firstWorkInProgressHook = null;
            numberOfReRenders = 0;
            renderPhaseUpdates = null;
            workInProgressHook = null;
          }
          function readContext$1(context) {
            {
              if (isInHookUserCodeInDev) {
                error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            return readContext(context);
          }
          function useContext(context) {
            {
              currentHookNameInDev = "useContext";
            }
            resolveCurrentlyRenderingComponent();
            return readContext(context);
          }
          function basicStateReducer(state, action2) {
            return typeof action2 === "function" ? action2(state) : action2;
          }
          function useState3(initialState) {
            {
              currentHookNameInDev = "useState";
            }
            return useReducer(basicStateReducer, initialState);
          }
          function useReducer(reducer, initialArg, init) {
            {
              if (reducer !== basicStateReducer) {
                currentHookNameInDev = "useReducer";
              }
            }
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            if (isReRender) {
              var queue = workInProgressHook.queue;
              var dispatch = queue.dispatch;
              if (renderPhaseUpdates !== null) {
                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
                if (firstRenderPhaseUpdate !== void 0) {
                  renderPhaseUpdates.delete(queue);
                  var newState = workInProgressHook.memoizedState;
                  var update = firstRenderPhaseUpdate;
                  do {
                    var action2 = update.action;
                    {
                      isInHookUserCodeInDev = true;
                    }
                    newState = reducer(newState, action2);
                    {
                      isInHookUserCodeInDev = false;
                    }
                    update = update.next;
                  } while (update !== null);
                  workInProgressHook.memoizedState = newState;
                  return [newState, dispatch];
                }
              }
              return [workInProgressHook.memoizedState, dispatch];
            } else {
              {
                isInHookUserCodeInDev = true;
              }
              var initialState;
              if (reducer === basicStateReducer) {
                initialState = typeof initialArg === "function" ? initialArg() : initialArg;
              } else {
                initialState = init !== void 0 ? init(initialArg) : initialArg;
              }
              {
                isInHookUserCodeInDev = false;
              }
              workInProgressHook.memoizedState = initialState;
              var _queue = workInProgressHook.queue = {
                last: null,
                dispatch: null
              };
              var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
              return [workInProgressHook.memoizedState, _dispatch];
            }
          }
          function useMemo(nextCreate, deps) {
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            if (workInProgressHook !== null) {
              var prevState = workInProgressHook.memoizedState;
              if (prevState !== null) {
                if (nextDeps !== null) {
                  var prevDeps = prevState[1];
                  if (areHookInputsEqual(nextDeps, prevDeps)) {
                    return prevState[0];
                  }
                }
              }
            }
            {
              isInHookUserCodeInDev = true;
            }
            var nextValue = nextCreate();
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function useRef2(initialValue) {
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            var previousRef = workInProgressHook.memoizedState;
            if (previousRef === null) {
              var ref = {
                current: initialValue
              };
              {
                Object.seal(ref);
              }
              workInProgressHook.memoizedState = ref;
              return ref;
            } else {
              return previousRef;
            }
          }
          function useLayoutEffect(create10, inputs) {
            {
              currentHookNameInDev = "useLayoutEffect";
              error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
            }
          }
          function dispatchAction(componentIdentity, queue, action2) {
            if (numberOfReRenders >= RE_RENDER_LIMIT) {
              throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
            if (componentIdentity === currentlyRenderingComponent) {
              didScheduleRenderPhaseUpdate = true;
              var update = {
                action: action2,
                next: null
              };
              if (renderPhaseUpdates === null) {
                renderPhaseUpdates = /* @__PURE__ */ new Map();
              }
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
              if (firstRenderPhaseUpdate === void 0) {
                renderPhaseUpdates.set(queue, update);
              } else {
                var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
                while (lastRenderPhaseUpdate.next !== null) {
                  lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
                }
                lastRenderPhaseUpdate.next = update;
              }
            }
          }
          function useCallback(callback, deps) {
            return useMemo(function() {
              return callback;
            }, deps);
          }
          function useMutableSource(source, getSnapshot, subscribe) {
            resolveCurrentlyRenderingComponent();
            return getSnapshot(source._source);
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            if (getServerSnapshot === void 0) {
              throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
            }
            return getServerSnapshot();
          }
          function useDeferredValue(value) {
            resolveCurrentlyRenderingComponent();
            return value;
          }
          function unsupportedStartTransition() {
            throw new Error("startTransition cannot be called during server rendering.");
          }
          function useTransition2() {
            resolveCurrentlyRenderingComponent();
            return [false, unsupportedStartTransition];
          }
          function useId() {
            var task = currentlyRenderingTask;
            var treeId = getTreeId(task.treeContext);
            var responseState = currentResponseState;
            if (responseState === null) {
              throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
            }
            var localId = localIdCounter++;
            return makeId(responseState, treeId, localId);
          }
          function noop() {
          }
          var Dispatcher = {
            readContext: readContext$1,
            useContext,
            useMemo,
            useReducer,
            useRef: useRef2,
            useState: useState3,
            useInsertionEffect: noop,
            useLayoutEffect,
            useCallback,
            useImperativeHandle: noop,
            useEffect: noop,
            useDebugValue: noop,
            useDeferredValue,
            useTransition: useTransition2,
            useId,
            useMutableSource,
            useSyncExternalStore
          };
          var currentResponseState = null;
          function setCurrentResponseState(responseState) {
            currentResponseState = responseState;
          }
          function getStackByComponentStackNode(componentStack) {
            try {
              var info = "";
              var node = componentStack;
              do {
                switch (node.tag) {
                  case 0:
                    info += describeBuiltInComponentFrame(node.type, null, null);
                    break;
                  case 1:
                    info += describeFunctionComponentFrame(node.type, null, null);
                    break;
                  case 2:
                    info += describeClassComponentFrame(node.type, null, null);
                    break;
                }
                node = node.parent;
              } while (node);
              return info;
            } catch (x) {
              return "\nError generating stack: " + x.message + "\n" + x.stack;
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          var PENDING = 0;
          var COMPLETED = 1;
          var FLUSHED = 2;
          var ABORTED = 3;
          var ERRORED = 4;
          var OPEN = 0;
          var CLOSING = 1;
          var CLOSED = 2;
          var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
          function defaultErrorHandler(error2) {
            console["error"](error2);
            return null;
          }
          function noop$1() {
          }
          function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError) {
            var pingedTasks = [];
            var abortSet = /* @__PURE__ */ new Set();
            var request = {
              destination: null,
              responseState,
              progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
              status: OPEN,
              fatalError: null,
              nextSegmentId: 0,
              allPendingTasks: 0,
              pendingRootTasks: 0,
              completedRootSegment: null,
              abortableTasks: abortSet,
              pingedTasks,
              clientRenderedBoundaries: [],
              completedBoundaries: [],
              partialBoundaries: [],
              onError: onError2 === void 0 ? defaultErrorHandler : onError2,
              onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
              onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
              onShellError: onShellError === void 0 ? noop$1 : onShellError,
              onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
            };
            var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false);
            rootSegment.parentFlushed = true;
            var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
            pingedTasks.push(rootTask);
            return request;
          }
          function pingTask(request, task) {
            var pingedTasks = request.pingedTasks;
            pingedTasks.push(task);
            if (pingedTasks.length === 1) {
              scheduleWork(function() {
                return performWork(request);
              });
            }
          }
          function createSuspenseBoundary(request, fallbackAbortableTasks) {
            return {
              id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
              rootSegmentID: -1,
              parentFlushed: false,
              pendingTasks: 0,
              forceClientRender: false,
              completedSegments: [],
              byteSize: 0,
              fallbackAbortableTasks,
              errorDigest: null
            };
          }
          function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
            request.allPendingTasks++;
            if (blockedBoundary === null) {
              request.pendingRootTasks++;
            } else {
              blockedBoundary.pendingTasks++;
            }
            var task = {
              node,
              ping: function() {
                return pingTask(request, task);
              },
              blockedBoundary,
              blockedSegment,
              abortSet,
              legacyContext,
              context,
              treeContext
            };
            {
              task.componentStack = null;
            }
            abortSet.add(task);
            return task;
          }
          function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
            return {
              status: PENDING,
              id: -1,
              index,
              parentFlushed: false,
              chunks: [],
              children: [],
              formatContext,
              boundary,
              lastPushedText,
              textEmbedded
            };
          }
          var currentTaskInDEV = null;
          function getCurrentStackInDEV() {
            {
              if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
                return "";
              }
              return getStackByComponentStackNode(currentTaskInDEV.componentStack);
            }
          }
          function pushBuiltInComponentStackInDEV(task, type) {
            {
              task.componentStack = {
                tag: 0,
                parent: task.componentStack,
                type
              };
            }
          }
          function pushFunctionComponentStackInDEV(task, type) {
            {
              task.componentStack = {
                tag: 1,
                parent: task.componentStack,
                type
              };
            }
          }
          function pushClassComponentStackInDEV(task, type) {
            {
              task.componentStack = {
                tag: 2,
                parent: task.componentStack,
                type
              };
            }
          }
          function popComponentStackInDEV(task) {
            {
              if (task.componentStack === null) {
                error("Unexpectedly popped too many stack frames. This is a bug in React.");
              } else {
                task.componentStack = task.componentStack.parent;
              }
            }
          }
          var lastBoundaryErrorComponentStackDev = null;
          function captureBoundaryErrorDetailsDev(boundary, error2) {
            {
              var errorMessage;
              if (typeof error2 === "string") {
                errorMessage = error2;
              } else if (error2 && typeof error2.message === "string") {
                errorMessage = error2.message;
              } else {
                errorMessage = String(error2);
              }
              var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
              lastBoundaryErrorComponentStackDev = null;
              boundary.errorMessage = errorMessage;
              boundary.errorComponentStack = errorComponentStack;
            }
          }
          function logRecoverableError(request, error2) {
            var errorDigest = request.onError(error2);
            if (errorDigest != null && typeof errorDigest !== "string") {
              throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
            }
            return errorDigest;
          }
          function fatalError(request, error2) {
            var onShellError = request.onShellError;
            onShellError(error2);
            var onFatalError = request.onFatalError;
            onFatalError(error2);
            if (request.destination !== null) {
              request.status = CLOSED;
              closeWithError(request.destination, error2);
            } else {
              request.status = CLOSING;
              request.fatalError = error2;
            }
          }
          function renderSuspenseBoundary(request, task, props) {
            pushBuiltInComponentStackInDEV(task, "Suspense");
            var parentBoundary = task.blockedBoundary;
            var parentSegment = task.blockedSegment;
            var fallback = props.fallback;
            var content = props.children;
            var fallbackAbortSet = /* @__PURE__ */ new Set();
            var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
            var insertionIndex = parentSegment.chunks.length;
            var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);
            parentSegment.children.push(boundarySegment);
            parentSegment.lastPushedText = false;
            var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false);
            contentRootSegment.parentFlushed = true;
            task.blockedBoundary = newBoundary;
            task.blockedSegment = contentRootSegment;
            try {
              renderNode(request, task, content);
              pushSegmentFinale$1(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
              contentRootSegment.status = COMPLETED;
              queueCompletedSegment(newBoundary, contentRootSegment);
              if (newBoundary.pendingTasks === 0) {
                popComponentStackInDEV(task);
                return;
              }
            } catch (error2) {
              contentRootSegment.status = ERRORED;
              newBoundary.forceClientRender = true;
              newBoundary.errorDigest = logRecoverableError(request, error2);
              {
                captureBoundaryErrorDetailsDev(newBoundary, error2);
              }
            } finally {
              task.blockedBoundary = parentBoundary;
              task.blockedSegment = parentSegment;
            }
            var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
            {
              suspendedFallbackTask.componentStack = task.componentStack;
            }
            request.pingedTasks.push(suspendedFallbackTask);
            popComponentStackInDEV(task);
          }
          function renderHostElement(request, task, type, props) {
            pushBuiltInComponentStackInDEV(task, type);
            var segment = task.blockedSegment;
            var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
            segment.lastPushedText = false;
            var prevContext = segment.formatContext;
            segment.formatContext = getChildFormatContext(prevContext, type, props);
            renderNode(request, task, children);
            segment.formatContext = prevContext;
            pushEndInstance(segment.chunks, type);
            segment.lastPushedText = false;
            popComponentStackInDEV(task);
          }
          function shouldConstruct$1(Component) {
            return Component.prototype && Component.prototype.isReactComponent;
          }
          function renderWithHooks(request, task, Component, props, secondArg) {
            var componentIdentity = {};
            prepareToUseHooks(task, componentIdentity);
            var result = Component(props, secondArg);
            return finishHooks(Component, props, result, secondArg);
          }
          function finishClassComponent(request, task, instance, Component, props) {
            var nextChildren = instance.render();
            {
              if (instance.props !== props) {
                if (!didWarnAboutReassigningProps) {
                  error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            {
              var childContextTypes = Component.childContextTypes;
              if (childContextTypes !== null && childContextTypes !== void 0) {
                var previousContext = task.legacyContext;
                var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
                task.legacyContext = mergedContext;
                renderNodeDestructive(request, task, nextChildren);
                task.legacyContext = previousContext;
                return;
              }
            }
            renderNodeDestructive(request, task, nextChildren);
          }
          function renderClassComponent(request, task, Component, props) {
            pushClassComponentStackInDEV(task, Component);
            var maskedContext = getMaskedContext(Component, task.legacyContext);
            var instance = constructClassInstance(Component, props, maskedContext);
            mountClassInstance(instance, Component, props, maskedContext);
            finishClassComponent(request, task, instance, Component, props);
            popComponentStackInDEV(task);
          }
          var didWarnAboutBadClass = {};
          var didWarnAboutModulePatternComponent = {};
          var didWarnAboutContextTypeOnFunctionComponent = {};
          var didWarnAboutGetDerivedStateOnFunctionComponent = {};
          var didWarnAboutReassigningProps = false;
          var didWarnAboutGenerators = false;
          var didWarnAboutMaps = false;
          var hasWarnedAboutUsingContextAsConsumer = false;
          function renderIndeterminateComponent(request, task, Component, props) {
            var legacyContext;
            {
              legacyContext = getMaskedContext(Component, task.legacyContext);
            }
            pushFunctionComponentStackInDEV(task, Component);
            {
              if (Component.prototype && typeof Component.prototype.render === "function") {
                var componentName = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
            }
            var value = renderWithHooks(request, task, Component, props, legacyContext);
            var hasId = checkDidRenderIdHook();
            {
              if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                var _componentName = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              {
                var _componentName2 = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              mountClassInstance(value, Component, props, legacyContext);
              finishClassComponent(request, task, value, Component, props);
            } else {
              {
                validateFunctionComponentInDev(Component);
              }
              if (hasId) {
                var prevTreeContext = task.treeContext;
                var totalChildren = 1;
                var index = 0;
                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
                try {
                  renderNodeDestructive(request, task, value);
                } finally {
                  task.treeContext = prevTreeContext;
                }
              } else {
                renderNodeDestructive(request, task, value);
              }
            }
            popComponentStackInDEV(task);
          }
          function validateFunctionComponentInDev(Component) {
            {
              if (Component) {
                if (Component.childContextTypes) {
                  error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
                }
              }
              if (typeof Component.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component.contextType === "object" && Component.contextType !== null) {
                var _componentName4 = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          function resolveDefaultProps(Component, baseProps) {
            if (Component && Component.defaultProps) {
              var props = assign({}, baseProps);
              var defaultProps = Component.defaultProps;
              for (var propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          function renderForwardRef(request, task, type, props, ref) {
            pushFunctionComponentStackInDEV(task, type.render);
            var children = renderWithHooks(request, task, type.render, props, ref);
            var hasId = checkDidRenderIdHook();
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
              try {
                renderNodeDestructive(request, task, children);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request, task, children);
            }
            popComponentStackInDEV(task);
          }
          function renderMemo(request, task, type, props, ref) {
            var innerType = type.type;
            var resolvedProps = resolveDefaultProps(innerType, props);
            renderElement(request, task, innerType, resolvedProps, ref);
          }
          function renderContextConsumer(request, task, context, props) {
            {
              if (context._context === void 0) {
                if (context !== context.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context = context._context;
              }
            }
            var render = props.children;
            {
              if (typeof render !== "function") {
                error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            var newValue = readContext(context);
            var newChildren = render(newValue);
            renderNodeDestructive(request, task, newChildren);
          }
          function renderContextProvider(request, task, type, props) {
            var context = type._context;
            var value = props.value;
            var children = props.children;
            var prevSnapshot;
            {
              prevSnapshot = task.context;
            }
            task.context = pushProvider(context, value);
            renderNodeDestructive(request, task, children);
            task.context = popProvider(context);
            {
              if (prevSnapshot !== task.context) {
                error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
              }
            }
          }
          function renderLazyComponent(request, task, lazyComponent, props, ref) {
            pushBuiltInComponentStackInDEV(task, "Lazy");
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;
            var Component = init(payload);
            var resolvedProps = resolveDefaultProps(Component, props);
            renderElement(request, task, Component, resolvedProps, ref);
            popComponentStackInDEV(task);
          }
          function renderElement(request, task, type, props, ref) {
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                renderClassComponent(request, task, type, props);
                return;
              } else {
                renderIndeterminateComponent(request, task, type, props);
                return;
              }
            }
            if (typeof type === "string") {
              renderHostElement(request, task, type, props);
              return;
            }
            switch (type) {
              case REACT_LEGACY_HIDDEN_TYPE:
              case REACT_DEBUG_TRACING_MODE_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_FRAGMENT_TYPE: {
                renderNodeDestructive(request, task, props.children);
                return;
              }
              case REACT_SUSPENSE_LIST_TYPE: {
                pushBuiltInComponentStackInDEV(task, "SuspenseList");
                renderNodeDestructive(request, task, props.children);
                popComponentStackInDEV(task);
                return;
              }
              case REACT_SCOPE_TYPE: {
                throw new Error("ReactDOMServer does not yet support scope components.");
              }
              case REACT_SUSPENSE_TYPE: {
                {
                  renderSuspenseBoundary(request, task, props);
                }
                return;
              }
            }
            if (typeof type === "object" && type !== null) {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE: {
                  renderForwardRef(request, task, type, props, ref);
                  return;
                }
                case REACT_MEMO_TYPE: {
                  renderMemo(request, task, type, props, ref);
                  return;
                }
                case REACT_PROVIDER_TYPE: {
                  renderContextProvider(request, task, type, props);
                  return;
                }
                case REACT_CONTEXT_TYPE: {
                  renderContextConsumer(request, task, type, props);
                  return;
                }
                case REACT_LAZY_TYPE: {
                  renderLazyComponent(request, task, type, props);
                  return;
                }
              }
            }
            var info = "";
            {
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
          }
          function validateIterable(iterable, iteratorFn) {
            {
              if (typeof Symbol === "function" && iterable[Symbol.toStringTag] === "Generator") {
                if (!didWarnAboutGenerators) {
                  error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                }
                didWarnAboutGenerators = true;
              }
              if (iterable.entries === iteratorFn) {
                if (!didWarnAboutMaps) {
                  error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
            }
          }
          function renderNodeDestructive(request, task, node) {
            {
              try {
                return renderNodeDestructiveImpl(request, task, node);
              } catch (x) {
                if (typeof x === "object" && x !== null && typeof x.then === "function")
                  ;
                else {
                  lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
                }
                throw x;
              }
            }
          }
          function renderNodeDestructiveImpl(request, task, node) {
            task.node = node;
            if (typeof node === "object" && node !== null) {
              switch (node.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var element = node;
                  var type = element.type;
                  var props = element.props;
                  var ref = element.ref;
                  renderElement(request, task, type, props, ref);
                  return;
                }
                case REACT_PORTAL_TYPE:
                  throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                case REACT_LAZY_TYPE: {
                  var lazyNode = node;
                  var payload = lazyNode._payload;
                  var init = lazyNode._init;
                  var resolvedNode;
                  {
                    try {
                      resolvedNode = init(payload);
                    } catch (x) {
                      if (typeof x === "object" && x !== null && typeof x.then === "function") {
                        pushBuiltInComponentStackInDEV(task, "Lazy");
                      }
                      throw x;
                    }
                  }
                  renderNodeDestructive(request, task, resolvedNode);
                  return;
                }
              }
              if (isArray(node)) {
                renderChildrenArray(request, task, node);
                return;
              }
              var iteratorFn = getIteratorFn(node);
              if (iteratorFn) {
                {
                  validateIterable(node, iteratorFn);
                }
                var iterator = iteratorFn.call(node);
                if (iterator) {
                  var step = iterator.next();
                  if (!step.done) {
                    var children = [];
                    do {
                      children.push(step.value);
                      step = iterator.next();
                    } while (!step.done);
                    renderChildrenArray(request, task, children);
                    return;
                  }
                  return;
                }
              }
              var childString = Object.prototype.toString.call(node);
              throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
            }
            if (typeof node === "string") {
              var segment = task.blockedSegment;
              segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
              return;
            }
            if (typeof node === "number") {
              var _segment = task.blockedSegment;
              _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
              return;
            }
            {
              if (typeof node === "function") {
                error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
              }
            }
          }
          function renderChildrenArray(request, task, children) {
            var totalChildren = children.length;
            for (var i = 0; i < totalChildren; i++) {
              var prevTreeContext = task.treeContext;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
              try {
                renderNode(request, task, children[i]);
              } finally {
                task.treeContext = prevTreeContext;
              }
            }
          }
          function spawnNewSuspendedTask(request, task, x) {
            var segment = task.blockedSegment;
            var insertionIndex = segment.chunks.length;
            var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);
            segment.children.push(newSegment);
            segment.lastPushedText = false;
            var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
            {
              if (task.componentStack !== null) {
                newTask.componentStack = task.componentStack.parent;
              }
            }
            var ping = newTask.ping;
            x.then(ping, ping);
          }
          function renderNode(request, task, node) {
            var previousFormatContext = task.blockedSegment.formatContext;
            var previousLegacyContext = task.legacyContext;
            var previousContext = task.context;
            var previousComponentStack = null;
            {
              previousComponentStack = task.componentStack;
            }
            try {
              return renderNodeDestructive(request, task, node);
            } catch (x) {
              resetHooksState();
              if (typeof x === "object" && x !== null && typeof x.then === "function") {
                spawnNewSuspendedTask(request, task, x);
                task.blockedSegment.formatContext = previousFormatContext;
                task.legacyContext = previousLegacyContext;
                task.context = previousContext;
                switchContext(previousContext);
                {
                  task.componentStack = previousComponentStack;
                }
                return;
              } else {
                task.blockedSegment.formatContext = previousFormatContext;
                task.legacyContext = previousLegacyContext;
                task.context = previousContext;
                switchContext(previousContext);
                {
                  task.componentStack = previousComponentStack;
                }
                throw x;
              }
            }
          }
          function erroredTask(request, boundary, segment, error2) {
            var errorDigest = logRecoverableError(request, error2);
            if (boundary === null) {
              fatalError(request, error2);
            } else {
              boundary.pendingTasks--;
              if (!boundary.forceClientRender) {
                boundary.forceClientRender = true;
                boundary.errorDigest = errorDigest;
                {
                  captureBoundaryErrorDetailsDev(boundary, error2);
                }
                if (boundary.parentFlushed) {
                  request.clientRenderedBoundaries.push(boundary);
                }
              }
            }
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
              var onAllReady = request.onAllReady;
              onAllReady();
            }
          }
          function abortTaskSoft(task) {
            var request = this;
            var boundary = task.blockedBoundary;
            var segment = task.blockedSegment;
            segment.status = ABORTED;
            finishedTask(request, boundary, segment);
          }
          function abortTask(task, request, reason) {
            var boundary = task.blockedBoundary;
            var segment = task.blockedSegment;
            segment.status = ABORTED;
            if (boundary === null) {
              request.allPendingTasks--;
              if (request.status !== CLOSED) {
                request.status = CLOSED;
                if (request.destination !== null) {
                  close(request.destination);
                }
              }
            } else {
              boundary.pendingTasks--;
              if (!boundary.forceClientRender) {
                boundary.forceClientRender = true;
                var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
                boundary.errorDigest = request.onError(_error);
                {
                  var errorPrefix = "The server did not finish this Suspense boundary: ";
                  if (_error && typeof _error.message === "string") {
                    _error = errorPrefix + _error.message;
                  } else {
                    _error = errorPrefix + String(_error);
                  }
                  var previousTaskInDev = currentTaskInDEV;
                  currentTaskInDEV = task;
                  try {
                    captureBoundaryErrorDetailsDev(boundary, _error);
                  } finally {
                    currentTaskInDEV = previousTaskInDev;
                  }
                }
                if (boundary.parentFlushed) {
                  request.clientRenderedBoundaries.push(boundary);
                }
              }
              boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
                return abortTask(fallbackTask, request, reason);
              });
              boundary.fallbackAbortableTasks.clear();
              request.allPendingTasks--;
              if (request.allPendingTasks === 0) {
                var onAllReady = request.onAllReady;
                onAllReady();
              }
            }
          }
          function queueCompletedSegment(boundary, segment) {
            if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
              var childSegment = segment.children[0];
              childSegment.id = segment.id;
              childSegment.parentFlushed = true;
              if (childSegment.status === COMPLETED) {
                queueCompletedSegment(boundary, childSegment);
              }
            } else {
              var completedSegments = boundary.completedSegments;
              completedSegments.push(segment);
            }
          }
          function finishedTask(request, boundary, segment) {
            if (boundary === null) {
              if (segment.parentFlushed) {
                if (request.completedRootSegment !== null) {
                  throw new Error("There can only be one root segment. This is a bug in React.");
                }
                request.completedRootSegment = segment;
              }
              request.pendingRootTasks--;
              if (request.pendingRootTasks === 0) {
                request.onShellError = noop$1;
                var onShellReady = request.onShellReady;
                onShellReady();
              }
            } else {
              boundary.pendingTasks--;
              if (boundary.forceClientRender)
                ;
              else if (boundary.pendingTasks === 0) {
                if (segment.parentFlushed) {
                  if (segment.status === COMPLETED) {
                    queueCompletedSegment(boundary, segment);
                  }
                }
                if (boundary.parentFlushed) {
                  request.completedBoundaries.push(boundary);
                }
                boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
                boundary.fallbackAbortableTasks.clear();
              } else {
                if (segment.parentFlushed) {
                  if (segment.status === COMPLETED) {
                    queueCompletedSegment(boundary, segment);
                    var completedSegments = boundary.completedSegments;
                    if (completedSegments.length === 1) {
                      if (boundary.parentFlushed) {
                        request.partialBoundaries.push(boundary);
                      }
                    }
                  }
                }
              }
            }
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
              var onAllReady = request.onAllReady;
              onAllReady();
            }
          }
          function retryTask(request, task) {
            var segment = task.blockedSegment;
            if (segment.status !== PENDING) {
              return;
            }
            switchContext(task.context);
            var prevTaskInDEV = null;
            {
              prevTaskInDEV = currentTaskInDEV;
              currentTaskInDEV = task;
            }
            try {
              renderNodeDestructive(request, task, task.node);
              pushSegmentFinale$1(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
              task.abortSet.delete(task);
              segment.status = COMPLETED;
              finishedTask(request, task.blockedBoundary, segment);
            } catch (x) {
              resetHooksState();
              if (typeof x === "object" && x !== null && typeof x.then === "function") {
                var ping = task.ping;
                x.then(ping, ping);
              } else {
                task.abortSet.delete(task);
                segment.status = ERRORED;
                erroredTask(request, task.blockedBoundary, segment, x);
              }
            } finally {
              {
                currentTaskInDEV = prevTaskInDEV;
              }
            }
          }
          function performWork(request) {
            if (request.status === CLOSED) {
              return;
            }
            var prevContext = getActiveContext();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = Dispatcher;
            var prevGetCurrentStackImpl;
            {
              prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
              ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
            }
            var prevResponseState = currentResponseState;
            setCurrentResponseState(request.responseState);
            try {
              var pingedTasks = request.pingedTasks;
              var i;
              for (i = 0; i < pingedTasks.length; i++) {
                var task = pingedTasks[i];
                retryTask(request, task);
              }
              pingedTasks.splice(0, i);
              if (request.destination !== null) {
                flushCompletedQueues(request, request.destination);
              }
            } catch (error2) {
              logRecoverableError(request, error2);
              fatalError(request, error2);
            } finally {
              setCurrentResponseState(prevResponseState);
              ReactCurrentDispatcher$1.current = prevDispatcher;
              {
                ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
              }
              if (prevDispatcher === Dispatcher) {
                switchContext(prevContext);
              }
            }
          }
          function flushSubtree(request, destination, segment) {
            segment.parentFlushed = true;
            switch (segment.status) {
              case PENDING: {
                var segmentID = segment.id = request.nextSegmentId++;
                segment.lastPushedText = false;
                segment.textEmbedded = false;
                return writePlaceholder(destination, request.responseState, segmentID);
              }
              case COMPLETED: {
                segment.status = FLUSHED;
                var r = true;
                var chunks = segment.chunks;
                var chunkIdx = 0;
                var children = segment.children;
                for (var childIdx = 0; childIdx < children.length; childIdx++) {
                  var nextChild = children[childIdx];
                  for (; chunkIdx < nextChild.index; chunkIdx++) {
                    writeChunk(destination, chunks[chunkIdx]);
                  }
                  r = flushSegment(request, destination, nextChild);
                }
                for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                if (chunkIdx < chunks.length) {
                  r = writeChunkAndReturn(destination, chunks[chunkIdx]);
                }
                return r;
              }
              default: {
                throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
              }
            }
          }
          function flushSegment(request, destination, segment) {
            var boundary = segment.boundary;
            if (boundary === null) {
              return flushSubtree(request, destination, segment);
            }
            boundary.parentFlushed = true;
            if (boundary.forceClientRender) {
              writeStartClientRenderedSuspenseBoundary$1(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
              flushSubtree(request, destination, segment);
              return writeEndClientRenderedSuspenseBoundary$1(destination, request.responseState);
            } else if (boundary.pendingTasks > 0) {
              boundary.rootSegmentID = request.nextSegmentId++;
              if (boundary.completedSegments.length > 0) {
                request.partialBoundaries.push(boundary);
              }
              var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
              writeStartPendingSuspenseBoundary(destination, request.responseState, id);
              flushSubtree(request, destination, segment);
              return writeEndPendingSuspenseBoundary(destination, request.responseState);
            } else if (boundary.byteSize > request.progressiveChunkSize) {
              boundary.rootSegmentID = request.nextSegmentId++;
              request.completedBoundaries.push(boundary);
              writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
              flushSubtree(request, destination, segment);
              return writeEndPendingSuspenseBoundary(destination, request.responseState);
            } else {
              writeStartCompletedSuspenseBoundary$1(destination, request.responseState);
              var completedSegments = boundary.completedSegments;
              if (completedSegments.length !== 1) {
                throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
              }
              var contentSegment = completedSegments[0];
              flushSegment(request, destination, contentSegment);
              return writeEndCompletedSuspenseBoundary$1(destination, request.responseState);
            }
          }
          function flushClientRenderedBoundary(request, destination, boundary) {
            return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
          }
          function flushSegmentContainer(request, destination, segment) {
            writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
            flushSegment(request, destination, segment);
            return writeEndSegment(destination, segment.formatContext);
          }
          function flushCompletedBoundary(request, destination, boundary) {
            var completedSegments = boundary.completedSegments;
            var i = 0;
            for (; i < completedSegments.length; i++) {
              var segment = completedSegments[i];
              flushPartiallyCompletedSegment(request, destination, boundary, segment);
            }
            completedSegments.length = 0;
            return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
          }
          function flushPartialBoundary(request, destination, boundary) {
            var completedSegments = boundary.completedSegments;
            var i = 0;
            for (; i < completedSegments.length; i++) {
              var segment = completedSegments[i];
              if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
                i++;
                completedSegments.splice(0, i);
                return false;
              }
            }
            completedSegments.splice(0, i);
            return true;
          }
          function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
            if (segment.status === FLUSHED) {
              return true;
            }
            var segmentID = segment.id;
            if (segmentID === -1) {
              var rootSegmentID = segment.id = boundary.rootSegmentID;
              if (rootSegmentID === -1) {
                throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
              }
              return flushSegmentContainer(request, destination, segment);
            } else {
              flushSegmentContainer(request, destination, segment);
              return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
            }
          }
          function flushCompletedQueues(request, destination) {
            try {
              var completedRootSegment = request.completedRootSegment;
              if (completedRootSegment !== null && request.pendingRootTasks === 0) {
                flushSegment(request, destination, completedRootSegment);
                request.completedRootSegment = null;
                writeCompletedRoot(destination, request.responseState);
              }
              var clientRenderedBoundaries = request.clientRenderedBoundaries;
              var i;
              for (i = 0; i < clientRenderedBoundaries.length; i++) {
                var boundary = clientRenderedBoundaries[i];
                if (!flushClientRenderedBoundary(request, destination, boundary)) {
                  request.destination = null;
                  i++;
                  clientRenderedBoundaries.splice(0, i);
                  return;
                }
              }
              clientRenderedBoundaries.splice(0, i);
              var completedBoundaries = request.completedBoundaries;
              for (i = 0; i < completedBoundaries.length; i++) {
                var _boundary = completedBoundaries[i];
                if (!flushCompletedBoundary(request, destination, _boundary)) {
                  request.destination = null;
                  i++;
                  completedBoundaries.splice(0, i);
                  return;
                }
              }
              completedBoundaries.splice(0, i);
              completeWriting(destination);
              beginWriting(destination);
              var partialBoundaries = request.partialBoundaries;
              for (i = 0; i < partialBoundaries.length; i++) {
                var _boundary2 = partialBoundaries[i];
                if (!flushPartialBoundary(request, destination, _boundary2)) {
                  request.destination = null;
                  i++;
                  partialBoundaries.splice(0, i);
                  return;
                }
              }
              partialBoundaries.splice(0, i);
              var largeBoundaries = request.completedBoundaries;
              for (i = 0; i < largeBoundaries.length; i++) {
                var _boundary3 = largeBoundaries[i];
                if (!flushCompletedBoundary(request, destination, _boundary3)) {
                  request.destination = null;
                  i++;
                  largeBoundaries.splice(0, i);
                  return;
                }
              }
              largeBoundaries.splice(0, i);
            } finally {
              if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
                {
                  if (request.abortableTasks.size !== 0) {
                    error("There was still abortable task at the root when we closed. This is a bug in React.");
                  }
                }
                close(destination);
              }
            }
          }
          function startWork(request) {
            scheduleWork(function() {
              return performWork(request);
            });
          }
          function startFlowing(request, destination) {
            if (request.status === CLOSING) {
              request.status = CLOSED;
              closeWithError(destination, request.fatalError);
              return;
            }
            if (request.status === CLOSED) {
              return;
            }
            if (request.destination !== null) {
              return;
            }
            request.destination = destination;
            try {
              flushCompletedQueues(request, destination);
            } catch (error2) {
              logRecoverableError(request, error2);
              fatalError(request, error2);
            }
          }
          function abort(request, reason) {
            try {
              var abortableTasks = request.abortableTasks;
              abortableTasks.forEach(function(task) {
                return abortTask(task, request, reason);
              });
              abortableTasks.clear();
              if (request.destination !== null) {
                flushCompletedQueues(request, request.destination);
              }
            } catch (error2) {
              logRecoverableError(request, error2);
              fatalError(request, error2);
            }
          }
          function onError() {
          }
          function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
            var didFatal = false;
            var fatalError2 = null;
            var result = "";
            var destination = {
              push: function(chunk) {
                if (chunk !== null) {
                  result += chunk;
                }
                return true;
              },
              destroy: function(error2) {
                didFatal = true;
                fatalError2 = error2;
              }
            };
            var readyToStream = false;
            function onShellReady() {
              readyToStream = true;
            }
            var request = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : void 0), createRootFormatContext(), Infinity, onError, void 0, onShellReady, void 0, void 0);
            startWork(request);
            abort(request, abortReason);
            startFlowing(request, destination);
            if (didFatal) {
              throw fatalError2;
            }
            if (!readyToStream) {
              throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
            }
            return result;
          }
          function renderToString2(children, options) {
            return renderToStringImpl(children, options, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
          }
          function renderToStaticMarkup(children, options) {
            return renderToStringImpl(children, options, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
          }
          function renderToNodeStream() {
            throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
          }
          function renderToStaticNodeStream() {
            throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
          }
          exports.renderToNodeStream = renderToNodeStream;
          exports.renderToStaticMarkup = renderToStaticMarkup;
          exports.renderToStaticNodeStream = renderToStaticNodeStream;
          exports.renderToString = renderToString2;
          exports.version = ReactVersion;
        })();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-server.browser.development.js
  var require_react_dom_server_browser_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom-server.browser.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React4 = require_react();
          var ReactVersion = "18.2.0";
          var ReactSharedInternals = React4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function warn(format) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format, args);
              }
            }
          }
          function error(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          function scheduleWork(callback) {
            callback();
          }
          var VIEW_SIZE = 512;
          var currentView = null;
          var writtenBytes = 0;
          function beginWriting(destination) {
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          function writeChunk(destination, chunk) {
            if (chunk.length === 0) {
              return;
            }
            if (chunk.length > VIEW_SIZE) {
              if (writtenBytes > 0) {
                destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
                currentView = new Uint8Array(VIEW_SIZE);
                writtenBytes = 0;
              }
              destination.enqueue(chunk);
              return;
            }
            var bytesToWrite = chunk;
            var allowableBytes = currentView.length - writtenBytes;
            if (allowableBytes < bytesToWrite.length) {
              if (allowableBytes === 0) {
                destination.enqueue(currentView);
              } else {
                currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
                destination.enqueue(currentView);
                bytesToWrite = bytesToWrite.subarray(allowableBytes);
              }
              currentView = new Uint8Array(VIEW_SIZE);
              writtenBytes = 0;
            }
            currentView.set(bytesToWrite, writtenBytes);
            writtenBytes += bytesToWrite.length;
          }
          function writeChunkAndReturn(destination, chunk) {
            writeChunk(destination, chunk);
            return true;
          }
          function completeWriting(destination) {
            if (currentView && writtenBytes > 0) {
              destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
              currentView = null;
              writtenBytes = 0;
            }
          }
          function close(destination) {
            destination.close();
          }
          var textEncoder = new TextEncoder();
          function stringToChunk(content) {
            return textEncoder.encode(content);
          }
          function stringToPrecomputedChunk(content) {
            return textEncoder.encode(content);
          }
          function closeWithError(destination, error2) {
            if (typeof destination.error === "function") {
              destination.error(error2);
            } else {
              destination.close();
            }
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkAttributeStringCoercion(value, attributeName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkCSSPropertyStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkHtmlStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  return prefix2 !== "data-" && prefix2 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function getPropertyInfo(name) {
            return properties.hasOwnProperty(name) ? properties[name] : null;
          }
          function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name = _ref[0], attributeName = _ref[1];
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
          });
          [
            "allowFullScreen",
            "async",
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            "itemScope"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
          });
          [
            "checked",
            "multiple",
            "muted",
            "selected"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
          });
          [
            "capture",
            "download"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
          });
          [
            "cols",
            "rows",
            "size",
            "span"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
          });
          ["rowSpan", "start"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
          });
          var isUnitlessNumber = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix2, key) {
            return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes2 = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes2.forEach(function(prefix2) {
              isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
            });
          });
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var ariaProperties = {
            "aria-current": 0,
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            "aria-hidden": 0,
            "aria-invalid": 0,
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          function validateProperty(tagName, name) {
            {
              if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
                return true;
              }
              if (rARIACamel.test(name)) {
                var ariaName = "aria-" + name.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                  warnedProperties[name] = true;
                  return true;
                }
                if (name !== correctName) {
                  error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
              if (rARIA.test(name)) {
                var lowerCasedName = name.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name] = true;
                  return false;
                }
                if (name !== standardName) {
                  error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid = validateProperty(type, key);
                if (!isValid) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var possibleStandardNames = {
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name, value, eventRegistry) {
              if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
                return true;
              }
              var lowerCasedName = name.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (eventRegistry != null) {
                var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
                if (registrationNameDependencies.hasOwnProperty(name)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
                if (registrationName != null) {
                  error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                  warnedProperties$1[name] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name)) {
                  error("Unknown event handler property `%s`. It will be ignored.", name);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name)) {
                if (INVALID_EVENT_NAME_REGEX.test(name)) {
                  error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
                error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "number" && isNaN(value)) {
                error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
                warnedProperties$1[name] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name) {
                  error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (!isReserved && name !== lowerCasedName) {
                error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                if (value) {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
                } else {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                warnedProperties$1[name] = true;
                return false;
              }
              if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
                warnedProperties$1[name] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid = validateProperty$1(type, key, props[key], eventRegistry);
                if (!isValid) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry);
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string2) {
              return string2.replace(hyphenPattern, function(_, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern, "ms-")));
            };
            var warnBadVendoredStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name, value) {
              if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                return;
              }
              warnedStyleValues[value] = true;
              error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name, value) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error("`NaN` is an invalid value for the `%s` css style property.", name);
            };
            var warnStyleValueIsInfinity = function(name, value) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error("`Infinity` is an invalid value for the `%s` css style property.", name);
            };
            warnValidStyle = function(name, value) {
              if (name.indexOf("-") > -1) {
                warnHyphenatedStyleName(name);
              } else if (badVendoredStyleNamePattern.test(name)) {
                warnBadVendoredStyleName(name);
              } else if (badStyleValueWithSemicolonPattern.test(value)) {
                warnStyleValueWithSemicolon(name, value);
              }
              if (typeof value === "number") {
                if (isNaN(value)) {
                  warnStyleValueIsNaN(name, value);
                } else if (!isFinite(value)) {
                  warnStyleValueIsInfinity(name, value);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          var matchHtmlRegExp = /["'&<>]/;
          function escapeHtml(string2) {
            {
              checkHtmlStringCoercion(string2);
            }
            var str = "" + string2;
            var match = matchHtmlRegExp.exec(str);
            if (!match) {
              return str;
            }
            var escape2;
            var html = "";
            var index;
            var lastIndex = 0;
            for (index = match.index; index < str.length; index++) {
              switch (str.charCodeAt(index)) {
                case 34:
                  escape2 = "&quot;";
                  break;
                case 38:
                  escape2 = "&amp;";
                  break;
                case 39:
                  escape2 = "&#x27;";
                  break;
                case 60:
                  escape2 = "&lt;";
                  break;
                case 62:
                  escape2 = "&gt;";
                  break;
                default:
                  continue;
              }
              if (lastIndex !== index) {
                html += str.substring(lastIndex, index);
              }
              lastIndex = index + 1;
              html += escape2;
            }
            return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
          }
          function escapeTextForBrowser(text) {
            if (typeof text === "boolean" || typeof text === "number") {
              return "" + text;
            }
            return escapeHtml(text);
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern$1 = /^ms-/;
          function hyphenateStyleName(name) {
            return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
          }
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray(a) {
            return isArrayImpl(a);
          }
          var startInlineScript = stringToPrecomputedChunk("<script>");
          var endInlineScript = stringToPrecomputedChunk("<\/script>");
          var startScriptSrc = stringToPrecomputedChunk('<script src="');
          var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
          var endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>');
          function escapeBootstrapScriptContent(scriptText) {
            {
              checkHtmlStringCoercion(scriptText);
            }
            return ("" + scriptText).replace(scriptRegex, scriptReplacer);
          }
          var scriptRegex = /(<\/|<)(s)(cript)/gi;
          var scriptReplacer = function(match, prefix2, s, suffix) {
            return "" + prefix2 + (s === "s" ? "\\u0073" : "\\u0053") + suffix;
          };
          function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
            var idPrefix2 = identifierPrefix === void 0 ? "" : identifierPrefix;
            var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
            var bootstrapChunks = [];
            if (bootstrapScriptContent !== void 0) {
              bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
            }
            if (bootstrapScripts !== void 0) {
              for (var i = 0; i < bootstrapScripts.length; i++) {
                bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
              }
            }
            if (bootstrapModules !== void 0) {
              for (var _i = 0; _i < bootstrapModules.length; _i++) {
                bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
              }
            }
            return {
              bootstrapChunks,
              startInlineScript: inlineScriptWithNonce,
              placeholderPrefix: stringToPrecomputedChunk(idPrefix2 + "P:"),
              segmentPrefix: stringToPrecomputedChunk(idPrefix2 + "S:"),
              boundaryPrefix: idPrefix2 + "B:",
              idPrefix: idPrefix2,
              nextSuspenseID: 0,
              sentCompleteSegmentFunction: false,
              sentCompleteBoundaryFunction: false,
              sentClientRenderFunction: false
            };
          }
          var ROOT_HTML_MODE = 0;
          var HTML_MODE = 1;
          var SVG_MODE = 2;
          var MATHML_MODE = 3;
          var HTML_TABLE_MODE = 4;
          var HTML_TABLE_BODY_MODE = 5;
          var HTML_TABLE_ROW_MODE = 6;
          var HTML_COLGROUP_MODE = 7;
          function createFormatContext(insertionMode, selectedValue) {
            return {
              insertionMode,
              selectedValue
            };
          }
          function createRootFormatContext(namespaceURI) {
            var insertionMode = namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE;
            return createFormatContext(insertionMode, null);
          }
          function getChildFormatContext(parentContext, type, props) {
            switch (type) {
              case "select":
                return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
              case "svg":
                return createFormatContext(SVG_MODE, null);
              case "math":
                return createFormatContext(MATHML_MODE, null);
              case "foreignObject":
                return createFormatContext(HTML_MODE, null);
              case "table":
                return createFormatContext(HTML_TABLE_MODE, null);
              case "thead":
              case "tbody":
              case "tfoot":
                return createFormatContext(HTML_TABLE_BODY_MODE, null);
              case "colgroup":
                return createFormatContext(HTML_COLGROUP_MODE, null);
              case "tr":
                return createFormatContext(HTML_TABLE_ROW_MODE, null);
            }
            if (parentContext.insertionMode >= HTML_TABLE_MODE) {
              return createFormatContext(HTML_MODE, null);
            }
            if (parentContext.insertionMode === ROOT_HTML_MODE) {
              return createFormatContext(HTML_MODE, null);
            }
            return parentContext;
          }
          var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
          function assignSuspenseBoundaryID(responseState) {
            var generatedID = responseState.nextSuspenseID++;
            return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
          }
          function makeId(responseState, treeId, localId) {
            var idPrefix2 = responseState.idPrefix;
            var id = ":" + idPrefix2 + "R" + treeId;
            if (localId > 0) {
              id += "H" + localId.toString(32);
            }
            return id + ":";
          }
          function encodeHTMLTextNode(text) {
            return escapeTextForBrowser(text);
          }
          var textSeparator = stringToPrecomputedChunk("<!-- -->");
          function pushTextInstance(target, text, responseState, textEmbedded) {
            if (text === "") {
              return textEmbedded;
            }
            if (textEmbedded) {
              target.push(textSeparator);
            }
            target.push(stringToChunk(encodeHTMLTextNode(text)));
            return true;
          }
          function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
            if (lastPushedText && textEmbedded) {
              target.push(textSeparator);
            }
          }
          var styleNameCache = /* @__PURE__ */ new Map();
          function processStyleName(styleName) {
            var chunk = styleNameCache.get(styleName);
            if (chunk !== void 0) {
              return chunk;
            }
            var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
            styleNameCache.set(styleName, result);
            return result;
          }
          var styleAttributeStart = stringToPrecomputedChunk(' style="');
          var styleAssign = stringToPrecomputedChunk(":");
          var styleSeparator = stringToPrecomputedChunk(";");
          function pushStyle(target, responseState, style) {
            if (typeof style !== "object") {
              throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
            var isFirst = true;
            for (var styleName in style) {
              if (!hasOwnProperty.call(style, styleName)) {
                continue;
              }
              var styleValue = style[styleName];
              if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
                continue;
              }
              var nameChunk = void 0;
              var valueChunk = void 0;
              var isCustomProperty = styleName.indexOf("--") === 0;
              if (isCustomProperty) {
                nameChunk = stringToChunk(escapeTextForBrowser(styleName));
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              } else {
                {
                  warnValidStyle$1(styleName, styleValue);
                }
                nameChunk = processStyleName(styleName);
                if (typeof styleValue === "number") {
                  if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                    valueChunk = stringToChunk(styleValue + "px");
                  } else {
                    valueChunk = stringToChunk("" + styleValue);
                  }
                } else {
                  {
                    checkCSSPropertyStringCoercion(styleValue, styleName);
                  }
                  valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
                }
              }
              if (isFirst) {
                isFirst = false;
                target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
              } else {
                target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
              }
            }
            if (!isFirst) {
              target.push(attributeEnd);
            }
          }
          var attributeSeparator = stringToPrecomputedChunk(" ");
          var attributeAssign = stringToPrecomputedChunk('="');
          var attributeEnd = stringToPrecomputedChunk('"');
          var attributeEmptyString = stringToPrecomputedChunk('=""');
          function pushAttribute(target, responseState, name, value) {
            switch (name) {
              case "style": {
                pushStyle(target, responseState, value);
                return;
              }
              case "defaultValue":
              case "defaultChecked":
              case "innerHTML":
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                return;
            }
            if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
              return;
            }
            var propertyInfo = getPropertyInfo(name);
            if (propertyInfo !== null) {
              switch (typeof value) {
                case "function":
                case "symbol":
                  return;
                case "boolean": {
                  if (!propertyInfo.acceptsBooleans) {
                    return;
                  }
                }
              }
              var attributeName = propertyInfo.attributeName;
              var attributeNameChunk = stringToChunk(attributeName);
              switch (propertyInfo.type) {
                case BOOLEAN:
                  if (value) {
                    target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                  }
                  return;
                case OVERLOADED_BOOLEAN:
                  if (value === true) {
                    target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                  } else if (value === false)
                    ;
                  else {
                    target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                  }
                  return;
                case NUMERIC:
                  if (!isNaN(value)) {
                    target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                  }
                  break;
                case POSITIVE_NUMERIC:
                  if (!isNaN(value) && value >= 1) {
                    target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                  }
                  break;
                default:
                  if (propertyInfo.sanitizeURL) {
                    {
                      checkAttributeStringCoercion(value, attributeName);
                    }
                    value = "" + value;
                    sanitizeURL(value);
                  }
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
            } else if (isAttributeNameSafe(name)) {
              switch (typeof value) {
                case "function":
                case "symbol":
                  return;
                case "boolean": {
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  if (prefix2 !== "data-" && prefix2 !== "aria-") {
                    return;
                  }
                }
              }
              target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
            }
          }
          var endOfStartTag = stringToPrecomputedChunk(">");
          var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
          function pushInnerHTML(target, innerHTML, children) {
            if (innerHTML != null) {
              if (children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
              var html = innerHTML.__html;
              if (html !== null && html !== void 0) {
                {
                  checkHtmlStringCoercion(html);
                }
                target.push(stringToChunk("" + html));
              }
            }
          }
          var didWarnDefaultInputValue = false;
          var didWarnDefaultChecked = false;
          var didWarnDefaultSelectValue = false;
          var didWarnDefaultTextareaValue = false;
          var didWarnInvalidOptionChildren = false;
          var didWarnInvalidOptionInnerHTML = false;
          var didWarnSelectedSetOnOption = false;
          function checkSelectProp(props, propName) {
            {
              var value = props[propName];
              if (value != null) {
                var array2 = isArray(value);
                if (props.multiple && !array2) {
                  error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
                } else if (!props.multiple && array2) {
                  error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
                }
              }
            }
          }
          function pushStartSelect(target, props, responseState) {
            {
              checkControlledValueProps("select", props);
              checkSelectProp(props, "value");
              checkSelectProp(props, "defaultValue");
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
                error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnDefaultSelectValue = true;
              }
            }
            target.push(startChunkForTag("select"));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target.push(endOfStartTag);
            pushInnerHTML(target, innerHTML, children);
            return children;
          }
          function flattenOptionChildren(children) {
            var content = "";
            React4.Children.forEach(children, function(child) {
              if (child == null) {
                return;
              }
              content += child;
              {
                if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                  didWarnInvalidOptionChildren = true;
                  error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                }
              }
            });
            return content;
          }
          var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
          function pushStartOption(target, props, responseState, formatContext) {
            var selectedValue = formatContext.selectedValue;
            target.push(startChunkForTag("option"));
            var children = null;
            var value = null;
            var selected = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "selected":
                    selected = propValue;
                    {
                      if (!didWarnSelectedSetOnOption) {
                        error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                        didWarnSelectedSetOnOption = true;
                      }
                    }
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "value":
                    value = propValue;
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            if (selectedValue != null) {
              var stringValue;
              if (value !== null) {
                {
                  checkAttributeStringCoercion(value, "value");
                }
                stringValue = "" + value;
              } else {
                {
                  if (innerHTML !== null) {
                    if (!didWarnInvalidOptionInnerHTML) {
                      didWarnInvalidOptionInnerHTML = true;
                      error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                    }
                  }
                }
                stringValue = flattenOptionChildren(children);
              }
              if (isArray(selectedValue)) {
                for (var i = 0; i < selectedValue.length; i++) {
                  {
                    checkAttributeStringCoercion(selectedValue[i], "value");
                  }
                  var v = "" + selectedValue[i];
                  if (v === stringValue) {
                    target.push(selectedMarkerAttribute);
                    break;
                  }
                }
              } else {
                {
                  checkAttributeStringCoercion(selectedValue, "select.value");
                }
                if ("" + selectedValue === stringValue) {
                  target.push(selectedMarkerAttribute);
                }
              }
            } else if (selected) {
              target.push(selectedMarkerAttribute);
            }
            target.push(endOfStartTag);
            pushInnerHTML(target, innerHTML, children);
            return children;
          }
          function pushInput(target, props, responseState) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
                error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                didWarnDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
                error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                didWarnDefaultInputValue = true;
              }
            }
            target.push(startChunkForTag("input"));
            var value = null;
            var defaultValue = null;
            var checked = null;
            var defaultChecked = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  case "defaultChecked":
                    defaultChecked = propValue;
                    break;
                  case "defaultValue":
                    defaultValue = propValue;
                    break;
                  case "checked":
                    checked = propValue;
                    break;
                  case "value":
                    value = propValue;
                    break;
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            if (checked !== null) {
              pushAttribute(target, responseState, "checked", checked);
            } else if (defaultChecked !== null) {
              pushAttribute(target, responseState, "checked", defaultChecked);
            }
            if (value !== null) {
              pushAttribute(target, responseState, "value", value);
            } else if (defaultValue !== null) {
              pushAttribute(target, responseState, "value", defaultValue);
            }
            target.push(endOfStartTagSelfClosing);
            return null;
          }
          function pushStartTextArea(target, props, responseState) {
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
                error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnDefaultTextareaValue = true;
              }
            }
            target.push(startChunkForTag("textarea"));
            var value = null;
            var defaultValue = null;
            var children = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "value":
                    value = propValue;
                    break;
                  case "defaultValue":
                    defaultValue = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            if (value === null && defaultValue !== null) {
              value = defaultValue;
            }
            target.push(endOfStartTag);
            if (children != null) {
              {
                error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
              }
              if (value != null) {
                throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
              }
              if (isArray(children)) {
                if (children.length > 1) {
                  throw new Error("<textarea> can only have at most one child.");
                }
                {
                  checkHtmlStringCoercion(children[0]);
                }
                value = "" + children[0];
              }
              {
                checkHtmlStringCoercion(children);
              }
              value = "" + children;
            }
            if (typeof value === "string" && value[0] === "\n") {
              target.push(leadingNewline);
            }
            if (value !== null) {
              {
                checkAttributeStringCoercion(value, "value");
              }
              target.push(stringToChunk(encodeHTMLTextNode("" + value)));
            }
            return null;
          }
          function pushSelfClosing(target, props, tag, responseState) {
            target.push(startChunkForTag(tag));
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target.push(endOfStartTagSelfClosing);
            return null;
          }
          function pushStartMenuItem(target, props, responseState) {
            target.push(startChunkForTag("menuitem"));
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target.push(endOfStartTag);
            return null;
          }
          function pushStartTitle(target, props, responseState) {
            target.push(startChunkForTag("title"));
            var children = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target.push(endOfStartTag);
            {
              var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
              if (Array.isArray(children) && children.length > 1) {
                error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
              } else if (child != null && child.$$typeof != null) {
                error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
              } else if (child != null && typeof child !== "string" && typeof child !== "number") {
                error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
              }
            }
            return children;
          }
          function pushStartGenericElement(target, props, tag, responseState) {
            target.push(startChunkForTag(tag));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target.push(endOfStartTag);
            pushInnerHTML(target, innerHTML, children);
            if (typeof children === "string") {
              target.push(stringToChunk(encodeHTMLTextNode(children)));
              return null;
            }
            return children;
          }
          function pushStartCustomElement(target, props, tag, responseState) {
            target.push(startChunkForTag(tag));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "style":
                    pushStyle(target, responseState, propValue);
                    break;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                    break;
                  default:
                    if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                      target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                    }
                    break;
                }
              }
            }
            target.push(endOfStartTag);
            pushInnerHTML(target, innerHTML, children);
            return children;
          }
          var leadingNewline = stringToPrecomputedChunk("\n");
          function pushStartPreformattedElement(target, props, tag, responseState) {
            target.push(startChunkForTag(tag));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target.push(endOfStartTag);
            if (innerHTML != null) {
              if (children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
              var html = innerHTML.__html;
              if (html !== null && html !== void 0) {
                if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                  target.push(leadingNewline, stringToChunk(html));
                } else {
                  {
                    checkHtmlStringCoercion(html);
                  }
                  target.push(stringToChunk("" + html));
                }
              }
            }
            if (typeof children === "string" && children[0] === "\n") {
              target.push(leadingNewline);
            }
            return children;
          }
          var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
          var validatedTagCache = /* @__PURE__ */ new Map();
          function startChunkForTag(tag) {
            var tagStartChunk = validatedTagCache.get(tag);
            if (tagStartChunk === void 0) {
              if (!VALID_TAG_REGEX.test(tag)) {
                throw new Error("Invalid tag: " + tag);
              }
              tagStartChunk = stringToPrecomputedChunk("<" + tag);
              validatedTagCache.set(tag, tagStartChunk);
            }
            return tagStartChunk;
          }
          var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
          function pushStartInstance(target, type, props, responseState, formatContext) {
            {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, null);
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
              if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
                if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
            }
            switch (type) {
              case "select":
                return pushStartSelect(target, props, responseState);
              case "option":
                return pushStartOption(target, props, responseState, formatContext);
              case "textarea":
                return pushStartTextArea(target, props, responseState);
              case "input":
                return pushInput(target, props, responseState);
              case "menuitem":
                return pushStartMenuItem(target, props, responseState);
              case "title":
                return pushStartTitle(target, props, responseState);
              case "listing":
              case "pre": {
                return pushStartPreformattedElement(target, props, type, responseState);
              }
              case "area":
              case "base":
              case "br":
              case "col":
              case "embed":
              case "hr":
              case "img":
              case "keygen":
              case "link":
              case "meta":
              case "param":
              case "source":
              case "track":
              case "wbr": {
                return pushSelfClosing(target, props, type, responseState);
              }
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph": {
                return pushStartGenericElement(target, props, type, responseState);
              }
              case "html": {
                if (formatContext.insertionMode === ROOT_HTML_MODE) {
                  target.push(DOCTYPE);
                }
                return pushStartGenericElement(target, props, type, responseState);
              }
              default: {
                if (type.indexOf("-") === -1 && typeof props.is !== "string") {
                  return pushStartGenericElement(target, props, type, responseState);
                } else {
                  return pushStartCustomElement(target, props, type, responseState);
                }
              }
            }
          }
          var endTag1 = stringToPrecomputedChunk("</");
          var endTag2 = stringToPrecomputedChunk(">");
          function pushEndInstance(target, type, props) {
            switch (type) {
              case "area":
              case "base":
              case "br":
              case "col":
              case "embed":
              case "hr":
              case "img":
              case "input":
              case "keygen":
              case "link":
              case "meta":
              case "param":
              case "source":
              case "track":
              case "wbr": {
                break;
              }
              default: {
                target.push(endTag1, stringToChunk(type), endTag2);
              }
            }
          }
          function writeCompletedRoot(destination, responseState) {
            var bootstrapChunks = responseState.bootstrapChunks;
            var i = 0;
            for (; i < bootstrapChunks.length - 1; i++) {
              writeChunk(destination, bootstrapChunks[i]);
            }
            if (i < bootstrapChunks.length) {
              return writeChunkAndReturn(destination, bootstrapChunks[i]);
            }
            return true;
          }
          var placeholder1 = stringToPrecomputedChunk('<template id="');
          var placeholder2 = stringToPrecomputedChunk('"></template>');
          function writePlaceholder(destination, responseState, id) {
            writeChunk(destination, placeholder1);
            writeChunk(destination, responseState.placeholderPrefix);
            var formattedID = stringToChunk(id.toString(16));
            writeChunk(destination, formattedID);
            return writeChunkAndReturn(destination, placeholder2);
          }
          var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
          var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
          var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
          var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
          var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
          var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
          var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
          var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
          var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
          var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
          var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
          function writeStartCompletedSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
          }
          function writeStartPendingSuspenseBoundary(destination, responseState, id) {
            writeChunk(destination, startPendingSuspenseBoundary1);
            if (id === null) {
              throw new Error("An ID must have been assigned before we can complete the boundary.");
            }
            writeChunk(destination, id);
            return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
          }
          function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
            var result;
            result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
            writeChunk(destination, clientRenderedSuspenseBoundaryError1);
            if (errorDigest) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            {
              if (errorMesssage) {
                writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
              }
              if (errorComponentStack) {
                writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
              }
            }
            result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
            return result;
          }
          function writeEndCompletedSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, endSuspenseBoundary);
          }
          function writeEndPendingSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, endSuspenseBoundary);
          }
          function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, endSuspenseBoundary);
          }
          var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
          var startSegmentHTML2 = stringToPrecomputedChunk('">');
          var endSegmentHTML = stringToPrecomputedChunk("</div>");
          var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
          var startSegmentSVG2 = stringToPrecomputedChunk('">');
          var endSegmentSVG = stringToPrecomputedChunk("</svg>");
          var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
          var startSegmentMathML2 = stringToPrecomputedChunk('">');
          var endSegmentMathML = stringToPrecomputedChunk("</math>");
          var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
          var startSegmentTable2 = stringToPrecomputedChunk('">');
          var endSegmentTable = stringToPrecomputedChunk("</table>");
          var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
          var startSegmentTableBody2 = stringToPrecomputedChunk('">');
          var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
          var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
          var startSegmentTableRow2 = stringToPrecomputedChunk('">');
          var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
          var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
          var startSegmentColGroup2 = stringToPrecomputedChunk('">');
          var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
          function writeStartSegment(destination, responseState, formatContext, id) {
            switch (formatContext.insertionMode) {
              case ROOT_HTML_MODE:
              case HTML_MODE: {
                writeChunk(destination, startSegmentHTML);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentHTML2);
              }
              case SVG_MODE: {
                writeChunk(destination, startSegmentSVG);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentSVG2);
              }
              case MATHML_MODE: {
                writeChunk(destination, startSegmentMathML);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentMathML2);
              }
              case HTML_TABLE_MODE: {
                writeChunk(destination, startSegmentTable);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTable2);
              }
              case HTML_TABLE_BODY_MODE: {
                writeChunk(destination, startSegmentTableBody);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTableBody2);
              }
              case HTML_TABLE_ROW_MODE: {
                writeChunk(destination, startSegmentTableRow);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTableRow2);
              }
              case HTML_COLGROUP_MODE: {
                writeChunk(destination, startSegmentColGroup);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentColGroup2);
              }
              default: {
                throw new Error("Unknown insertion mode. This is a bug in React.");
              }
            }
          }
          function writeEndSegment(destination, formatContext) {
            switch (formatContext.insertionMode) {
              case ROOT_HTML_MODE:
              case HTML_MODE: {
                return writeChunkAndReturn(destination, endSegmentHTML);
              }
              case SVG_MODE: {
                return writeChunkAndReturn(destination, endSegmentSVG);
              }
              case MATHML_MODE: {
                return writeChunkAndReturn(destination, endSegmentMathML);
              }
              case HTML_TABLE_MODE: {
                return writeChunkAndReturn(destination, endSegmentTable);
              }
              case HTML_TABLE_BODY_MODE: {
                return writeChunkAndReturn(destination, endSegmentTableBody);
              }
              case HTML_TABLE_ROW_MODE: {
                return writeChunkAndReturn(destination, endSegmentTableRow);
              }
              case HTML_COLGROUP_MODE: {
                return writeChunkAndReturn(destination, endSegmentColGroup);
              }
              default: {
                throw new Error("Unknown insertion mode. This is a bug in React.");
              }
            }
          }
          var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
          var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
          var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
          var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
          var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
          var completeSegmentScript2 = stringToPrecomputedChunk('","');
          var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
          function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
            writeChunk(destination, responseState.startInlineScript);
            if (!responseState.sentCompleteSegmentFunction) {
              responseState.sentCompleteSegmentFunction = true;
              writeChunk(destination, completeSegmentScript1Full);
            } else {
              writeChunk(destination, completeSegmentScript1Partial);
            }
            writeChunk(destination, responseState.segmentPrefix);
            var formattedID = stringToChunk(contentSegmentID.toString(16));
            writeChunk(destination, formattedID);
            writeChunk(destination, completeSegmentScript2);
            writeChunk(destination, responseState.placeholderPrefix);
            writeChunk(destination, formattedID);
            return writeChunkAndReturn(destination, completeSegmentScript3);
          }
          var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
          var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
          var completeBoundaryScript2 = stringToPrecomputedChunk('","');
          var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
          function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
            writeChunk(destination, responseState.startInlineScript);
            if (!responseState.sentCompleteBoundaryFunction) {
              responseState.sentCompleteBoundaryFunction = true;
              writeChunk(destination, completeBoundaryScript1Full);
            } else {
              writeChunk(destination, completeBoundaryScript1Partial);
            }
            if (boundaryID === null) {
              throw new Error("An ID must have been assigned before we can complete the boundary.");
            }
            var formattedContentID = stringToChunk(contentSegmentID.toString(16));
            writeChunk(destination, boundaryID);
            writeChunk(destination, completeBoundaryScript2);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, formattedContentID);
            return writeChunkAndReturn(destination, completeBoundaryScript3);
          }
          var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
          var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
          var clientRenderScript1A = stringToPrecomputedChunk('"');
          var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
          var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
          function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
            writeChunk(destination, responseState.startInlineScript);
            if (!responseState.sentClientRenderFunction) {
              responseState.sentClientRenderFunction = true;
              writeChunk(destination, clientRenderScript1Full);
            } else {
              writeChunk(destination, clientRenderScript1Partial);
            }
            if (boundaryID === null) {
              throw new Error("An ID must have been assigned before we can complete the boundary.");
            }
            writeChunk(destination, boundaryID);
            writeChunk(destination, clientRenderScript1A);
            if (errorDigest || errorMessage || errorComponentStack) {
              writeChunk(destination, clientRenderErrorScriptArgInterstitial);
              writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
            }
            if (errorMessage || errorComponentStack) {
              writeChunk(destination, clientRenderErrorScriptArgInterstitial);
              writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderErrorScriptArgInterstitial);
              writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
            }
            return writeChunkAndReturn(destination, clientRenderScript2);
          }
          var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
          function escapeJSStringsForInstructionScripts(input) {
            var escaped = JSON.stringify(input);
            return escaped.replace(regexForJSStringsInScripts, function(match) {
              switch (match) {
                case "<":
                  return "\\u003c";
                case "\u2028":
                  return "\\u2028";
                case "\u2029":
                  return "\\u2029";
                default: {
                  throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
                }
              }
            });
          }
          var assign = Object.assign;
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_SCOPE_TYPE = Symbol.for("react.scope");
          var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
          var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
          var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has4 = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has4(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          function getMaskedContext(type, unmaskedContext) {
            {
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var context = {};
              for (var key in contextTypes) {
                context[key] = unmaskedContext[key];
              }
              {
                var name = getComponentNameFromType(type) || "Unknown";
                checkPropTypes(contextTypes, context, "context", name);
              }
              return context;
            }
          }
          function processChildContext(instance, type, parentContext, childContextTypes) {
            {
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentNameFromType(type) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                }
              }
              {
                var name = getComponentNameFromType(type) || "Unknown";
                checkPropTypes(childContextTypes, childContext, "child context", name);
              }
              return assign({}, parentContext, childContext);
            }
          }
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var rootContextSnapshot = null;
          var currentActiveSnapshot = null;
          function popNode(prev) {
            {
              prev.context._currentValue = prev.parentValue;
            }
          }
          function pushNode(next) {
            {
              next.context._currentValue = next.value;
            }
          }
          function popToNearestCommonAncestor(prev, next) {
            if (prev === next)
              ;
            else {
              popNode(prev);
              var parentPrev = prev.parent;
              var parentNext = next.parent;
              if (parentPrev === null) {
                if (parentNext !== null) {
                  throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
                }
              } else {
                if (parentNext === null) {
                  throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
                }
                popToNearestCommonAncestor(parentPrev, parentNext);
              }
              pushNode(next);
            }
          }
          function popAllPrevious(prev) {
            popNode(prev);
            var parentPrev = prev.parent;
            if (parentPrev !== null) {
              popAllPrevious(parentPrev);
            }
          }
          function pushAllNext(next) {
            var parentNext = next.parent;
            if (parentNext !== null) {
              pushAllNext(parentNext);
            }
            pushNode(next);
          }
          function popPreviousToCommonLevel(prev, next) {
            popNode(prev);
            var parentPrev = prev.parent;
            if (parentPrev === null) {
              throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
            }
            if (parentPrev.depth === next.depth) {
              popToNearestCommonAncestor(parentPrev, next);
            } else {
              popPreviousToCommonLevel(parentPrev, next);
            }
          }
          function popNextToCommonLevel(prev, next) {
            var parentNext = next.parent;
            if (parentNext === null) {
              throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
            }
            if (prev.depth === parentNext.depth) {
              popToNearestCommonAncestor(prev, parentNext);
            } else {
              popNextToCommonLevel(prev, parentNext);
            }
            pushNode(next);
          }
          function switchContext(newSnapshot) {
            var prev = currentActiveSnapshot;
            var next = newSnapshot;
            if (prev !== next) {
              if (prev === null) {
                pushAllNext(next);
              } else if (next === null) {
                popAllPrevious(prev);
              } else if (prev.depth === next.depth) {
                popToNearestCommonAncestor(prev, next);
              } else if (prev.depth > next.depth) {
                popPreviousToCommonLevel(prev, next);
              } else {
                popNextToCommonLevel(prev, next);
              }
              currentActiveSnapshot = next;
            }
          }
          function pushProvider(context, nextValue) {
            var prevValue;
            {
              prevValue = context._currentValue;
              context._currentValue = nextValue;
              {
                if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                  error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer = rendererSigil;
              }
            }
            var prevNode = currentActiveSnapshot;
            var newNode = {
              parent: prevNode,
              depth: prevNode === null ? 0 : prevNode.depth + 1,
              context,
              parentValue: prevValue,
              value: nextValue
            };
            currentActiveSnapshot = newNode;
            return newNode;
          }
          function popProvider(context) {
            var prevSnapshot = currentActiveSnapshot;
            if (prevSnapshot === null) {
              throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
            }
            {
              if (prevSnapshot.context !== context) {
                error("The parent context is not the expected context. This is probably a bug in React.");
              }
            }
            {
              var value = prevSnapshot.parentValue;
              if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
              } else {
                prevSnapshot.context._currentValue = value;
              }
              {
                if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                  error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer = rendererSigil;
              }
            }
            return currentActiveSnapshot = prevSnapshot.parent;
          }
          function getActiveContext() {
            return currentActiveSnapshot;
          }
          function readContext(context) {
            var value = context._currentValue;
            return value;
          }
          function get(key) {
            return key._reactInternals;
          }
          function set2(key, value) {
            key._reactInternals = value;
          }
          var didWarnAboutNoopUpdateForComponent = {};
          var didWarnAboutDeprecatedWillMount = {};
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentNameFromType(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
          }
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnAboutNoopUpdateForComponent[warningKey]) {
                return;
              }
              error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
              didWarnAboutNoopUpdateForComponent[warningKey] = true;
            }
          }
          var classComponentUpdater = {
            isMounted: function(inst) {
              return false;
            },
            enqueueSetState: function(inst, payload, callback) {
              var internals = get(inst);
              if (internals.queue === null) {
                warnNoop(inst, "setState");
              } else {
                internals.queue.push(payload);
                {
                  if (callback !== void 0 && callback !== null) {
                    warnOnInvalidCallback(callback, "setState");
                  }
                }
              }
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var internals = get(inst);
              internals.replace = true;
              internals.queue = [payload];
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            },
            enqueueForceUpdate: function(inst, callback) {
              var internals = get(inst);
              if (internals.queue === null) {
                warnNoop(inst, "forceUpdate");
              } else {
                {
                  if (callback !== void 0 && callback !== null) {
                    warnOnInvalidCallback(callback, "setState");
                  }
                }
              }
            }
          };
          function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var newState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
            return newState;
          }
          function constructClassInstance(ctor, props, maskedLegacyContext) {
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context = readContext(contextType);
            } else {
              context = maskedLegacyContext;
            }
            var instance = new ctor(props, context);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentNameFromType(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            return instance;
          }
          function checkClassInstance(instance, ctor, newProps) {
            {
              var name = getComponentNameFromType(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
                } else {
                  error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
              }
              if (instance.propTypes) {
                error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
              }
              if (instance.contextType) {
                error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
              }
              {
                if (instance.contextTypes) {
                  error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
              }
              if (instance.defaultProps) {
                error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray(_state))) {
                error("%s.state: must be set to an object or null", name);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
              }
            }
          }
          function callComponentWillMount(type, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              {
                if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  var componentName = getComponentNameFromType(type) || "Unknown";
                  if (!didWarnAboutDeprecatedWillMount[componentName]) {
                    warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", componentName);
                    didWarnAboutDeprecatedWillMount[componentName] = true;
                  }
                }
              }
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
            if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
              var oldQueue = internalInstance.queue;
              var oldReplace = internalInstance.replace;
              internalInstance.queue = null;
              internalInstance.replace = false;
              if (oldReplace && oldQueue.length === 1) {
                inst.state = oldQueue[0];
              } else {
                var nextState = oldReplace ? oldQueue[0] : inst.state;
                var dontMutate = true;
                for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                  var partial = oldQueue[i];
                  var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                  if (partialState != null) {
                    if (dontMutate) {
                      dontMutate = false;
                      nextState = assign({}, nextState, partialState);
                    } else {
                      assign(nextState, partialState);
                    }
                  }
                }
                inst.state = nextState;
              }
            } else {
              internalInstance.queue = null;
            }
          }
          function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
            {
              checkClassInstance(instance, ctor, newProps);
            }
            var initialState = instance.state !== void 0 ? instance.state : null;
            instance.updater = classComponentUpdater;
            instance.props = newProps;
            instance.state = initialState;
            var internalInstance = {
              queue: [],
              replace: false
            };
            set2(instance, internalInstance);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              instance.context = maskedLegacyContext;
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(ctor, instance);
              processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
            }
          }
          var emptyTreeContext = {
            id: 1,
            overflow: ""
          };
          function getTreeId(context) {
            var overflow = context.overflow;
            var idWithLeadingBit = context.id;
            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id.toString(32) + overflow;
          }
          function pushTreeContext(baseContext, totalChildren, index) {
            var baseIdWithLeadingBit = baseContext.id;
            var baseOverflow = baseContext.overflow;
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index + 1;
            var length = getBitLength(totalChildren) + baseLength;
            if (length > 30) {
              var numberOfOverflowBits = baseLength - baseLength % 5;
              var newOverflowBits = (1 << numberOfOverflowBits) - 1;
              var newOverflow = (baseId & newOverflowBits).toString(32);
              var restOfBaseId = baseId >> numberOfOverflowBits;
              var restOfBaseLength = baseLength - numberOfOverflowBits;
              var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
              var restOfNewBits = slot << restOfBaseLength;
              var id = restOfNewBits | restOfBaseId;
              var overflow = newOverflow + baseOverflow;
              return {
                id: 1 << restOfLength | id,
                overflow
              };
            } else {
              var newBits = slot << baseLength;
              var _id = newBits | baseId;
              var _overflow = baseOverflow;
              return {
                id: 1 << length | _id,
                overflow: _overflow
              };
            }
          }
          function getBitLength(number2) {
            return 32 - clz32(number2);
          }
          function getLeadingBit(id) {
            return 1 << getBitLength(id) - 1;
          }
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(x) {
            var asUint = x >>> 0;
            if (asUint === 0) {
              return 32;
            }
            return 31 - (log(asUint) / LN2 | 0) | 0;
          }
          function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          var currentlyRenderingComponent = null;
          var currentlyRenderingTask = null;
          var firstWorkInProgressHook = null;
          var workInProgressHook = null;
          var isReRender = false;
          var didScheduleRenderPhaseUpdate = false;
          var localIdCounter = 0;
          var renderPhaseUpdates = null;
          var numberOfReRenders = 0;
          var RE_RENDER_LIMIT = 25;
          var isInHookUserCodeInDev = false;
          var currentHookNameInDev;
          function resolveCurrentlyRenderingComponent() {
            if (currentlyRenderingComponent === null) {
              throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
            {
              if (isInHookUserCodeInDev) {
                error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
              }
            }
            return currentlyRenderingComponent;
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            if (prevDeps === null) {
              {
                error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
              }
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
              if (objectIs(nextDeps[i], prevDeps[i])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function createHook() {
            if (numberOfReRenders > 0) {
              throw new Error("Rendered more hooks than during the previous render");
            }
            return {
              memoizedState: null,
              queue: null,
              next: null
            };
          }
          function createWorkInProgressHook() {
            if (workInProgressHook === null) {
              if (firstWorkInProgressHook === null) {
                isReRender = false;
                firstWorkInProgressHook = workInProgressHook = createHook();
              } else {
                isReRender = true;
                workInProgressHook = firstWorkInProgressHook;
              }
            } else {
              if (workInProgressHook.next === null) {
                isReRender = false;
                workInProgressHook = workInProgressHook.next = createHook();
              } else {
                isReRender = true;
                workInProgressHook = workInProgressHook.next;
              }
            }
            return workInProgressHook;
          }
          function prepareToUseHooks(task, componentIdentity) {
            currentlyRenderingComponent = componentIdentity;
            currentlyRenderingTask = task;
            {
              isInHookUserCodeInDev = false;
            }
            localIdCounter = 0;
          }
          function finishHooks(Component, props, children, refOrContext) {
            while (didScheduleRenderPhaseUpdate) {
              didScheduleRenderPhaseUpdate = false;
              localIdCounter = 0;
              numberOfReRenders += 1;
              workInProgressHook = null;
              children = Component(props, refOrContext);
            }
            resetHooksState();
            return children;
          }
          function checkDidRenderIdHook() {
            var didRenderIdHook = localIdCounter !== 0;
            return didRenderIdHook;
          }
          function resetHooksState() {
            {
              isInHookUserCodeInDev = false;
            }
            currentlyRenderingComponent = null;
            currentlyRenderingTask = null;
            didScheduleRenderPhaseUpdate = false;
            firstWorkInProgressHook = null;
            numberOfReRenders = 0;
            renderPhaseUpdates = null;
            workInProgressHook = null;
          }
          function readContext$1(context) {
            {
              if (isInHookUserCodeInDev) {
                error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            return readContext(context);
          }
          function useContext(context) {
            {
              currentHookNameInDev = "useContext";
            }
            resolveCurrentlyRenderingComponent();
            return readContext(context);
          }
          function basicStateReducer(state, action2) {
            return typeof action2 === "function" ? action2(state) : action2;
          }
          function useState3(initialState) {
            {
              currentHookNameInDev = "useState";
            }
            return useReducer(basicStateReducer, initialState);
          }
          function useReducer(reducer, initialArg, init) {
            {
              if (reducer !== basicStateReducer) {
                currentHookNameInDev = "useReducer";
              }
            }
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            if (isReRender) {
              var queue = workInProgressHook.queue;
              var dispatch = queue.dispatch;
              if (renderPhaseUpdates !== null) {
                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
                if (firstRenderPhaseUpdate !== void 0) {
                  renderPhaseUpdates.delete(queue);
                  var newState = workInProgressHook.memoizedState;
                  var update = firstRenderPhaseUpdate;
                  do {
                    var action2 = update.action;
                    {
                      isInHookUserCodeInDev = true;
                    }
                    newState = reducer(newState, action2);
                    {
                      isInHookUserCodeInDev = false;
                    }
                    update = update.next;
                  } while (update !== null);
                  workInProgressHook.memoizedState = newState;
                  return [newState, dispatch];
                }
              }
              return [workInProgressHook.memoizedState, dispatch];
            } else {
              {
                isInHookUserCodeInDev = true;
              }
              var initialState;
              if (reducer === basicStateReducer) {
                initialState = typeof initialArg === "function" ? initialArg() : initialArg;
              } else {
                initialState = init !== void 0 ? init(initialArg) : initialArg;
              }
              {
                isInHookUserCodeInDev = false;
              }
              workInProgressHook.memoizedState = initialState;
              var _queue = workInProgressHook.queue = {
                last: null,
                dispatch: null
              };
              var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
              return [workInProgressHook.memoizedState, _dispatch];
            }
          }
          function useMemo(nextCreate, deps) {
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            if (workInProgressHook !== null) {
              var prevState = workInProgressHook.memoizedState;
              if (prevState !== null) {
                if (nextDeps !== null) {
                  var prevDeps = prevState[1];
                  if (areHookInputsEqual(nextDeps, prevDeps)) {
                    return prevState[0];
                  }
                }
              }
            }
            {
              isInHookUserCodeInDev = true;
            }
            var nextValue = nextCreate();
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function useRef2(initialValue) {
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            var previousRef = workInProgressHook.memoizedState;
            if (previousRef === null) {
              var ref = {
                current: initialValue
              };
              {
                Object.seal(ref);
              }
              workInProgressHook.memoizedState = ref;
              return ref;
            } else {
              return previousRef;
            }
          }
          function useLayoutEffect(create10, inputs) {
            {
              currentHookNameInDev = "useLayoutEffect";
              error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
            }
          }
          function dispatchAction(componentIdentity, queue, action2) {
            if (numberOfReRenders >= RE_RENDER_LIMIT) {
              throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
            if (componentIdentity === currentlyRenderingComponent) {
              didScheduleRenderPhaseUpdate = true;
              var update = {
                action: action2,
                next: null
              };
              if (renderPhaseUpdates === null) {
                renderPhaseUpdates = /* @__PURE__ */ new Map();
              }
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
              if (firstRenderPhaseUpdate === void 0) {
                renderPhaseUpdates.set(queue, update);
              } else {
                var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
                while (lastRenderPhaseUpdate.next !== null) {
                  lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
                }
                lastRenderPhaseUpdate.next = update;
              }
            }
          }
          function useCallback(callback, deps) {
            return useMemo(function() {
              return callback;
            }, deps);
          }
          function useMutableSource(source, getSnapshot, subscribe) {
            resolveCurrentlyRenderingComponent();
            return getSnapshot(source._source);
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            if (getServerSnapshot === void 0) {
              throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
            }
            return getServerSnapshot();
          }
          function useDeferredValue(value) {
            resolveCurrentlyRenderingComponent();
            return value;
          }
          function unsupportedStartTransition() {
            throw new Error("startTransition cannot be called during server rendering.");
          }
          function useTransition2() {
            resolveCurrentlyRenderingComponent();
            return [false, unsupportedStartTransition];
          }
          function useId() {
            var task = currentlyRenderingTask;
            var treeId = getTreeId(task.treeContext);
            var responseState = currentResponseState;
            if (responseState === null) {
              throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
            }
            var localId = localIdCounter++;
            return makeId(responseState, treeId, localId);
          }
          function noop() {
          }
          var Dispatcher = {
            readContext: readContext$1,
            useContext,
            useMemo,
            useReducer,
            useRef: useRef2,
            useState: useState3,
            useInsertionEffect: noop,
            useLayoutEffect,
            useCallback,
            useImperativeHandle: noop,
            useEffect: noop,
            useDebugValue: noop,
            useDeferredValue,
            useTransition: useTransition2,
            useId,
            useMutableSource,
            useSyncExternalStore
          };
          var currentResponseState = null;
          function setCurrentResponseState(responseState) {
            currentResponseState = responseState;
          }
          function getStackByComponentStackNode(componentStack) {
            try {
              var info = "";
              var node = componentStack;
              do {
                switch (node.tag) {
                  case 0:
                    info += describeBuiltInComponentFrame(node.type, null, null);
                    break;
                  case 1:
                    info += describeFunctionComponentFrame(node.type, null, null);
                    break;
                  case 2:
                    info += describeClassComponentFrame(node.type, null, null);
                    break;
                }
                node = node.parent;
              } while (node);
              return info;
            } catch (x) {
              return "\nError generating stack: " + x.message + "\n" + x.stack;
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          var PENDING = 0;
          var COMPLETED = 1;
          var FLUSHED = 2;
          var ABORTED = 3;
          var ERRORED = 4;
          var OPEN = 0;
          var CLOSING = 1;
          var CLOSED = 2;
          var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
          function defaultErrorHandler(error2) {
            console["error"](error2);
            return null;
          }
          function noop$1() {
          }
          function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
            var pingedTasks = [];
            var abortSet = /* @__PURE__ */ new Set();
            var request = {
              destination: null,
              responseState,
              progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
              status: OPEN,
              fatalError: null,
              nextSegmentId: 0,
              allPendingTasks: 0,
              pendingRootTasks: 0,
              completedRootSegment: null,
              abortableTasks: abortSet,
              pingedTasks,
              clientRenderedBoundaries: [],
              completedBoundaries: [],
              partialBoundaries: [],
              onError: onError === void 0 ? defaultErrorHandler : onError,
              onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
              onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
              onShellError: onShellError === void 0 ? noop$1 : onShellError,
              onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
            };
            var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false);
            rootSegment.parentFlushed = true;
            var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
            pingedTasks.push(rootTask);
            return request;
          }
          function pingTask(request, task) {
            var pingedTasks = request.pingedTasks;
            pingedTasks.push(task);
            if (pingedTasks.length === 1) {
              scheduleWork(function() {
                return performWork(request);
              });
            }
          }
          function createSuspenseBoundary(request, fallbackAbortableTasks) {
            return {
              id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
              rootSegmentID: -1,
              parentFlushed: false,
              pendingTasks: 0,
              forceClientRender: false,
              completedSegments: [],
              byteSize: 0,
              fallbackAbortableTasks,
              errorDigest: null
            };
          }
          function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
            request.allPendingTasks++;
            if (blockedBoundary === null) {
              request.pendingRootTasks++;
            } else {
              blockedBoundary.pendingTasks++;
            }
            var task = {
              node,
              ping: function() {
                return pingTask(request, task);
              },
              blockedBoundary,
              blockedSegment,
              abortSet,
              legacyContext,
              context,
              treeContext
            };
            {
              task.componentStack = null;
            }
            abortSet.add(task);
            return task;
          }
          function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
            return {
              status: PENDING,
              id: -1,
              index,
              parentFlushed: false,
              chunks: [],
              children: [],
              formatContext,
              boundary,
              lastPushedText,
              textEmbedded
            };
          }
          var currentTaskInDEV = null;
          function getCurrentStackInDEV() {
            {
              if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
                return "";
              }
              return getStackByComponentStackNode(currentTaskInDEV.componentStack);
            }
          }
          function pushBuiltInComponentStackInDEV(task, type) {
            {
              task.componentStack = {
                tag: 0,
                parent: task.componentStack,
                type
              };
            }
          }
          function pushFunctionComponentStackInDEV(task, type) {
            {
              task.componentStack = {
                tag: 1,
                parent: task.componentStack,
                type
              };
            }
          }
          function pushClassComponentStackInDEV(task, type) {
            {
              task.componentStack = {
                tag: 2,
                parent: task.componentStack,
                type
              };
            }
          }
          function popComponentStackInDEV(task) {
            {
              if (task.componentStack === null) {
                error("Unexpectedly popped too many stack frames. This is a bug in React.");
              } else {
                task.componentStack = task.componentStack.parent;
              }
            }
          }
          var lastBoundaryErrorComponentStackDev = null;
          function captureBoundaryErrorDetailsDev(boundary, error2) {
            {
              var errorMessage;
              if (typeof error2 === "string") {
                errorMessage = error2;
              } else if (error2 && typeof error2.message === "string") {
                errorMessage = error2.message;
              } else {
                errorMessage = String(error2);
              }
              var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
              lastBoundaryErrorComponentStackDev = null;
              boundary.errorMessage = errorMessage;
              boundary.errorComponentStack = errorComponentStack;
            }
          }
          function logRecoverableError(request, error2) {
            var errorDigest = request.onError(error2);
            if (errorDigest != null && typeof errorDigest !== "string") {
              throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
            }
            return errorDigest;
          }
          function fatalError(request, error2) {
            var onShellError = request.onShellError;
            onShellError(error2);
            var onFatalError = request.onFatalError;
            onFatalError(error2);
            if (request.destination !== null) {
              request.status = CLOSED;
              closeWithError(request.destination, error2);
            } else {
              request.status = CLOSING;
              request.fatalError = error2;
            }
          }
          function renderSuspenseBoundary(request, task, props) {
            pushBuiltInComponentStackInDEV(task, "Suspense");
            var parentBoundary = task.blockedBoundary;
            var parentSegment = task.blockedSegment;
            var fallback = props.fallback;
            var content = props.children;
            var fallbackAbortSet = /* @__PURE__ */ new Set();
            var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
            var insertionIndex = parentSegment.chunks.length;
            var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);
            parentSegment.children.push(boundarySegment);
            parentSegment.lastPushedText = false;
            var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false);
            contentRootSegment.parentFlushed = true;
            task.blockedBoundary = newBoundary;
            task.blockedSegment = contentRootSegment;
            try {
              renderNode(request, task, content);
              pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
              contentRootSegment.status = COMPLETED;
              queueCompletedSegment(newBoundary, contentRootSegment);
              if (newBoundary.pendingTasks === 0) {
                popComponentStackInDEV(task);
                return;
              }
            } catch (error2) {
              contentRootSegment.status = ERRORED;
              newBoundary.forceClientRender = true;
              newBoundary.errorDigest = logRecoverableError(request, error2);
              {
                captureBoundaryErrorDetailsDev(newBoundary, error2);
              }
            } finally {
              task.blockedBoundary = parentBoundary;
              task.blockedSegment = parentSegment;
            }
            var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
            {
              suspendedFallbackTask.componentStack = task.componentStack;
            }
            request.pingedTasks.push(suspendedFallbackTask);
            popComponentStackInDEV(task);
          }
          function renderHostElement(request, task, type, props) {
            pushBuiltInComponentStackInDEV(task, type);
            var segment = task.blockedSegment;
            var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
            segment.lastPushedText = false;
            var prevContext = segment.formatContext;
            segment.formatContext = getChildFormatContext(prevContext, type, props);
            renderNode(request, task, children);
            segment.formatContext = prevContext;
            pushEndInstance(segment.chunks, type);
            segment.lastPushedText = false;
            popComponentStackInDEV(task);
          }
          function shouldConstruct$1(Component) {
            return Component.prototype && Component.prototype.isReactComponent;
          }
          function renderWithHooks(request, task, Component, props, secondArg) {
            var componentIdentity = {};
            prepareToUseHooks(task, componentIdentity);
            var result = Component(props, secondArg);
            return finishHooks(Component, props, result, secondArg);
          }
          function finishClassComponent(request, task, instance, Component, props) {
            var nextChildren = instance.render();
            {
              if (instance.props !== props) {
                if (!didWarnAboutReassigningProps) {
                  error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            {
              var childContextTypes = Component.childContextTypes;
              if (childContextTypes !== null && childContextTypes !== void 0) {
                var previousContext = task.legacyContext;
                var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
                task.legacyContext = mergedContext;
                renderNodeDestructive(request, task, nextChildren);
                task.legacyContext = previousContext;
                return;
              }
            }
            renderNodeDestructive(request, task, nextChildren);
          }
          function renderClassComponent(request, task, Component, props) {
            pushClassComponentStackInDEV(task, Component);
            var maskedContext = getMaskedContext(Component, task.legacyContext);
            var instance = constructClassInstance(Component, props, maskedContext);
            mountClassInstance(instance, Component, props, maskedContext);
            finishClassComponent(request, task, instance, Component, props);
            popComponentStackInDEV(task);
          }
          var didWarnAboutBadClass = {};
          var didWarnAboutModulePatternComponent = {};
          var didWarnAboutContextTypeOnFunctionComponent = {};
          var didWarnAboutGetDerivedStateOnFunctionComponent = {};
          var didWarnAboutReassigningProps = false;
          var didWarnAboutGenerators = false;
          var didWarnAboutMaps = false;
          var hasWarnedAboutUsingContextAsConsumer = false;
          function renderIndeterminateComponent(request, task, Component, props) {
            var legacyContext;
            {
              legacyContext = getMaskedContext(Component, task.legacyContext);
            }
            pushFunctionComponentStackInDEV(task, Component);
            {
              if (Component.prototype && typeof Component.prototype.render === "function") {
                var componentName = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
            }
            var value = renderWithHooks(request, task, Component, props, legacyContext);
            var hasId = checkDidRenderIdHook();
            {
              if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                var _componentName = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              {
                var _componentName2 = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              mountClassInstance(value, Component, props, legacyContext);
              finishClassComponent(request, task, value, Component, props);
            } else {
              {
                validateFunctionComponentInDev(Component);
              }
              if (hasId) {
                var prevTreeContext = task.treeContext;
                var totalChildren = 1;
                var index = 0;
                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
                try {
                  renderNodeDestructive(request, task, value);
                } finally {
                  task.treeContext = prevTreeContext;
                }
              } else {
                renderNodeDestructive(request, task, value);
              }
            }
            popComponentStackInDEV(task);
          }
          function validateFunctionComponentInDev(Component) {
            {
              if (Component) {
                if (Component.childContextTypes) {
                  error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
                }
              }
              if (typeof Component.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component.contextType === "object" && Component.contextType !== null) {
                var _componentName4 = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          function resolveDefaultProps(Component, baseProps) {
            if (Component && Component.defaultProps) {
              var props = assign({}, baseProps);
              var defaultProps = Component.defaultProps;
              for (var propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          function renderForwardRef(request, task, type, props, ref) {
            pushFunctionComponentStackInDEV(task, type.render);
            var children = renderWithHooks(request, task, type.render, props, ref);
            var hasId = checkDidRenderIdHook();
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
              try {
                renderNodeDestructive(request, task, children);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request, task, children);
            }
            popComponentStackInDEV(task);
          }
          function renderMemo(request, task, type, props, ref) {
            var innerType = type.type;
            var resolvedProps = resolveDefaultProps(innerType, props);
            renderElement(request, task, innerType, resolvedProps, ref);
          }
          function renderContextConsumer(request, task, context, props) {
            {
              if (context._context === void 0) {
                if (context !== context.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context = context._context;
              }
            }
            var render = props.children;
            {
              if (typeof render !== "function") {
                error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            var newValue = readContext(context);
            var newChildren = render(newValue);
            renderNodeDestructive(request, task, newChildren);
          }
          function renderContextProvider(request, task, type, props) {
            var context = type._context;
            var value = props.value;
            var children = props.children;
            var prevSnapshot;
            {
              prevSnapshot = task.context;
            }
            task.context = pushProvider(context, value);
            renderNodeDestructive(request, task, children);
            task.context = popProvider(context);
            {
              if (prevSnapshot !== task.context) {
                error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
              }
            }
          }
          function renderLazyComponent(request, task, lazyComponent, props, ref) {
            pushBuiltInComponentStackInDEV(task, "Lazy");
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;
            var Component = init(payload);
            var resolvedProps = resolveDefaultProps(Component, props);
            renderElement(request, task, Component, resolvedProps, ref);
            popComponentStackInDEV(task);
          }
          function renderElement(request, task, type, props, ref) {
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                renderClassComponent(request, task, type, props);
                return;
              } else {
                renderIndeterminateComponent(request, task, type, props);
                return;
              }
            }
            if (typeof type === "string") {
              renderHostElement(request, task, type, props);
              return;
            }
            switch (type) {
              case REACT_LEGACY_HIDDEN_TYPE:
              case REACT_DEBUG_TRACING_MODE_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_FRAGMENT_TYPE: {
                renderNodeDestructive(request, task, props.children);
                return;
              }
              case REACT_SUSPENSE_LIST_TYPE: {
                pushBuiltInComponentStackInDEV(task, "SuspenseList");
                renderNodeDestructive(request, task, props.children);
                popComponentStackInDEV(task);
                return;
              }
              case REACT_SCOPE_TYPE: {
                throw new Error("ReactDOMServer does not yet support scope components.");
              }
              case REACT_SUSPENSE_TYPE: {
                {
                  renderSuspenseBoundary(request, task, props);
                }
                return;
              }
            }
            if (typeof type === "object" && type !== null) {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE: {
                  renderForwardRef(request, task, type, props, ref);
                  return;
                }
                case REACT_MEMO_TYPE: {
                  renderMemo(request, task, type, props, ref);
                  return;
                }
                case REACT_PROVIDER_TYPE: {
                  renderContextProvider(request, task, type, props);
                  return;
                }
                case REACT_CONTEXT_TYPE: {
                  renderContextConsumer(request, task, type, props);
                  return;
                }
                case REACT_LAZY_TYPE: {
                  renderLazyComponent(request, task, type, props);
                  return;
                }
              }
            }
            var info = "";
            {
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
          }
          function validateIterable(iterable, iteratorFn) {
            {
              if (typeof Symbol === "function" && iterable[Symbol.toStringTag] === "Generator") {
                if (!didWarnAboutGenerators) {
                  error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                }
                didWarnAboutGenerators = true;
              }
              if (iterable.entries === iteratorFn) {
                if (!didWarnAboutMaps) {
                  error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
            }
          }
          function renderNodeDestructive(request, task, node) {
            {
              try {
                return renderNodeDestructiveImpl(request, task, node);
              } catch (x) {
                if (typeof x === "object" && x !== null && typeof x.then === "function")
                  ;
                else {
                  lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
                }
                throw x;
              }
            }
          }
          function renderNodeDestructiveImpl(request, task, node) {
            task.node = node;
            if (typeof node === "object" && node !== null) {
              switch (node.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var element = node;
                  var type = element.type;
                  var props = element.props;
                  var ref = element.ref;
                  renderElement(request, task, type, props, ref);
                  return;
                }
                case REACT_PORTAL_TYPE:
                  throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                case REACT_LAZY_TYPE: {
                  var lazyNode = node;
                  var payload = lazyNode._payload;
                  var init = lazyNode._init;
                  var resolvedNode;
                  {
                    try {
                      resolvedNode = init(payload);
                    } catch (x) {
                      if (typeof x === "object" && x !== null && typeof x.then === "function") {
                        pushBuiltInComponentStackInDEV(task, "Lazy");
                      }
                      throw x;
                    }
                  }
                  renderNodeDestructive(request, task, resolvedNode);
                  return;
                }
              }
              if (isArray(node)) {
                renderChildrenArray(request, task, node);
                return;
              }
              var iteratorFn = getIteratorFn(node);
              if (iteratorFn) {
                {
                  validateIterable(node, iteratorFn);
                }
                var iterator = iteratorFn.call(node);
                if (iterator) {
                  var step = iterator.next();
                  if (!step.done) {
                    var children = [];
                    do {
                      children.push(step.value);
                      step = iterator.next();
                    } while (!step.done);
                    renderChildrenArray(request, task, children);
                    return;
                  }
                  return;
                }
              }
              var childString = Object.prototype.toString.call(node);
              throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
            }
            if (typeof node === "string") {
              var segment = task.blockedSegment;
              segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
              return;
            }
            if (typeof node === "number") {
              var _segment = task.blockedSegment;
              _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
              return;
            }
            {
              if (typeof node === "function") {
                error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
              }
            }
          }
          function renderChildrenArray(request, task, children) {
            var totalChildren = children.length;
            for (var i = 0; i < totalChildren; i++) {
              var prevTreeContext = task.treeContext;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
              try {
                renderNode(request, task, children[i]);
              } finally {
                task.treeContext = prevTreeContext;
              }
            }
          }
          function spawnNewSuspendedTask(request, task, x) {
            var segment = task.blockedSegment;
            var insertionIndex = segment.chunks.length;
            var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);
            segment.children.push(newSegment);
            segment.lastPushedText = false;
            var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
            {
              if (task.componentStack !== null) {
                newTask.componentStack = task.componentStack.parent;
              }
            }
            var ping = newTask.ping;
            x.then(ping, ping);
          }
          function renderNode(request, task, node) {
            var previousFormatContext = task.blockedSegment.formatContext;
            var previousLegacyContext = task.legacyContext;
            var previousContext = task.context;
            var previousComponentStack = null;
            {
              previousComponentStack = task.componentStack;
            }
            try {
              return renderNodeDestructive(request, task, node);
            } catch (x) {
              resetHooksState();
              if (typeof x === "object" && x !== null && typeof x.then === "function") {
                spawnNewSuspendedTask(request, task, x);
                task.blockedSegment.formatContext = previousFormatContext;
                task.legacyContext = previousLegacyContext;
                task.context = previousContext;
                switchContext(previousContext);
                {
                  task.componentStack = previousComponentStack;
                }
                return;
              } else {
                task.blockedSegment.formatContext = previousFormatContext;
                task.legacyContext = previousLegacyContext;
                task.context = previousContext;
                switchContext(previousContext);
                {
                  task.componentStack = previousComponentStack;
                }
                throw x;
              }
            }
          }
          function erroredTask(request, boundary, segment, error2) {
            var errorDigest = logRecoverableError(request, error2);
            if (boundary === null) {
              fatalError(request, error2);
            } else {
              boundary.pendingTasks--;
              if (!boundary.forceClientRender) {
                boundary.forceClientRender = true;
                boundary.errorDigest = errorDigest;
                {
                  captureBoundaryErrorDetailsDev(boundary, error2);
                }
                if (boundary.parentFlushed) {
                  request.clientRenderedBoundaries.push(boundary);
                }
              }
            }
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
              var onAllReady = request.onAllReady;
              onAllReady();
            }
          }
          function abortTaskSoft(task) {
            var request = this;
            var boundary = task.blockedBoundary;
            var segment = task.blockedSegment;
            segment.status = ABORTED;
            finishedTask(request, boundary, segment);
          }
          function abortTask(task, request, reason) {
            var boundary = task.blockedBoundary;
            var segment = task.blockedSegment;
            segment.status = ABORTED;
            if (boundary === null) {
              request.allPendingTasks--;
              if (request.status !== CLOSED) {
                request.status = CLOSED;
                if (request.destination !== null) {
                  close(request.destination);
                }
              }
            } else {
              boundary.pendingTasks--;
              if (!boundary.forceClientRender) {
                boundary.forceClientRender = true;
                var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
                boundary.errorDigest = request.onError(_error);
                {
                  var errorPrefix = "The server did not finish this Suspense boundary: ";
                  if (_error && typeof _error.message === "string") {
                    _error = errorPrefix + _error.message;
                  } else {
                    _error = errorPrefix + String(_error);
                  }
                  var previousTaskInDev = currentTaskInDEV;
                  currentTaskInDEV = task;
                  try {
                    captureBoundaryErrorDetailsDev(boundary, _error);
                  } finally {
                    currentTaskInDEV = previousTaskInDev;
                  }
                }
                if (boundary.parentFlushed) {
                  request.clientRenderedBoundaries.push(boundary);
                }
              }
              boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
                return abortTask(fallbackTask, request, reason);
              });
              boundary.fallbackAbortableTasks.clear();
              request.allPendingTasks--;
              if (request.allPendingTasks === 0) {
                var onAllReady = request.onAllReady;
                onAllReady();
              }
            }
          }
          function queueCompletedSegment(boundary, segment) {
            if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
              var childSegment = segment.children[0];
              childSegment.id = segment.id;
              childSegment.parentFlushed = true;
              if (childSegment.status === COMPLETED) {
                queueCompletedSegment(boundary, childSegment);
              }
            } else {
              var completedSegments = boundary.completedSegments;
              completedSegments.push(segment);
            }
          }
          function finishedTask(request, boundary, segment) {
            if (boundary === null) {
              if (segment.parentFlushed) {
                if (request.completedRootSegment !== null) {
                  throw new Error("There can only be one root segment. This is a bug in React.");
                }
                request.completedRootSegment = segment;
              }
              request.pendingRootTasks--;
              if (request.pendingRootTasks === 0) {
                request.onShellError = noop$1;
                var onShellReady = request.onShellReady;
                onShellReady();
              }
            } else {
              boundary.pendingTasks--;
              if (boundary.forceClientRender)
                ;
              else if (boundary.pendingTasks === 0) {
                if (segment.parentFlushed) {
                  if (segment.status === COMPLETED) {
                    queueCompletedSegment(boundary, segment);
                  }
                }
                if (boundary.parentFlushed) {
                  request.completedBoundaries.push(boundary);
                }
                boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
                boundary.fallbackAbortableTasks.clear();
              } else {
                if (segment.parentFlushed) {
                  if (segment.status === COMPLETED) {
                    queueCompletedSegment(boundary, segment);
                    var completedSegments = boundary.completedSegments;
                    if (completedSegments.length === 1) {
                      if (boundary.parentFlushed) {
                        request.partialBoundaries.push(boundary);
                      }
                    }
                  }
                }
              }
            }
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
              var onAllReady = request.onAllReady;
              onAllReady();
            }
          }
          function retryTask(request, task) {
            var segment = task.blockedSegment;
            if (segment.status !== PENDING) {
              return;
            }
            switchContext(task.context);
            var prevTaskInDEV = null;
            {
              prevTaskInDEV = currentTaskInDEV;
              currentTaskInDEV = task;
            }
            try {
              renderNodeDestructive(request, task, task.node);
              pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
              task.abortSet.delete(task);
              segment.status = COMPLETED;
              finishedTask(request, task.blockedBoundary, segment);
            } catch (x) {
              resetHooksState();
              if (typeof x === "object" && x !== null && typeof x.then === "function") {
                var ping = task.ping;
                x.then(ping, ping);
              } else {
                task.abortSet.delete(task);
                segment.status = ERRORED;
                erroredTask(request, task.blockedBoundary, segment, x);
              }
            } finally {
              {
                currentTaskInDEV = prevTaskInDEV;
              }
            }
          }
          function performWork(request) {
            if (request.status === CLOSED) {
              return;
            }
            var prevContext = getActiveContext();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = Dispatcher;
            var prevGetCurrentStackImpl;
            {
              prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
              ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
            }
            var prevResponseState = currentResponseState;
            setCurrentResponseState(request.responseState);
            try {
              var pingedTasks = request.pingedTasks;
              var i;
              for (i = 0; i < pingedTasks.length; i++) {
                var task = pingedTasks[i];
                retryTask(request, task);
              }
              pingedTasks.splice(0, i);
              if (request.destination !== null) {
                flushCompletedQueues(request, request.destination);
              }
            } catch (error2) {
              logRecoverableError(request, error2);
              fatalError(request, error2);
            } finally {
              setCurrentResponseState(prevResponseState);
              ReactCurrentDispatcher$1.current = prevDispatcher;
              {
                ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
              }
              if (prevDispatcher === Dispatcher) {
                switchContext(prevContext);
              }
            }
          }
          function flushSubtree(request, destination, segment) {
            segment.parentFlushed = true;
            switch (segment.status) {
              case PENDING: {
                var segmentID = segment.id = request.nextSegmentId++;
                segment.lastPushedText = false;
                segment.textEmbedded = false;
                return writePlaceholder(destination, request.responseState, segmentID);
              }
              case COMPLETED: {
                segment.status = FLUSHED;
                var r = true;
                var chunks = segment.chunks;
                var chunkIdx = 0;
                var children = segment.children;
                for (var childIdx = 0; childIdx < children.length; childIdx++) {
                  var nextChild = children[childIdx];
                  for (; chunkIdx < nextChild.index; chunkIdx++) {
                    writeChunk(destination, chunks[chunkIdx]);
                  }
                  r = flushSegment(request, destination, nextChild);
                }
                for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                if (chunkIdx < chunks.length) {
                  r = writeChunkAndReturn(destination, chunks[chunkIdx]);
                }
                return r;
              }
              default: {
                throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
              }
            }
          }
          function flushSegment(request, destination, segment) {
            var boundary = segment.boundary;
            if (boundary === null) {
              return flushSubtree(request, destination, segment);
            }
            boundary.parentFlushed = true;
            if (boundary.forceClientRender) {
              writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
              flushSubtree(request, destination, segment);
              return writeEndClientRenderedSuspenseBoundary(destination, request.responseState);
            } else if (boundary.pendingTasks > 0) {
              boundary.rootSegmentID = request.nextSegmentId++;
              if (boundary.completedSegments.length > 0) {
                request.partialBoundaries.push(boundary);
              }
              var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
              writeStartPendingSuspenseBoundary(destination, request.responseState, id);
              flushSubtree(request, destination, segment);
              return writeEndPendingSuspenseBoundary(destination, request.responseState);
            } else if (boundary.byteSize > request.progressiveChunkSize) {
              boundary.rootSegmentID = request.nextSegmentId++;
              request.completedBoundaries.push(boundary);
              writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
              flushSubtree(request, destination, segment);
              return writeEndPendingSuspenseBoundary(destination, request.responseState);
            } else {
              writeStartCompletedSuspenseBoundary(destination, request.responseState);
              var completedSegments = boundary.completedSegments;
              if (completedSegments.length !== 1) {
                throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
              }
              var contentSegment = completedSegments[0];
              flushSegment(request, destination, contentSegment);
              return writeEndCompletedSuspenseBoundary(destination, request.responseState);
            }
          }
          function flushClientRenderedBoundary(request, destination, boundary) {
            return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
          }
          function flushSegmentContainer(request, destination, segment) {
            writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
            flushSegment(request, destination, segment);
            return writeEndSegment(destination, segment.formatContext);
          }
          function flushCompletedBoundary(request, destination, boundary) {
            var completedSegments = boundary.completedSegments;
            var i = 0;
            for (; i < completedSegments.length; i++) {
              var segment = completedSegments[i];
              flushPartiallyCompletedSegment(request, destination, boundary, segment);
            }
            completedSegments.length = 0;
            return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
          }
          function flushPartialBoundary(request, destination, boundary) {
            var completedSegments = boundary.completedSegments;
            var i = 0;
            for (; i < completedSegments.length; i++) {
              var segment = completedSegments[i];
              if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
                i++;
                completedSegments.splice(0, i);
                return false;
              }
            }
            completedSegments.splice(0, i);
            return true;
          }
          function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
            if (segment.status === FLUSHED) {
              return true;
            }
            var segmentID = segment.id;
            if (segmentID === -1) {
              var rootSegmentID = segment.id = boundary.rootSegmentID;
              if (rootSegmentID === -1) {
                throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
              }
              return flushSegmentContainer(request, destination, segment);
            } else {
              flushSegmentContainer(request, destination, segment);
              return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
            }
          }
          function flushCompletedQueues(request, destination) {
            beginWriting();
            try {
              var completedRootSegment = request.completedRootSegment;
              if (completedRootSegment !== null && request.pendingRootTasks === 0) {
                flushSegment(request, destination, completedRootSegment);
                request.completedRootSegment = null;
                writeCompletedRoot(destination, request.responseState);
              }
              var clientRenderedBoundaries = request.clientRenderedBoundaries;
              var i;
              for (i = 0; i < clientRenderedBoundaries.length; i++) {
                var boundary = clientRenderedBoundaries[i];
                if (!flushClientRenderedBoundary(request, destination, boundary)) {
                  request.destination = null;
                  i++;
                  clientRenderedBoundaries.splice(0, i);
                  return;
                }
              }
              clientRenderedBoundaries.splice(0, i);
              var completedBoundaries = request.completedBoundaries;
              for (i = 0; i < completedBoundaries.length; i++) {
                var _boundary = completedBoundaries[i];
                if (!flushCompletedBoundary(request, destination, _boundary)) {
                  request.destination = null;
                  i++;
                  completedBoundaries.splice(0, i);
                  return;
                }
              }
              completedBoundaries.splice(0, i);
              completeWriting(destination);
              beginWriting(destination);
              var partialBoundaries = request.partialBoundaries;
              for (i = 0; i < partialBoundaries.length; i++) {
                var _boundary2 = partialBoundaries[i];
                if (!flushPartialBoundary(request, destination, _boundary2)) {
                  request.destination = null;
                  i++;
                  partialBoundaries.splice(0, i);
                  return;
                }
              }
              partialBoundaries.splice(0, i);
              var largeBoundaries = request.completedBoundaries;
              for (i = 0; i < largeBoundaries.length; i++) {
                var _boundary3 = largeBoundaries[i];
                if (!flushCompletedBoundary(request, destination, _boundary3)) {
                  request.destination = null;
                  i++;
                  largeBoundaries.splice(0, i);
                  return;
                }
              }
              largeBoundaries.splice(0, i);
            } finally {
              completeWriting(destination);
              if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
                {
                  if (request.abortableTasks.size !== 0) {
                    error("There was still abortable task at the root when we closed. This is a bug in React.");
                  }
                }
                close(destination);
              }
            }
          }
          function startWork(request) {
            scheduleWork(function() {
              return performWork(request);
            });
          }
          function startFlowing(request, destination) {
            if (request.status === CLOSING) {
              request.status = CLOSED;
              closeWithError(destination, request.fatalError);
              return;
            }
            if (request.status === CLOSED) {
              return;
            }
            if (request.destination !== null) {
              return;
            }
            request.destination = destination;
            try {
              flushCompletedQueues(request, destination);
            } catch (error2) {
              logRecoverableError(request, error2);
              fatalError(request, error2);
            }
          }
          function abort(request, reason) {
            try {
              var abortableTasks = request.abortableTasks;
              abortableTasks.forEach(function(task) {
                return abortTask(task, request, reason);
              });
              abortableTasks.clear();
              if (request.destination !== null) {
                flushCompletedQueues(request, request.destination);
              }
            } catch (error2) {
              logRecoverableError(request, error2);
              fatalError(request, error2);
            }
          }
          function renderToReadableStream(children, options) {
            return new Promise(function(resolve, reject) {
              var onFatalError;
              var onAllReady;
              var allReady = new Promise(function(res, rej) {
                onAllReady = res;
                onFatalError = rej;
              });
              function onShellReady() {
                var stream = new ReadableStream({
                  type: "bytes",
                  pull: function(controller) {
                    startFlowing(request, controller);
                  },
                  cancel: function(reason) {
                    abort(request);
                  }
                }, {
                  highWaterMark: 0
                });
                stream.allReady = allReady;
                resolve(stream);
              }
              function onShellError(error2) {
                allReady.catch(function() {
                });
                reject(error2);
              }
              var request = createRequest(children, createResponseState(options ? options.identifierPrefix : void 0, options ? options.nonce : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), createRootFormatContext(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, onAllReady, onShellReady, onShellError, onFatalError);
              if (options && options.signal) {
                var signal = options.signal;
                var listener = function() {
                  abort(request, signal.reason);
                  signal.removeEventListener("abort", listener);
                };
                signal.addEventListener("abort", listener);
              }
              startWork(request);
            });
          }
          exports.renderToReadableStream = renderToReadableStream;
          exports.version = ReactVersion;
        })();
      }
    }
  });

  // node_modules/react-dom/server.browser.js
  var require_server_browser = __commonJS({
    "node_modules/react-dom/server.browser.js"(exports) {
      "use strict";
      var l;
      var s;
      if (false) {
        l = null;
        s = null;
      } else {
        l = require_react_dom_server_legacy_browser_development();
        s = require_react_dom_server_browser_development();
      }
      exports.version = l.version;
      exports.renderToString = l.renderToString;
      exports.renderToStaticMarkup = l.renderToStaticMarkup;
      exports.renderToNodeStream = l.renderToNodeStream;
      exports.renderToStaticNodeStream = l.renderToStaticNodeStream;
      exports.renderToReadableStream = s.renderToReadableStream;
    }
  });

  // node_modules/@remix-run/react/_virtual/_rollupPluginBabelHelpers.js
  var require_rollupPluginBabelHelpers = __commonJS({
    "node_modules/@remix-run/react/_virtual/_rollupPluginBabelHelpers.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function _extends6() {
        _extends6 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends6.apply(this, arguments);
      }
      exports["extends"] = _extends6;
    }
  });

  // node_modules/@remix-run/react/errorBoundaries.js
  var require_errorBoundaries = __commonJS({
    "node_modules/@remix-run/react/errorBoundaries.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var React4 = require_react();
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var React__default = /* @__PURE__ */ _interopDefaultLegacy(React4);
      var RemixErrorBoundary = class extends React__default["default"].Component {
        constructor(props) {
          super(props);
          this.state = {
            error: props.error || null,
            location: props.location
          };
        }
        static getDerivedStateFromError(error) {
          return {
            error
          };
        }
        static getDerivedStateFromProps(props, state) {
          if (state.location !== props.location) {
            return {
              error: props.error || null,
              location: props.location
            };
          }
          return {
            error: props.error || state.error,
            location: state.location
          };
        }
        render() {
          if (this.state.error) {
            return /* @__PURE__ */ React__default["default"].createElement(this.props.component, {
              error: this.state.error
            });
          } else {
            return this.props.children;
          }
        }
      };
      function RemixRootDefaultErrorBoundary({
        error
      }) {
        console.error(error);
        return /* @__PURE__ */ React__default["default"].createElement("html", {
          lang: "en"
        }, /* @__PURE__ */ React__default["default"].createElement("head", null, /* @__PURE__ */ React__default["default"].createElement("meta", {
          charSet: "utf-8"
        }), /* @__PURE__ */ React__default["default"].createElement("meta", {
          name: "viewport",
          content: "width=device-width,initial-scale=1,viewport-fit=cover"
        }), /* @__PURE__ */ React__default["default"].createElement("title", null, "Application Error!")), /* @__PURE__ */ React__default["default"].createElement("body", null, /* @__PURE__ */ React__default["default"].createElement("main", {
          style: {
            fontFamily: "system-ui, sans-serif",
            padding: "2rem"
          }
        }, /* @__PURE__ */ React__default["default"].createElement("h1", {
          style: {
            fontSize: "24px"
          }
        }, "Application Error"), /* @__PURE__ */ React__default["default"].createElement("pre", {
          style: {
            padding: "2rem",
            background: "hsla(10, 50%, 50%, 0.1)",
            color: "red",
            overflow: "auto"
          }
        }, error.stack)), /* @__PURE__ */ React__default["default"].createElement("script", {
          dangerouslySetInnerHTML: {
            __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
              );
            `
          }
        })));
      }
      var RemixCatchContext = /* @__PURE__ */ React__default["default"].createContext(void 0);
      function useCatch2() {
        return React4.useContext(RemixCatchContext);
      }
      function RemixCatchBoundary({
        catch: catchVal,
        component: Component,
        children
      }) {
        if (catchVal) {
          return /* @__PURE__ */ React__default["default"].createElement(RemixCatchContext.Provider, {
            value: catchVal
          }, /* @__PURE__ */ React__default["default"].createElement(Component, null));
        }
        return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, children);
      }
      function RemixRootDefaultCatchBoundary() {
        let caught = useCatch2();
        return /* @__PURE__ */ React__default["default"].createElement("html", {
          lang: "en"
        }, /* @__PURE__ */ React__default["default"].createElement("head", null, /* @__PURE__ */ React__default["default"].createElement("meta", {
          charSet: "utf-8"
        }), /* @__PURE__ */ React__default["default"].createElement("meta", {
          name: "viewport",
          content: "width=device-width,initial-scale=1,viewport-fit=cover"
        }), /* @__PURE__ */ React__default["default"].createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ React__default["default"].createElement("body", null, /* @__PURE__ */ React__default["default"].createElement("h1", {
          style: {
            fontFamily: "system-ui, sans-serif",
            padding: "2rem"
          }
        }, caught.status, " ", caught.statusText), /* @__PURE__ */ React__default["default"].createElement("script", {
          dangerouslySetInnerHTML: {
            __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information."
              );
            `
          }
        })));
      }
      exports.RemixCatchBoundary = RemixCatchBoundary;
      exports.RemixErrorBoundary = RemixErrorBoundary;
      exports.RemixRootDefaultCatchBoundary = RemixRootDefaultCatchBoundary;
      exports.RemixRootDefaultErrorBoundary = RemixRootDefaultErrorBoundary;
      exports.useCatch = useCatch2;
    }
  });

  // node_modules/@remix-run/react/invariant.js
  var require_invariant = __commonJS({
    "node_modules/@remix-run/react/invariant.js"(exports, module) {
      "use strict";
      function invariant(value, message) {
        if (value === false || value === null || typeof value === "undefined") {
          throw new Error(message);
        }
      }
      module.exports = invariant;
    }
  });

  // node_modules/@remix-run/react/routeModules.js
  var require_routeModules = __commonJS({
    "node_modules/@remix-run/react/routeModules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function _interopNamespace(e) {
        if (e && e.__esModule)
          return e;
        var n = /* @__PURE__ */ Object.create(null);
        if (e) {
          Object.keys(e).forEach(function(k) {
            if (k !== "default") {
              var d = Object.getOwnPropertyDescriptor(e, k);
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: function() {
                  return e[k];
                }
              });
            }
          });
        }
        n["default"] = e;
        return Object.freeze(n);
      }
      async function loadRouteModule(route, routeModulesCache) {
        if (route.id in routeModulesCache) {
          return routeModulesCache[route.id];
        }
        try {
          let routeModule = await function(t) {
            return Promise.resolve().then(function() {
              return /* @__PURE__ */ _interopNamespace(__require(t));
            });
          }(route.module);
          routeModulesCache[route.id] = routeModule;
          return routeModule;
        } catch (error) {
          window.location.reload();
          return new Promise(() => {
          });
        }
      }
      exports.loadRouteModule = loadRouteModule;
    }
  });

  // node_modules/@remix-run/react/links.js
  var require_links = __commonJS({
    "node_modules/@remix-run/react/links.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var history = require_main();
      var routeModules = require_routeModules();
      function getLinksForMatches(matches, routeModules2, manifest) {
        let descriptors = matches.map((match) => {
          var _module$links;
          let module2 = routeModules2[match.route.id];
          return ((_module$links = module2.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module2)) || [];
        }).flat(1);
        let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
        return dedupe(descriptors, preloads);
      }
      async function prefetchStyleLinks(routeModule) {
        if (!routeModule.links)
          return;
        let descriptors = routeModule.links();
        if (!descriptors)
          return;
        let styleLinks = [];
        for (let descriptor of descriptors) {
          if (!isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet") {
            styleLinks.push({
              ...descriptor,
              rel: "preload",
              as: "style"
            });
          }
        }
        let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
        await Promise.all(matchingLinks.map(prefetchStyleLink));
      }
      async function prefetchStyleLink(descriptor) {
        return new Promise((resolve) => {
          let link = document.createElement("link");
          Object.assign(link, descriptor);
          function removeLink() {
            if (document.head.contains(link)) {
              document.head.removeChild(link);
            }
          }
          link.onload = () => {
            removeLink();
            resolve();
          };
          link.onerror = () => {
            removeLink();
            resolve();
          };
          document.head.appendChild(link);
        });
      }
      function isPageLinkDescriptor(object2) {
        return object2 != null && typeof object2.page === "string";
      }
      function isHtmlLinkDescriptor(object2) {
        if (object2 == null)
          return false;
        if (object2.href == null) {
          return object2.rel === "preload" && (typeof object2.imageSrcSet === "string" || typeof object2.imagesrcset === "string") && (typeof object2.imageSizes === "string" || typeof object2.imagesizes === "string");
        }
        return typeof object2.rel === "string" && typeof object2.href === "string";
      }
      async function getStylesheetPrefetchLinks(matches, routeModules$1) {
        let links2 = await Promise.all(matches.map(async (match) => {
          let mod = await routeModules.loadRouteModule(match.route, routeModules$1);
          return mod.links ? mod.links() : [];
        }));
        return links2.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((link) => link.rel === "preload" ? {
          ...link,
          rel: "prefetch"
        } : {
          ...link,
          rel: "prefetch",
          as: "style"
        });
      }
      function getNewMatchesForLinks(page, nextMatches, currentMatches, location, mode) {
        let path = parsePathPatch(page);
        let isNew = (match, index) => {
          if (!currentMatches[index])
            return true;
          return match.route.id !== currentMatches[index].route.id;
        };
        let matchPathChanged = (match, index) => {
          var _currentMatches$index;
          return currentMatches[index].pathname !== match.pathname || ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"];
        };
        let newMatches = mode === "data" && location.search !== path.search ? nextMatches.filter((match, index) => {
          if (!match.route.hasLoader) {
            return false;
          }
          if (isNew(match, index) || matchPathChanged(match, index)) {
            return true;
          }
          if (match.route.shouldReload) {
            return match.route.shouldReload({
              params: match.params,
              prevUrl: new URL(location.pathname + location.search + location.hash, window.origin),
              url: new URL(page, window.origin)
            });
          }
          return true;
        }) : nextMatches.filter((match, index) => {
          return (mode === "assets" || match.route.hasLoader) && (isNew(match, index) || matchPathChanged(match, index));
        });
        return newMatches;
      }
      function getDataLinkHrefs(page, matches, manifest) {
        let path = parsePathPatch(page);
        return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
          let {
            pathname,
            search
          } = path;
          let searchParams = new URLSearchParams(search);
          searchParams.set("_data", match.route.id);
          return `${pathname}?${searchParams}`;
        }));
      }
      function getModuleLinkHrefs(matches, manifestPatch) {
        return dedupeHrefs(matches.map((match) => {
          let route = manifestPatch.routes[match.route.id];
          let hrefs = [route.module];
          if (route.imports) {
            hrefs = hrefs.concat(route.imports);
          }
          return hrefs;
        }).flat(1));
      }
      function getCurrentPageModulePreloadHrefs(matches, manifest) {
        return dedupeHrefs(matches.map((match) => {
          let route = manifest.routes[match.route.id];
          let hrefs = [route.module];
          if (route.imports) {
            hrefs = hrefs.concat(route.imports);
          }
          return hrefs;
        }).flat(1));
      }
      function dedupeHrefs(hrefs) {
        return [...new Set(hrefs)];
      }
      function dedupe(descriptors, preloads) {
        let set2 = /* @__PURE__ */ new Set();
        let preloadsSet = new Set(preloads);
        return descriptors.reduce((deduped, descriptor) => {
          let alreadyModulePreload = !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
          if (alreadyModulePreload) {
            return deduped;
          }
          let str = JSON.stringify(descriptor);
          if (!set2.has(str)) {
            set2.add(str);
            deduped.push(descriptor);
          }
          return deduped;
        }, []);
      }
      function parsePathPatch(href) {
        let path = history.parsePath(href);
        if (path.search === void 0)
          path.search = "";
        return path;
      }
      exports.dedupe = dedupe;
      exports.getDataLinkHrefs = getDataLinkHrefs;
      exports.getLinksForMatches = getLinksForMatches;
      exports.getModuleLinkHrefs = getModuleLinkHrefs;
      exports.getNewMatchesForLinks = getNewMatchesForLinks;
      exports.getStylesheetPrefetchLinks = getStylesheetPrefetchLinks;
      exports.isHtmlLinkDescriptor = isHtmlLinkDescriptor;
      exports.isPageLinkDescriptor = isPageLinkDescriptor;
      exports.prefetchStyleLinks = prefetchStyleLinks;
    }
  });

  // node_modules/@remix-run/react/markup.js
  var require_markup = __commonJS({
    "node_modules/@remix-run/react/markup.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function createHtml(html) {
        return {
          __html: html
        };
      }
      exports.createHtml = createHtml;
    }
  });

  // node_modules/@remix-run/react/data.js
  var require_data2 = __commonJS({
    "node_modules/@remix-run/react/data.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var invariant = require_invariant();
      function isCatchResponse(response) {
        return response instanceof Response && response.headers.get("X-Remix-Catch") != null;
      }
      function isErrorResponse(response) {
        return response instanceof Response && response.headers.get("X-Remix-Error") != null;
      }
      function isRedirectResponse(response) {
        return response instanceof Response && response.headers.get("X-Remix-Redirect") != null;
      }
      async function fetchData(url, routeId, signal, submission) {
        url.searchParams.set("_data", routeId);
        let init = submission ? getActionInit(submission, signal) : {
          credentials: "same-origin",
          signal
        };
        let response = await fetch(url.href, init);
        if (isErrorResponse(response)) {
          let data = await response.json();
          let error = new Error(data.message);
          error.stack = data.stack;
          return error;
        }
        return response;
      }
      async function extractData(response) {
        let contentType = response.headers.get("Content-Type");
        if (contentType && /\bapplication\/json\b/.test(contentType)) {
          return response.json();
        }
        return response.text();
      }
      function getActionInit(submission, signal) {
        let {
          encType,
          method,
          formData
        } = submission;
        let headers2 = void 0;
        let body = formData;
        if (encType === "application/x-www-form-urlencoded") {
          body = new URLSearchParams();
          for (let [key, value] of formData) {
            invariant(typeof value === "string", `File inputs are not supported with encType "application/x-www-form-urlencoded", please use "multipart/form-data" instead.`);
            body.append(key, value);
          }
          headers2 = {
            "Content-Type": encType
          };
        }
        return {
          method,
          body,
          signal,
          credentials: "same-origin",
          headers: headers2
        };
      }
      exports.extractData = extractData;
      exports.fetchData = fetchData;
      exports.isCatchResponse = isCatchResponse;
      exports.isErrorResponse = isErrorResponse;
      exports.isRedirectResponse = isRedirectResponse;
    }
  });

  // node_modules/@remix-run/react/routeMatching.js
  var require_routeMatching2 = __commonJS({
    "node_modules/@remix-run/react/routeMatching.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var reactRouterDom = require_main3();
      function matchClientRoutes(routes2, location) {
        let matches = reactRouterDom.matchRoutes(routes2, location);
        if (!matches)
          return null;
        return matches.map((match) => ({
          params: match.params,
          pathname: match.pathname,
          route: match.route
        }));
      }
      exports.matchClientRoutes = matchClientRoutes;
    }
  });

  // node_modules/@remix-run/react/transition.js
  var require_transition = __commonJS({
    "node_modules/@remix-run/react/transition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var history = require_main();
      var routeMatching = require_routeMatching2();
      var invariant = require_invariant();
      var CatchValue = class {
        constructor(status, statusText, data) {
          this.status = status;
          this.statusText = statusText;
          this.data = data;
        }
      };
      function isActionSubmission(submission) {
        return ["POST", "PUT", "PATCH", "DELETE"].includes(submission.method);
      }
      function isLoaderSubmission(submission) {
        return submission.method === "GET";
      }
      function isRedirectLocation(location) {
        return Boolean(location.state) && location.state.isRedirect;
      }
      function isLoaderRedirectLocation(location) {
        return isRedirectLocation(location) && location.state.type === "loader";
      }
      function isActionRedirectLocation(location) {
        return isRedirectLocation(location) && location.state.type === "action";
      }
      function isFetchActionRedirect(location) {
        return isRedirectLocation(location) && location.state.type === "fetchAction";
      }
      function isLoaderSubmissionRedirectLocation(location) {
        return isRedirectLocation(location) && location.state.type === "loaderSubmission";
      }
      var TransitionRedirect = class {
        constructor(location, setCookie) {
          this.setCookie = setCookie;
          this.location = typeof location === "string" ? location : location.pathname + location.search;
        }
      };
      var IDLE_TRANSITION = {
        state: "idle",
        submission: void 0,
        location: void 0,
        type: "idle"
      };
      var IDLE_FETCHER = {
        state: "idle",
        type: "init",
        data: void 0,
        submission: void 0
      };
      function createTransitionManager(init) {
        let {
          routes: routes2
        } = init;
        let pendingNavigationController;
        let fetchControllers = /* @__PURE__ */ new Map();
        let incrementingLoadId = 0;
        let navigationLoadId = -1;
        let fetchReloadIds = /* @__PURE__ */ new Map();
        let fetchRedirectIds = /* @__PURE__ */ new Set();
        let matches = routeMatching.matchClientRoutes(routes2, init.location);
        if (!matches) {
          matches = [{
            params: {},
            pathname: "",
            route: routes2[0]
          }];
        }
        let state = {
          location: init.location,
          loaderData: init.loaderData || {},
          actionData: init.actionData,
          catch: init.catch,
          error: init.error,
          catchBoundaryId: init.catchBoundaryId || null,
          errorBoundaryId: init.errorBoundaryId || null,
          matches,
          nextMatches: void 0,
          transition: IDLE_TRANSITION,
          fetchers: /* @__PURE__ */ new Map()
        };
        function update(updates) {
          if (updates.transition) {
            if (updates.transition === IDLE_TRANSITION) {
              pendingNavigationController = void 0;
            }
          }
          state = Object.assign({}, state, updates);
          init.onChange(state);
        }
        function getState() {
          return state;
        }
        function getFetcher(key) {
          return state.fetchers.get(key) || IDLE_FETCHER;
        }
        function setFetcher(key, fetcher) {
          state.fetchers.set(key, fetcher);
        }
        function deleteFetcher(key) {
          if (fetchControllers.has(key))
            abortFetcher(key);
          fetchReloadIds.delete(key);
          fetchRedirectIds.delete(key);
          state.fetchers.delete(key);
        }
        async function send(event) {
          switch (event.type) {
            case "navigation": {
              let {
                action: action2,
                location,
                submission
              } = event;
              let matches2 = routeMatching.matchClientRoutes(routes2, location);
              if (!matches2) {
                matches2 = [{
                  params: {},
                  pathname: "",
                  route: routes2[0]
                }];
                await handleNotFoundNavigation(location, matches2);
              } else if (!submission && isHashChangeOnly(location)) {
                await handleHashChange(location, matches2);
              } else if (action2 === history.Action.Pop) {
                await handleLoad(location, matches2);
              } else if (submission && isActionSubmission(submission)) {
                await handleActionSubmissionNavigation(location, submission, matches2);
              } else if (submission && isLoaderSubmission(submission)) {
                await handleLoaderSubmissionNavigation(location, submission, matches2);
              } else if (isActionRedirectLocation(location)) {
                await handleActionRedirect(location, matches2);
              } else if (isLoaderSubmissionRedirectLocation(location)) {
                await handleLoaderSubmissionRedirect(location, matches2);
              } else if (isLoaderRedirectLocation(location)) {
                await handleLoaderRedirect(location, matches2);
              } else if (isFetchActionRedirect(location)) {
                await handleFetchActionRedirect(location, matches2);
              } else {
                await handleLoad(location, matches2);
              }
              navigationLoadId = -1;
              break;
            }
            case "fetcher": {
              let {
                key,
                submission,
                href
              } = event;
              let matches2 = routeMatching.matchClientRoutes(routes2, href);
              invariant(matches2, "No matches found");
              if (fetchControllers.has(key))
                abortFetcher(key);
              let match = getFetcherRequestMatch(new URL(href, window.location.href), matches2);
              if (submission && isActionSubmission(submission)) {
                await handleActionFetchSubmission(key, submission, match);
              } else if (submission && isLoaderSubmission(submission)) {
                await handleLoaderFetchSubmission(href, key, submission, match);
              } else {
                await handleLoaderFetch(href, key, match);
              }
              break;
            }
            default: {
              throw new Error(`Unknown data event type: ${event.type}`);
            }
          }
        }
        function dispose() {
          abortNormalNavigation();
          for (let [, controller] of fetchControllers) {
            controller.abort();
          }
        }
        function isIndexRequestUrl(url) {
          for (let param of url.searchParams.getAll("index")) {
            if (param === "") {
              return true;
            }
          }
          return false;
        }
        function getFetcherRequestMatch(url, matches2) {
          let match = matches2.slice(-1)[0];
          if (!isIndexRequestUrl(url) && match.route.index) {
            return matches2.slice(-2)[0];
          }
          return match;
        }
        async function handleActionFetchSubmission(key, submission, match) {
          let currentFetcher = state.fetchers.get(key);
          let fetcher = {
            state: "submitting",
            type: "actionSubmission",
            submission,
            data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
          };
          setFetcher(key, fetcher);
          update({
            fetchers: new Map(state.fetchers)
          });
          let controller = new AbortController();
          fetchControllers.set(key, controller);
          let result = await callAction(submission, match, controller.signal);
          if (controller.signal.aborted) {
            return;
          }
          if (isRedirectResult(result)) {
            let locationState = {
              isRedirect: true,
              type: "fetchAction",
              setCookie: result.value.setCookie
            };
            fetchRedirectIds.add(key);
            init.onRedirect(result.value.location, locationState);
            let loadingFetcher = {
              state: "loading",
              type: "actionRedirect",
              submission,
              data: void 0
            };
            setFetcher(key, loadingFetcher);
            update({
              fetchers: new Map(state.fetchers)
            });
            return;
          }
          if (maybeBailOnError(match, key, result)) {
            return;
          }
          if (await maybeBailOnCatch(match, key, result)) {
            return;
          }
          let loadFetcher = {
            state: "loading",
            type: "actionReload",
            data: result.value,
            submission
          };
          setFetcher(key, loadFetcher);
          update({
            fetchers: new Map(state.fetchers)
          });
          let maybeActionErrorResult = isErrorResult(result) ? result : void 0;
          let maybeActionCatchResult = isCatchResult(result) ? result : void 0;
          let loadId = ++incrementingLoadId;
          fetchReloadIds.set(key, loadId);
          let matchesToLoad = state.nextMatches || state.matches;
          let results = await callLoaders(state, state.transition.location || state.location, matchesToLoad, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, match.route.id, loadFetcher);
          if (controller.signal.aborted) {
            return;
          }
          fetchReloadIds.delete(key);
          fetchControllers.delete(key);
          let redirect2 = findRedirect(results);
          if (redirect2) {
            let locationState = {
              isRedirect: true,
              type: "loader",
              setCookie: redirect2.setCookie
            };
            init.onRedirect(redirect2.location, locationState);
            return;
          }
          let [error, errorBoundaryId] = findErrorAndBoundaryId(results, state.matches, maybeActionErrorResult);
          let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, state.matches, maybeActionCatchResult) || [];
          let doneFetcher = {
            state: "idle",
            type: "done",
            data: result.value,
            submission: void 0
          };
          setFetcher(key, doneFetcher);
          let abortedKeys = abortStaleFetchLoads(loadId);
          if (abortedKeys) {
            markFetchersDone(abortedKeys);
          }
          let yeetedNavigation = yeetStaleNavigationLoad(loadId);
          if (yeetedNavigation) {
            let {
              transition
            } = state;
            invariant(transition.state === "loading", "Expected loading transition");
            update({
              location: transition.location,
              matches: state.nextMatches,
              error,
              errorBoundaryId,
              catch: catchVal,
              catchBoundaryId,
              loaderData: makeLoaderData(state, results, matchesToLoad),
              actionData: transition.type === "actionReload" ? state.actionData : void 0,
              transition: IDLE_TRANSITION,
              fetchers: new Map(state.fetchers)
            });
          } else {
            update({
              fetchers: new Map(state.fetchers),
              error,
              errorBoundaryId,
              loaderData: makeLoaderData(state, results, matchesToLoad)
            });
          }
        }
        function yeetStaleNavigationLoad(landedId) {
          let isLoadingNavigation = state.transition.state === "loading";
          if (isLoadingNavigation && navigationLoadId < landedId) {
            abortNormalNavigation();
            return true;
          }
          return false;
        }
        function markFetchersDone(keys) {
          for (let key of keys) {
            let fetcher = getFetcher(key);
            let doneFetcher = {
              state: "idle",
              type: "done",
              data: fetcher.data,
              submission: void 0
            };
            setFetcher(key, doneFetcher);
          }
        }
        function abortStaleFetchLoads(landedId) {
          let yeetedKeys = [];
          for (let [key, id] of fetchReloadIds) {
            if (id < landedId) {
              let fetcher = state.fetchers.get(key);
              invariant(fetcher, `Expected fetcher: ${key}`);
              if (fetcher.state === "loading") {
                abortFetcher(key);
                fetchReloadIds.delete(key);
                yeetedKeys.push(key);
              }
            }
          }
          return yeetedKeys.length ? yeetedKeys : false;
        }
        async function handleLoaderFetchSubmission(href, key, submission, match) {
          let currentFetcher = state.fetchers.get(key);
          let fetcher = {
            state: "submitting",
            type: "loaderSubmission",
            submission,
            data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
          };
          setFetcher(key, fetcher);
          update({
            fetchers: new Map(state.fetchers)
          });
          let controller = new AbortController();
          fetchControllers.set(key, controller);
          let result = await callLoader(match, createUrl(href), controller.signal);
          fetchControllers.delete(key);
          if (controller.signal.aborted) {
            return;
          }
          if (isRedirectResult(result)) {
            let locationState = {
              isRedirect: true,
              type: "loader",
              setCookie: result.value.setCookie
            };
            init.onRedirect(result.value.location, locationState);
            return;
          }
          if (maybeBailOnError(match, key, result)) {
            return;
          }
          if (await maybeBailOnCatch(match, key, result)) {
            return;
          }
          let doneFetcher = {
            state: "idle",
            type: "done",
            data: result.value,
            submission: void 0
          };
          setFetcher(key, doneFetcher);
          update({
            fetchers: new Map(state.fetchers)
          });
        }
        async function handleLoaderFetch(href, key, match) {
          if (typeof AbortController === "undefined") {
            throw new Error("handleLoaderFetch was called during the server render, but it shouldn't be. You are likely calling useFetcher.load() in the body of your component. Try moving it to a useEffect or a callback.");
          }
          let currentFetcher = state.fetchers.get(key);
          let fetcher = {
            state: "loading",
            type: "normalLoad",
            submission: void 0,
            data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
          };
          setFetcher(key, fetcher);
          update({
            fetchers: new Map(state.fetchers)
          });
          let controller = new AbortController();
          fetchControllers.set(key, controller);
          let result = await callLoader(match, createUrl(href), controller.signal);
          if (controller.signal.aborted)
            return;
          fetchControllers.delete(key);
          if (isRedirectResult(result)) {
            let locationState = {
              isRedirect: true,
              type: "loader",
              setCookie: result.value.setCookie
            };
            init.onRedirect(result.value.location, locationState);
            return;
          }
          if (maybeBailOnError(match, key, result)) {
            return;
          }
          if (await maybeBailOnCatch(match, key, result)) {
            return;
          }
          let doneFetcher = {
            state: "idle",
            type: "done",
            data: result.value,
            submission: void 0
          };
          setFetcher(key, doneFetcher);
          update({
            fetchers: new Map(state.fetchers)
          });
        }
        async function maybeBailOnCatch(match, key, result) {
          if (isCatchResult(result)) {
            let catchBoundaryId = findNearestCatchBoundary(match, state.matches);
            state.fetchers.delete(key);
            update({
              transition: IDLE_TRANSITION,
              fetchers: new Map(state.fetchers),
              catch: {
                data: result.value.data,
                status: result.value.status,
                statusText: result.value.statusText
              },
              catchBoundaryId
            });
            return true;
          }
          return false;
        }
        function maybeBailOnError(match, key, result) {
          if (isErrorResult(result)) {
            let errorBoundaryId = findNearestBoundary(match, state.matches);
            state.fetchers.delete(key);
            update({
              fetchers: new Map(state.fetchers),
              error: result.value,
              errorBoundaryId
            });
            return true;
          }
          return false;
        }
        async function handleNotFoundNavigation(location, matches2) {
          abortNormalNavigation();
          let transition = {
            state: "loading",
            type: "normalLoad",
            submission: void 0,
            location
          };
          update({
            transition,
            nextMatches: matches2
          });
          await Promise.resolve();
          let catchBoundaryId = findNearestCatchBoundary(matches2[0], matches2);
          update({
            location,
            matches: matches2,
            catch: {
              data: null,
              status: 404,
              statusText: "Not Found"
            },
            catchBoundaryId,
            transition: IDLE_TRANSITION
          });
        }
        async function handleActionSubmissionNavigation(location, submission, matches2) {
          abortNormalNavigation();
          let transition = {
            state: "submitting",
            type: "actionSubmission",
            submission,
            location
          };
          update({
            transition,
            nextMatches: matches2
          });
          let controller = new AbortController();
          pendingNavigationController = controller;
          let actionMatches = matches2;
          if (!isIndexRequestUrl(createUrl(submission.action)) && actionMatches[matches2.length - 1].route.index) {
            actionMatches = actionMatches.slice(0, -1);
          }
          let leafMatch = actionMatches.slice(-1)[0];
          let result = await callAction(submission, leafMatch, controller.signal);
          if (controller.signal.aborted) {
            return;
          }
          if (isRedirectResult(result)) {
            let locationState = {
              isRedirect: true,
              type: "action",
              setCookie: result.value.setCookie
            };
            init.onRedirect(result.value.location, locationState);
            return;
          }
          let catchVal, catchBoundaryId;
          if (isCatchResult(result)) {
            [catchVal, catchBoundaryId] = await findCatchAndBoundaryId([result], actionMatches, result) || [];
          }
          let loadTransition = {
            state: "loading",
            type: "actionReload",
            submission,
            location
          };
          update({
            transition: loadTransition,
            actionData: {
              [leafMatch.route.id]: result.value
            }
          });
          await loadPageData(location, matches2, submission, leafMatch.route.id, result, catchVal, catchBoundaryId);
        }
        async function handleLoaderSubmissionNavigation(location, submission, matches2) {
          abortNormalNavigation();
          let transition = {
            state: "submitting",
            type: "loaderSubmission",
            submission,
            location
          };
          update({
            transition,
            nextMatches: matches2
          });
          await loadPageData(location, matches2, submission);
        }
        async function handleHashChange(location, matches2) {
          abortNormalNavigation();
          let transition = {
            state: "loading",
            type: "normalLoad",
            submission: void 0,
            location
          };
          update({
            transition,
            nextMatches: matches2
          });
          await Promise.resolve();
          update({
            location,
            matches: matches2,
            transition: IDLE_TRANSITION
          });
        }
        async function handleLoad(location, matches2) {
          abortNormalNavigation();
          let transition = {
            state: "loading",
            type: "normalLoad",
            submission: void 0,
            location
          };
          update({
            transition,
            nextMatches: matches2
          });
          await loadPageData(location, matches2);
        }
        async function handleLoaderRedirect(location, matches2) {
          abortNormalNavigation();
          let transition = {
            state: "loading",
            type: "normalRedirect",
            submission: void 0,
            location
          };
          update({
            transition,
            nextMatches: matches2
          });
          await loadPageData(location, matches2);
        }
        async function handleLoaderSubmissionRedirect(location, matches2) {
          abortNormalNavigation();
          invariant(state.transition.type === "loaderSubmission", `Unexpected transition: ${JSON.stringify(state.transition)}`);
          let {
            submission
          } = state.transition;
          let transition = {
            state: "loading",
            type: "loaderSubmissionRedirect",
            submission,
            location
          };
          update({
            transition,
            nextMatches: matches2
          });
          await loadPageData(location, matches2, submission);
        }
        async function handleFetchActionRedirect(location, matches2) {
          abortNormalNavigation();
          let transition = {
            state: "loading",
            type: "fetchActionRedirect",
            submission: void 0,
            location
          };
          update({
            transition,
            nextMatches: matches2
          });
          await loadPageData(location, matches2);
        }
        async function handleActionRedirect(location, matches2) {
          abortNormalNavigation();
          invariant(state.transition.type === "actionSubmission" || state.transition.type === "actionReload", `Unexpected transition: ${JSON.stringify(state.transition)}`);
          let {
            submission
          } = state.transition;
          let transition = {
            state: "loading",
            type: "actionRedirect",
            submission,
            location
          };
          update({
            transition,
            nextMatches: matches2
          });
          await loadPageData(location, matches2, submission);
        }
        function isHashChangeOnly(location) {
          return createHref(state.location) === createHref(location) && state.location.hash !== location.hash;
        }
        async function loadPageData(location, matches2, submission, submissionRouteId, actionResult, catchVal, catchBoundaryId) {
          let maybeActionErrorResult = actionResult && isErrorResult(actionResult) ? actionResult : void 0;
          let maybeActionCatchResult = actionResult && isCatchResult(actionResult) ? actionResult : void 0;
          let controller = new AbortController();
          pendingNavigationController = controller;
          navigationLoadId = ++incrementingLoadId;
          let results = await callLoaders(state, location, matches2, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, submissionRouteId, void 0, catchBoundaryId);
          if (controller.signal.aborted) {
            return;
          }
          let redirect2 = findRedirect(results);
          if (redirect2) {
            if (state.transition.type === "actionReload") {
              let locationState = {
                isRedirect: true,
                type: "action",
                setCookie: redirect2.setCookie
              };
              init.onRedirect(redirect2.location, locationState);
            } else if (state.transition.type === "loaderSubmission") {
              let locationState = {
                isRedirect: true,
                type: "loaderSubmission",
                setCookie: redirect2.setCookie
              };
              init.onRedirect(redirect2.location, locationState);
            } else {
              let locationState = {
                isRedirect: true,
                type: "loader",
                setCookie: redirect2.setCookie
              };
              init.onRedirect(redirect2.location, locationState);
            }
            return;
          }
          let [error, errorBoundaryId] = findErrorAndBoundaryId(results, matches2, maybeActionErrorResult);
          [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, matches2, maybeActionErrorResult) || [catchVal, catchBoundaryId];
          markFetchRedirectsDone();
          let abortedIds = abortStaleFetchLoads(navigationLoadId);
          if (abortedIds) {
            markFetchersDone(abortedIds);
          }
          update({
            location,
            matches: matches2,
            error,
            errorBoundaryId,
            catch: catchVal,
            catchBoundaryId,
            loaderData: makeLoaderData(state, results, matches2),
            actionData: state.transition.type === "actionReload" ? state.actionData : void 0,
            transition: IDLE_TRANSITION,
            fetchers: abortedIds ? new Map(state.fetchers) : state.fetchers
          });
        }
        function abortNormalNavigation() {
          if (pendingNavigationController) {
            pendingNavigationController.abort();
          }
        }
        function abortFetcher(key) {
          let controller = fetchControllers.get(key);
          invariant(controller, `Expected fetch controller: ${key}`);
          controller.abort();
          fetchControllers.delete(key);
        }
        function markFetchRedirectsDone() {
          let doneKeys = [];
          for (let key of fetchRedirectIds) {
            let fetcher = state.fetchers.get(key);
            invariant(fetcher, `Expected fetcher: ${key}`);
            if (fetcher.type === "actionRedirect") {
              fetchRedirectIds.delete(key);
              doneKeys.push(key);
            }
          }
          markFetchersDone(doneKeys);
        }
        return {
          send,
          getState,
          getFetcher,
          deleteFetcher,
          dispose,
          get _internalFetchControllers() {
            return fetchControllers;
          }
        };
      }
      async function callLoaders(state, location, matches, signal, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher, catchBoundaryId) {
        let url = createUrl(createHref(location));
        let matchesToLoad = filterMatchesToLoad(state, location, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher, catchBoundaryId);
        return Promise.all(matchesToLoad.map((match) => callLoader(match, url, signal)));
      }
      async function callLoader(match, url, signal) {
        invariant(match.route.loader, `Expected loader for ${match.route.id}`);
        try {
          let {
            params
          } = match;
          let value = await match.route.loader({
            params,
            url,
            signal
          });
          return {
            match,
            value
          };
        } catch (error) {
          return {
            match,
            value: error
          };
        }
      }
      async function callAction(submission, match, signal) {
        try {
          let value = await match.route.action({
            url: createUrl(submission.action),
            params: match.params,
            submission,
            signal
          });
          return {
            match,
            value
          };
        } catch (error) {
          return {
            match,
            value: error
          };
        }
      }
      function filterMatchesToLoad(state, location, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher, catchBoundaryId) {
        var _location$state;
        if (catchBoundaryId || submissionRouteId && (actionCatchResult || actionErrorResult)) {
          let foundProblematicRoute = false;
          matches = matches.filter((match) => {
            if (foundProblematicRoute) {
              return false;
            }
            if (match.route.id === submissionRouteId || match.route.id === catchBoundaryId) {
              foundProblematicRoute = true;
              return false;
            }
            return true;
          });
        }
        let isNew = (match, index) => {
          if (!state.matches[index])
            return true;
          return match.route.id !== state.matches[index].route.id;
        };
        let matchPathChanged = (match, index) => {
          var _state$matches$index$;
          return state.matches[index].pathname !== match.pathname || ((_state$matches$index$ = state.matches[index].route.path) === null || _state$matches$index$ === void 0 ? void 0 : _state$matches$index$.endsWith("*")) && state.matches[index].params["*"] !== match.params["*"];
        };
        let url = createUrl(createHref(location));
        let filterByRouteProps = (match, index) => {
          if (!match.route.loader) {
            return false;
          }
          if (isNew(match, index) || matchPathChanged(match, index)) {
            return true;
          }
          if (match.route.shouldReload) {
            let prevUrl = createUrl(createHref(state.location));
            return match.route.shouldReload({
              prevUrl,
              url,
              submission,
              params: match.params
            });
          }
          return true;
        };
        let isInRootCatchBoundary = state.matches.length === 1;
        if (isInRootCatchBoundary) {
          return matches.filter((match) => !!match.route.loader);
        }
        if ((fetcher === null || fetcher === void 0 ? void 0 : fetcher.type) === "actionReload") {
          return matches.filter(filterByRouteProps);
        } else if (state.transition.type === "actionReload" || state.transition.type === "actionRedirect" || state.transition.type === "fetchActionRedirect" || createHref(url) === createHref(state.location) || url.searchParams.toString() !== state.location.search.substring(1) || (_location$state = location.state) !== null && _location$state !== void 0 && _location$state.setCookie) {
          return matches.filter(filterByRouteProps);
        }
        return matches.filter((match, index, arr) => {
          var _location$state2;
          if ((actionErrorResult || actionCatchResult) && arr.length - 1 === index) {
            return false;
          }
          return match.route.loader && (isNew(match, index) || matchPathChanged(match, index) || ((_location$state2 = location.state) === null || _location$state2 === void 0 ? void 0 : _location$state2.setCookie));
        });
      }
      function isRedirectResult(result) {
        return result.value instanceof TransitionRedirect;
      }
      function createHref(location) {
        return location.pathname + location.search;
      }
      function findRedirect(results) {
        for (let result of results) {
          if (isRedirectResult(result)) {
            return result.value;
          }
        }
        return null;
      }
      async function findCatchAndBoundaryId(results, matches, actionCatchResult) {
        let loaderCatchResult;
        for (let result of results) {
          if (isCatchResult(result)) {
            loaderCatchResult = result;
            break;
          }
        }
        let extractCatchData = async (res) => ({
          status: res.status,
          statusText: res.statusText,
          data: res.data
        });
        if (actionCatchResult && loaderCatchResult) {
          let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
          return [await extractCatchData(actionCatchResult.value), boundaryId];
        }
        if (loaderCatchResult) {
          let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
          return [await extractCatchData(loaderCatchResult.value), boundaryId];
        }
        return null;
      }
      function findErrorAndBoundaryId(results, matches, actionErrorResult) {
        let loaderErrorResult;
        for (let result of results) {
          if (isErrorResult(result)) {
            loaderErrorResult = result;
            break;
          }
        }
        if (actionErrorResult && loaderErrorResult) {
          let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
          return [actionErrorResult.value, boundaryId];
        }
        if (actionErrorResult) {
          let boundaryId = findNearestBoundary(actionErrorResult.match, matches);
          return [actionErrorResult.value, boundaryId];
        }
        if (loaderErrorResult) {
          let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
          return [loaderErrorResult.value, boundaryId];
        }
        return [void 0, void 0];
      }
      function findNearestCatchBoundary(matchWithError, matches) {
        let nearestBoundaryId = null;
        for (let match of matches) {
          if (match.route.CatchBoundary) {
            nearestBoundaryId = match.route.id;
          }
          if (match === matchWithError) {
            break;
          }
        }
        return nearestBoundaryId;
      }
      function findNearestBoundary(matchWithError, matches) {
        let nearestBoundaryId = null;
        for (let match of matches) {
          if (match.route.ErrorBoundary) {
            nearestBoundaryId = match.route.id;
          }
          if (match === matchWithError) {
            break;
          }
        }
        return nearestBoundaryId;
      }
      function makeLoaderData(state, results, matches) {
        let newData = {};
        for (let {
          match,
          value
        } of results) {
          newData[match.route.id] = value;
        }
        let loaderData = {};
        for (let {
          route
        } of matches) {
          let value = newData[route.id] !== void 0 ? newData[route.id] : state.loaderData[route.id];
          if (value !== void 0) {
            loaderData[route.id] = value;
          }
        }
        return loaderData;
      }
      function isCatchResult(result) {
        return result.value instanceof CatchValue;
      }
      function isErrorResult(result) {
        return result.value instanceof Error;
      }
      function createUrl(href) {
        return new URL(href, window.location.origin);
      }
      exports.CatchValue = CatchValue;
      exports.IDLE_FETCHER = IDLE_FETCHER;
      exports.IDLE_TRANSITION = IDLE_TRANSITION;
      exports.TransitionRedirect = TransitionRedirect;
      exports.createTransitionManager = createTransitionManager;
    }
  });

  // node_modules/@remix-run/react/routes.js
  var require_routes2 = __commonJS({
    "node_modules/@remix-run/react/routes.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var React4 = require_react();
      var routeModules = require_routeModules();
      var data = require_data2();
      var transition = require_transition();
      var links2 = require_links();
      var invariant = require_invariant();
      function _interopNamespace(e) {
        if (e && e.__esModule)
          return e;
        var n = /* @__PURE__ */ Object.create(null);
        if (e) {
          Object.keys(e).forEach(function(k) {
            if (k !== "default") {
              var d = Object.getOwnPropertyDescriptor(e, k);
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: function() {
                  return e[k];
                }
              });
            }
          });
        }
        n["default"] = e;
        return Object.freeze(n);
      }
      var React__namespace = /* @__PURE__ */ _interopNamespace(React4);
      function createClientRoute(entryRoute, routeModulesCache, Component) {
        return {
          caseSensitive: !!entryRoute.caseSensitive,
          element: /* @__PURE__ */ React__namespace.createElement(Component, {
            id: entryRoute.id
          }),
          id: entryRoute.id,
          path: entryRoute.path,
          index: entryRoute.index,
          module: entryRoute.module,
          loader: createLoader(entryRoute, routeModulesCache),
          action: createAction(entryRoute, routeModulesCache),
          shouldReload: createShouldReload(entryRoute, routeModulesCache),
          ErrorBoundary: entryRoute.hasErrorBoundary,
          CatchBoundary: entryRoute.hasCatchBoundary,
          hasLoader: entryRoute.hasLoader
        };
      }
      function createClientRoutes(routeManifest, routeModulesCache, Component, parentId) {
        return Object.keys(routeManifest).filter((key) => routeManifest[key].parentId === parentId).map((key) => {
          let route = createClientRoute(routeManifest[key], routeModulesCache, Component);
          let children = createClientRoutes(routeManifest, routeModulesCache, Component, route.id);
          if (children.length > 0)
            route.children = children;
          return route;
        });
      }
      function createShouldReload(route, routeModules2) {
        let shouldReload = (arg) => {
          let module2 = routeModules2[route.id];
          invariant(module2, `Expected route module to be loaded for ${route.id}`);
          if (module2.unstable_shouldReload) {
            return module2.unstable_shouldReload(arg);
          }
          return true;
        };
        return shouldReload;
      }
      async function loadRouteModuleWithBlockingLinks(route, routeModules$1) {
        let routeModule = await routeModules.loadRouteModule(route, routeModules$1);
        await links2.prefetchStyleLinks(routeModule);
        return routeModule;
      }
      function createLoader(route, routeModules2) {
        let loader = async ({
          url,
          signal,
          submission
        }) => {
          if (route.hasLoader) {
            let [result] = await Promise.all([data.fetchData(url, route.id, signal, submission), loadRouteModuleWithBlockingLinks(route, routeModules2)]);
            if (result instanceof Error)
              throw result;
            let redirect2 = await checkRedirect(result);
            if (redirect2)
              return redirect2;
            if (data.isCatchResponse(result)) {
              throw new transition.CatchValue(result.status, result.statusText, await data.extractData(result));
            }
            return data.extractData(result);
          } else {
            await loadRouteModuleWithBlockingLinks(route, routeModules2);
          }
        };
        return loader;
      }
      function createAction(route, routeModules2) {
        let action2 = async ({
          url,
          signal,
          submission
        }) => {
          if (!route.hasAction) {
            console.error(`Route "${route.id}" does not have an action, but you are trying to submit to it. To fix this, please add an \`action\` function to the route`);
          }
          let result = await data.fetchData(url, route.id, signal, submission);
          if (result instanceof Error) {
            throw result;
          }
          let redirect2 = await checkRedirect(result);
          if (redirect2)
            return redirect2;
          await loadRouteModuleWithBlockingLinks(route, routeModules2);
          if (data.isCatchResponse(result)) {
            throw new transition.CatchValue(result.status, result.statusText, await data.extractData(result));
          }
          return data.extractData(result);
        };
        return action2;
      }
      async function checkRedirect(response) {
        if (data.isRedirectResponse(response)) {
          let url = new URL(response.headers.get("X-Remix-Redirect"), window.location.origin);
          if (url.origin !== window.location.origin) {
            await new Promise(() => {
              window.location.replace(url.href);
            });
          } else {
            return new transition.TransitionRedirect(url.pathname + url.search + url.hash, response.headers.get("X-Remix-Revalidate") !== null);
          }
        }
        return null;
      }
      exports.createClientRoute = createClientRoute;
      exports.createClientRoutes = createClientRoutes;
    }
  });

  // node_modules/@remix-run/react/components.js
  var require_components = __commonJS({
    "node_modules/@remix-run/react/components.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers();
      var React4 = require_react();
      var reactRouterDom = require_main3();
      var errorBoundaries = require_errorBoundaries();
      var invariant = require_invariant();
      var links2 = require_links();
      var markup = require_markup();
      var routes2 = require_routes2();
      var routeMatching = require_routeMatching2();
      var transition = require_transition();
      function _interopNamespace(e) {
        if (e && e.__esModule)
          return e;
        var n = /* @__PURE__ */ Object.create(null);
        if (e) {
          Object.keys(e).forEach(function(k) {
            if (k !== "default") {
              var d = Object.getOwnPropertyDescriptor(e, k);
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: function() {
                  return e[k];
                }
              });
            }
          });
        }
        n["default"] = e;
        return Object.freeze(n);
      }
      var React__namespace = /* @__PURE__ */ _interopNamespace(React4);
      var RemixEntryContext = /* @__PURE__ */ React__namespace.createContext(void 0);
      function useRemixEntryContext() {
        let context = React__namespace.useContext(RemixEntryContext);
        invariant(context, "You must render this element inside a <Remix> element");
        return context;
      }
      function RemixEntry({
        context: entryContext,
        action: action2,
        location: historyLocation,
        navigator: _navigator,
        static: staticProp = false
      }) {
        let {
          manifest,
          routeData: documentLoaderData,
          actionData: documentActionData,
          routeModules,
          serverHandoffString,
          appState: entryComponentDidCatchEmulator
        } = entryContext;
        let clientRoutes = React__namespace.useMemo(() => routes2.createClientRoutes(manifest.routes, routeModules, RemixRoute), [manifest, routeModules]);
        let [clientState, setClientState] = React__namespace.useState(entryComponentDidCatchEmulator);
        let [transitionManager] = React__namespace.useState(() => {
          return transition.createTransitionManager({
            routes: clientRoutes,
            actionData: documentActionData,
            loaderData: documentLoaderData,
            location: historyLocation,
            catch: entryComponentDidCatchEmulator.catch,
            catchBoundaryId: entryComponentDidCatchEmulator.catchBoundaryRouteId,
            onRedirect: _navigator.replace,
            onChange: (state) => {
              setClientState({
                catch: state.catch,
                error: state.error,
                catchBoundaryRouteId: state.catchBoundaryId,
                loaderBoundaryRouteId: state.errorBoundaryId,
                renderBoundaryRouteId: null,
                trackBoundaries: false,
                trackCatchBoundaries: false
              });
            }
          });
        });
        let navigator = React__namespace.useMemo(() => {
          let push = (to, state) => {
            return transitionManager.getState().transition.state !== "idle" ? _navigator.replace(to, state) : _navigator.push(to, state);
          };
          return {
            ..._navigator,
            push
          };
        }, [_navigator, transitionManager]);
        let {
          location,
          matches,
          loaderData,
          actionData
        } = transitionManager.getState();
        React__namespace.useEffect(() => {
          let {
            location: location2
          } = transitionManager.getState();
          if (historyLocation === location2)
            return;
          transitionManager.send({
            type: "navigation",
            location: historyLocation,
            submission: consumeNextNavigationSubmission(),
            action: action2
          });
        }, [transitionManager, historyLocation, action2]);
        let ssrErrorBeforeRoutesRendered = clientState.error && clientState.renderBoundaryRouteId === null && clientState.loaderBoundaryRouteId === null ? deserializeError(clientState.error) : void 0;
        let ssrCatchBeforeRoutesRendered = clientState.catch && clientState.catchBoundaryRouteId === null ? clientState.catch : void 0;
        return /* @__PURE__ */ React__namespace.createElement(RemixEntryContext.Provider, {
          value: {
            matches,
            manifest,
            appState: clientState,
            routeModules,
            serverHandoffString,
            clientRoutes,
            routeData: loaderData,
            actionData,
            transitionManager
          }
        }, /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixErrorBoundary, {
          location,
          component: errorBoundaries.RemixRootDefaultErrorBoundary,
          error: ssrErrorBeforeRoutesRendered
        }, /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixCatchBoundary, {
          location,
          component: errorBoundaries.RemixRootDefaultCatchBoundary,
          catch: ssrCatchBeforeRoutesRendered
        }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Router, {
          navigationType: action2,
          location,
          navigator,
          static: staticProp
        }, /* @__PURE__ */ React__namespace.createElement(Routes, null)))));
      }
      function deserializeError(data) {
        let error = new Error(data.message);
        error.stack = data.stack;
        return error;
      }
      function Routes() {
        let {
          clientRoutes
        } = useRemixEntryContext();
        let element = reactRouterDom.useRoutes(clientRoutes) || clientRoutes[0].element;
        return element;
      }
      var RemixRouteContext = /* @__PURE__ */ React__namespace.createContext(void 0);
      function useRemixRouteContext() {
        let context = React__namespace.useContext(RemixRouteContext);
        invariant(context, "You must render this element in a remix route element");
        return context;
      }
      function DefaultRouteComponent({
        id
      }) {
        throw new Error(`Route "${id}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`);
      }
      function RemixRoute({
        id
      }) {
        let location = reactRouterDom.useLocation();
        let {
          routeData,
          routeModules,
          appState
        } = useRemixEntryContext();
        invariant(routeData, "Cannot initialize 'routeData'. This normally occurs when you have server code in your client modules.\nCheck this link for more details:\nhttps://remix.run/pages/gotchas#server-code-in-client-bundles");
        invariant(routeModules, "Cannot initialize 'routeModules'. This normally occurs when you have server code in your client modules.\nCheck this link for more details:\nhttps://remix.run/pages/gotchas#server-code-in-client-bundles");
        let data = routeData[id];
        let {
          default: Component,
          CatchBoundary,
          ErrorBoundary
        } = routeModules[id];
        let element = Component ? /* @__PURE__ */ React__namespace.createElement(Component, null) : /* @__PURE__ */ React__namespace.createElement(DefaultRouteComponent, {
          id
        });
        let context = {
          data,
          id
        };
        if (CatchBoundary) {
          let maybeServerCaught = appState.catch && appState.catchBoundaryRouteId === id ? appState.catch : void 0;
          if (appState.trackCatchBoundaries) {
            appState.catchBoundaryRouteId = id;
          }
          context = maybeServerCaught ? {
            id,
            get data() {
              console.error("You cannot `useLoaderData` in a catch boundary.");
              return void 0;
            }
          } : {
            id,
            data
          };
          element = /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixCatchBoundary, {
            location,
            component: CatchBoundary,
            catch: maybeServerCaught
          }, element);
        }
        if (ErrorBoundary) {
          let maybeServerRenderError = appState.error && (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id) ? deserializeError(appState.error) : void 0;
          if (appState.trackBoundaries) {
            appState.renderBoundaryRouteId = id;
          }
          context = maybeServerRenderError ? {
            id,
            get data() {
              console.error("You cannot `useLoaderData` in an error boundary.");
              return void 0;
            }
          } : {
            id,
            data
          };
          element = /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixErrorBoundary, {
            location,
            component: ErrorBoundary,
            error: maybeServerRenderError
          }, element);
        }
        return /* @__PURE__ */ React__namespace.createElement(RemixRouteContext.Provider, {
          value: context
        }, element);
      }
      function usePrefetchBehavior(prefetch, theirElementProps) {
        let [maybePrefetch, setMaybePrefetch] = React__namespace.useState(false);
        let [shouldPrefetch, setShouldPrefetch] = React__namespace.useState(false);
        let {
          onFocus,
          onBlur,
          onMouseEnter,
          onMouseLeave,
          onTouchStart
        } = theirElementProps;
        React__namespace.useEffect(() => {
          if (prefetch === "render") {
            setShouldPrefetch(true);
          }
        }, [prefetch]);
        let setIntent = () => {
          if (prefetch === "intent") {
            setMaybePrefetch(true);
          }
        };
        let cancelIntent = () => {
          if (prefetch === "intent") {
            setMaybePrefetch(false);
            setShouldPrefetch(false);
          }
        };
        React__namespace.useEffect(() => {
          if (maybePrefetch) {
            let id = setTimeout(() => {
              setShouldPrefetch(true);
            }, 100);
            return () => {
              clearTimeout(id);
            };
          }
        }, [maybePrefetch]);
        return [shouldPrefetch, {
          onFocus: composeEventHandlers(onFocus, setIntent),
          onBlur: composeEventHandlers(onBlur, cancelIntent),
          onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
          onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
          onTouchStart: composeEventHandlers(onTouchStart, setIntent)
        }];
      }
      var NavLink2 = /* @__PURE__ */ React__namespace.forwardRef(({
        to,
        prefetch = "none",
        ...props
      }, forwardedRef) => {
        let href = reactRouterDom.useHref(to);
        let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.NavLink, _rollupPluginBabelHelpers["extends"]({
          ref: forwardedRef,
          to
        }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks2, {
          page: href
        }) : null);
      });
      NavLink2.displayName = "NavLink";
      var Link2 = /* @__PURE__ */ React__namespace.forwardRef(({
        to,
        prefetch = "none",
        ...props
      }, forwardedRef) => {
        let href = reactRouterDom.useHref(to);
        let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Link, _rollupPluginBabelHelpers["extends"]({
          ref: forwardedRef,
          to
        }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks2, {
          page: href
        }) : null);
      });
      Link2.displayName = "Link";
      function composeEventHandlers(theirHandler, ourHandler) {
        return (event) => {
          theirHandler && theirHandler(event);
          if (!event.defaultPrevented) {
            ourHandler(event);
          }
        };
      }
      function Links2() {
        let {
          matches,
          routeModules,
          manifest
        } = useRemixEntryContext();
        let links$1 = React__namespace.useMemo(() => links2.getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, links$1.map((link) => {
          if (links2.isPageLinkDescriptor(link)) {
            return /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks2, _rollupPluginBabelHelpers["extends"]({
              key: link.page
            }, link));
          }
          let imageSrcSet = null;
          if ("useId" in React__namespace) {
            if (link.imagesrcset) {
              link.imageSrcSet = imageSrcSet = link.imagesrcset;
              delete link.imagesrcset;
            }
            if (link.imagesizes) {
              link.imageSizes = link.imagesizes;
              delete link.imagesizes;
            }
          } else {
            if (link.imageSrcSet) {
              link.imagesrcset = imageSrcSet = link.imageSrcSet;
              delete link.imageSrcSet;
            }
            if (link.imageSizes) {
              link.imagesizes = link.imageSizes;
              delete link.imageSizes;
            }
          }
          return /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers["extends"]({
            key: link.rel + (link.href || "") + (imageSrcSet || "")
          }, link));
        }));
      }
      function PrefetchPageLinks2({
        page,
        ...dataLinkProps
      }) {
        let {
          clientRoutes
        } = useRemixEntryContext();
        let matches = React__namespace.useMemo(() => routeMatching.matchClientRoutes(clientRoutes, page), [clientRoutes, page]);
        if (!matches) {
          console.warn(`Tried to prefetch ${page} but no routes matched.`);
          return null;
        }
        return /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinksImpl, _rollupPluginBabelHelpers["extends"]({
          page,
          matches
        }, dataLinkProps));
      }
      function usePrefetchedStylesheets(matches) {
        let {
          routeModules
        } = useRemixEntryContext();
        let [styleLinks, setStyleLinks] = React__namespace.useState([]);
        React__namespace.useEffect(() => {
          let interrupted = false;
          links2.getStylesheetPrefetchLinks(matches, routeModules).then((links3) => {
            if (!interrupted)
              setStyleLinks(links3);
          });
          return () => {
            interrupted = true;
          };
        }, [matches, routeModules]);
        return styleLinks;
      }
      function PrefetchPageLinksImpl({
        page,
        matches: nextMatches,
        ...linkProps
      }) {
        let location = reactRouterDom.useLocation();
        let {
          matches,
          manifest
        } = useRemixEntryContext();
        let newMatchesForData = React__namespace.useMemo(() => links2.getNewMatchesForLinks(page, nextMatches, matches, location, "data"), [page, nextMatches, matches, location]);
        let newMatchesForAssets = React__namespace.useMemo(() => links2.getNewMatchesForLinks(page, nextMatches, matches, location, "assets"), [page, nextMatches, matches, location]);
        let dataHrefs = React__namespace.useMemo(() => links2.getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]);
        let moduleHrefs = React__namespace.useMemo(() => links2.getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);
        let styleLinks = usePrefetchedStylesheets(newMatchesForAssets);
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers["extends"]({
          key: href,
          rel: "prefetch",
          as: "fetch",
          href
        }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers["extends"]({
          key: href,
          rel: "modulepreload",
          href
        }, linkProps))), styleLinks.map((link) => /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers["extends"]({
          key: link.href
        }, link))));
      }
      function Meta2() {
        let {
          matches,
          routeData,
          routeModules
        } = useRemixEntryContext();
        let location = reactRouterDom.useLocation();
        let meta2 = {};
        let parentsData = {};
        for (let match of matches) {
          let routeId = match.route.id;
          let data = routeData[routeId];
          let params = match.params;
          let routeModule = routeModules[routeId];
          if (routeModule.meta) {
            let routeMeta = typeof routeModule.meta === "function" ? routeModule.meta({
              data,
              parentsData,
              params,
              location
            }) : routeModule.meta;
            Object.assign(meta2, routeMeta);
          }
          parentsData[routeId] = data;
        }
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, Object.entries(meta2).map(([name, value]) => {
          if (!value) {
            return null;
          }
          if (["charset", "charSet"].includes(name)) {
            return /* @__PURE__ */ React__namespace.createElement("meta", {
              key: "charset",
              charSet: value
            });
          }
          if (name === "title") {
            return /* @__PURE__ */ React__namespace.createElement("title", {
              key: "title"
            }, value);
          }
          let isOpenGraphTag = name.startsWith("og:");
          return [value].flat().map((content) => {
            if (isOpenGraphTag) {
              return /* @__PURE__ */ React__namespace.createElement("meta", {
                content,
                key: name + content,
                property: name
              });
            }
            if (typeof content === "string") {
              return /* @__PURE__ */ React__namespace.createElement("meta", {
                content,
                name,
                key: name + content
              });
            }
            return /* @__PURE__ */ React__namespace.createElement("meta", _rollupPluginBabelHelpers["extends"]({
              key: name + JSON.stringify(content)
            }, content));
          });
        }));
      }
      var isHydrated = false;
      function Scripts2(props) {
        let {
          manifest,
          matches,
          pendingLocation,
          clientRoutes,
          serverHandoffString
        } = useRemixEntryContext();
        React__namespace.useEffect(() => {
          isHydrated = true;
        }, []);
        let initialScripts = React__namespace.useMemo(() => {
          let contextScript = serverHandoffString ? `window.__remixContext = ${serverHandoffString};` : "";
          let routeModulesScript = `${matches.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join("\n")}
window.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};`;
          return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers["extends"]({}, props, {
            suppressHydrationWarning: true,
            dangerouslySetInnerHTML: markup.createHtml(contextScript)
          })), /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers["extends"]({}, props, {
            src: manifest.url
          })), /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers["extends"]({}, props, {
            dangerouslySetInnerHTML: markup.createHtml(routeModulesScript),
            type: "module"
          })), /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers["extends"]({}, props, {
            src: manifest.entry.module,
            type: "module"
          })));
        }, []);
        let nextMatches = React__namespace.useMemo(() => {
          if (pendingLocation) {
            let matches2 = routeMatching.matchClientRoutes(clientRoutes, pendingLocation);
            invariant(matches2, `No routes match path "${pendingLocation.pathname}"`);
            return matches2;
          }
          return [];
        }, [pendingLocation, clientRoutes]);
        let routePreloads = matches.concat(nextMatches).map((match) => {
          let route = manifest.routes[match.route.id];
          return (route.imports || []).concat([route.module]);
        }).flat(1);
        let preloads = manifest.entry.imports.concat(routePreloads);
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, dedupe(preloads).map((path) => /* @__PURE__ */ React__namespace.createElement("link", {
          key: path,
          rel: "modulepreload",
          href: path,
          crossOrigin: props.crossOrigin
        })), isHydrated ? null : initialScripts);
      }
      function dedupe(array2) {
        return [...new Set(array2)];
      }
      var Form2 = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
        return /* @__PURE__ */ React__namespace.createElement(FormImpl, _rollupPluginBabelHelpers["extends"]({}, props, {
          ref
        }));
      });
      Form2.displayName = "Form";
      var FormImpl = /* @__PURE__ */ React__namespace.forwardRef(({
        reloadDocument = false,
        replace = false,
        method = "get",
        action: action2 = ".",
        encType = "application/x-www-form-urlencoded",
        fetchKey,
        onSubmit,
        ...props
      }, forwardedRef) => {
        let submit = useSubmitImpl(fetchKey);
        let formMethod = method.toLowerCase() === "get" ? "get" : "post";
        let formAction = useFormAction2(action2);
        return /* @__PURE__ */ React__namespace.createElement("form", _rollupPluginBabelHelpers["extends"]({
          ref: forwardedRef,
          method: formMethod,
          action: formAction,
          encType,
          onSubmit: reloadDocument ? void 0 : (event) => {
            onSubmit && onSubmit(event);
            if (event.defaultPrevented)
              return;
            event.preventDefault();
            let submitter = event.nativeEvent.submitter;
            submit(submitter || event.currentTarget, {
              method,
              replace
            });
          }
        }, props));
      });
      FormImpl.displayName = "FormImpl";
      function useFormAction2(action2 = ".", method = "get") {
        let {
          id
        } = useRemixRouteContext();
        let path = reactRouterDom.useResolvedPath(action2);
        let search = path.search;
        let isIndexRoute = id.endsWith("/index");
        if (action2 === "." && isIndexRoute) {
          search = search ? search.replace(/^\?/, "?index&") : "?index";
        }
        return path.pathname + search;
      }
      function useSubmit2() {
        return useSubmitImpl();
      }
      var defaultMethod = "get";
      var defaultEncType = "application/x-www-form-urlencoded";
      function useSubmitImpl(key) {
        let navigate = reactRouterDom.useNavigate();
        let defaultAction = useFormAction2();
        let {
          transitionManager
        } = useRemixEntryContext();
        return React__namespace.useCallback((target, options = {}) => {
          let method;
          let action2;
          let encType;
          let formData;
          if (isFormElement(target)) {
            let submissionTrigger = options.submissionTrigger;
            method = options.method || target.getAttribute("method") || defaultMethod;
            action2 = options.action || target.getAttribute("action") || defaultAction;
            encType = options.encType || target.getAttribute("enctype") || defaultEncType;
            formData = new FormData(target);
            if (submissionTrigger && submissionTrigger.name) {
              formData.append(submissionTrigger.name, submissionTrigger.value);
            }
          } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
            let form = target.form;
            if (form == null) {
              throw new Error(`Cannot submit a <button> without a <form>`);
            }
            method = options.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
            action2 = options.action || target.getAttribute("formaction") || form.getAttribute("action") || defaultAction;
            encType = options.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType;
            formData = new FormData(form);
            if (target.name) {
              formData.set(target.name, target.value);
            }
          } else {
            if (isHtmlElement(target)) {
              throw new Error(`Cannot submit element that is not <form>, <button>, or <input type="submit|image">`);
            }
            method = options.method || "get";
            action2 = options.action || defaultAction;
            encType = options.encType || "application/x-www-form-urlencoded";
            if (target instanceof FormData) {
              formData = target;
            } else {
              formData = new FormData();
              if (target instanceof URLSearchParams) {
                for (let [name, value] of target) {
                  formData.append(name, value);
                }
              } else if (target != null) {
                for (let name of Object.keys(target)) {
                  formData.append(name, target[name]);
                }
              }
            }
          }
          if (typeof document === "undefined") {
            throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
          }
          let {
            protocol,
            host
          } = window.location;
          let url = new URL(action2, `${protocol}//${host}`);
          if (method.toLowerCase() === "get") {
            for (let [name, value] of formData) {
              if (typeof value === "string") {
                url.searchParams.append(name, value);
              } else {
                throw new Error(`Cannot submit binary form data using GET`);
              }
            }
          }
          let submission = {
            formData,
            action: url.pathname + url.search,
            method: method.toUpperCase(),
            encType,
            key: Math.random().toString(36).substr(2, 8)
          };
          if (key) {
            transitionManager.send({
              type: "fetcher",
              href: submission.action,
              submission,
              key
            });
          } else {
            setNextNavigationSubmission(submission);
            navigate(url.pathname + url.search, {
              replace: options.replace
            });
          }
        }, [defaultAction, key, navigate, transitionManager]);
      }
      var nextNavigationSubmission;
      function setNextNavigationSubmission(submission) {
        nextNavigationSubmission = submission;
      }
      function consumeNextNavigationSubmission() {
        let submission = nextNavigationSubmission;
        nextNavigationSubmission = void 0;
        return submission;
      }
      function isHtmlElement(object2) {
        return object2 != null && typeof object2.tagName === "string";
      }
      function isButtonElement(object2) {
        return isHtmlElement(object2) && object2.tagName.toLowerCase() === "button";
      }
      function isFormElement(object2) {
        return isHtmlElement(object2) && object2.tagName.toLowerCase() === "form";
      }
      function isInputElement(object2) {
        return isHtmlElement(object2) && object2.tagName.toLowerCase() === "input";
      }
      function useBeforeUnload2(callback) {
        React__namespace.useEffect(() => {
          window.addEventListener("beforeunload", callback);
          return () => {
            window.removeEventListener("beforeunload", callback);
          };
        }, [callback]);
      }
      function useMatches2() {
        let {
          matches,
          routeData,
          routeModules
        } = useRemixEntryContext();
        return React__namespace.useMemo(() => matches.map((match) => {
          var _routeModules$match$r;
          let {
            pathname,
            params
          } = match;
          return {
            id: match.route.id,
            pathname,
            params,
            data: routeData[match.route.id],
            handle: (_routeModules$match$r = routeModules[match.route.id]) === null || _routeModules$match$r === void 0 ? void 0 : _routeModules$match$r.handle
          };
        }), [matches, routeData, routeModules]);
      }
      function useLoaderData2() {
        return useRemixRouteContext().data;
      }
      function useActionData2() {
        let {
          id: routeId
        } = useRemixRouteContext();
        let {
          transitionManager
        } = useRemixEntryContext();
        let {
          actionData
        } = transitionManager.getState();
        return actionData ? actionData[routeId] : void 0;
      }
      function useTransition2() {
        let {
          transitionManager
        } = useRemixEntryContext();
        return transitionManager.getState().transition;
      }
      function createFetcherForm(fetchKey) {
        let FetcherForm = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
          return /* @__PURE__ */ React__namespace.createElement(FormImpl, _rollupPluginBabelHelpers["extends"]({}, props, {
            ref,
            fetchKey
          }));
        });
        FetcherForm.displayName = "fetcher.Form";
        return FetcherForm;
      }
      var fetcherId = 0;
      function useFetcher2() {
        let {
          transitionManager
        } = useRemixEntryContext();
        let [key] = React__namespace.useState(() => String(++fetcherId));
        let [Form3] = React__namespace.useState(() => createFetcherForm(key));
        let [load] = React__namespace.useState(() => (href) => {
          transitionManager.send({
            type: "fetcher",
            href,
            key
          });
        });
        let submit = useSubmitImpl(key);
        let fetcher = transitionManager.getFetcher(key);
        let fetcherWithComponents = React__namespace.useMemo(() => ({
          Form: Form3,
          submit,
          load,
          ...fetcher
        }), [fetcher, Form3, submit, load]);
        React__namespace.useEffect(() => {
          return () => transitionManager.deleteFetcher(key);
        }, [transitionManager, key]);
        return fetcherWithComponents;
      }
      function useFetchers2() {
        let {
          transitionManager
        } = useRemixEntryContext();
        let {
          fetchers
        } = transitionManager.getState();
        return [...fetchers.values()];
      }
      var LiveReload2 = false ? () => null : function LiveReload3({
        port = Number(process.env.REMIX_DEV_SERVER_WS_PORT || 8002),
        nonce = void 0
      }) {
        let js = String.raw;
        return /* @__PURE__ */ React__namespace.createElement("script", {
          nonce,
          suppressHydrationWarning: true,
          dangerouslySetInnerHTML: {
            __html: js`
                (() => {
                  let protocol = location.protocol === "https:" ? "wss:" : "ws:";
                  let host = location.hostname;
                  let socketPath = protocol + "//" + host + ":" + ${String(port)} + "/socket";

                  let ws = new WebSocket(socketPath);
                  ws.onmessage = (message) => {
                    let event = JSON.parse(message.data);
                    if (event.type === "LOG") {
                      console.log(event.message);
                    }
                    if (event.type === "RELOAD") {
                      console.log("💿 Reloading window ...");
                      window.location.reload();
                    }
                  };
                  ws.onerror = (error) => {
                    console.log("Remix dev asset server web socket error:");
                    console.error(error);
                  };
                })();
              `
          }
        });
      };
      exports.Form = Form2;
      exports.FormImpl = FormImpl;
      exports.Link = Link2;
      exports.Links = Links2;
      exports.LiveReload = LiveReload2;
      exports.Meta = Meta2;
      exports.NavLink = NavLink2;
      exports.PrefetchPageLinks = PrefetchPageLinks2;
      exports.RemixEntry = RemixEntry;
      exports.RemixEntryContext = RemixEntryContext;
      exports.RemixRoute = RemixRoute;
      exports.Scripts = Scripts2;
      exports.composeEventHandlers = composeEventHandlers;
      exports.useActionData = useActionData2;
      exports.useBeforeUnload = useBeforeUnload2;
      exports.useFetcher = useFetcher2;
      exports.useFetchers = useFetchers2;
      exports.useFormAction = useFormAction2;
      exports.useLoaderData = useLoaderData2;
      exports.useMatches = useMatches2;
      exports.useSubmit = useSubmit2;
      exports.useSubmitImpl = useSubmitImpl;
      exports.useTransition = useTransition2;
    }
  });

  // node_modules/@remix-run/react/browser.js
  var require_browser = __commonJS({
    "node_modules/@remix-run/react/browser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var history = require_main();
      var React4 = require_react();
      var components = require_components();
      function _interopNamespace(e) {
        if (e && e.__esModule)
          return e;
        var n = /* @__PURE__ */ Object.create(null);
        if (e) {
          Object.keys(e).forEach(function(k) {
            if (k !== "default") {
              var d = Object.getOwnPropertyDescriptor(e, k);
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: function() {
                  return e[k];
                }
              });
            }
          });
        }
        n["default"] = e;
        return Object.freeze(n);
      }
      var React__namespace = /* @__PURE__ */ _interopNamespace(React4);
      function RemixBrowser2(_props) {
        let historyRef = React__namespace.useRef();
        if (historyRef.current == null) {
          historyRef.current = history.createBrowserHistory({
            window
          });
        }
        let history$1 = historyRef.current;
        let [state, dispatch] = React__namespace.useReducer((_, update) => update, {
          action: history$1.action,
          location: history$1.location
        });
        React__namespace.useLayoutEffect(() => history$1.listen(dispatch), [history$1]);
        let entryContext = window.__remixContext;
        entryContext.manifest = window.__remixManifest;
        entryContext.routeModules = window.__remixRouteModules;
        entryContext.appState.trackBoundaries = false;
        entryContext.appState.trackCatchBoundaries = false;
        return /* @__PURE__ */ React__namespace.createElement(components.RemixEntry, {
          context: entryContext,
          action: state.action,
          location: state.location,
          navigator: history$1
        });
      }
      exports.RemixBrowser = RemixBrowser2;
    }
  });

  // node_modules/@remix-run/react/scroll-restoration.js
  var require_scroll_restoration = __commonJS({
    "node_modules/@remix-run/react/scroll-restoration.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var React4 = require_react();
      var reactRouterDom = require_main3();
      var components = require_components();
      function _interopNamespace(e) {
        if (e && e.__esModule)
          return e;
        var n = /* @__PURE__ */ Object.create(null);
        if (e) {
          Object.keys(e).forEach(function(k) {
            if (k !== "default") {
              var d = Object.getOwnPropertyDescriptor(e, k);
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: function() {
                  return e[k];
                }
              });
            }
          });
        }
        n["default"] = e;
        return Object.freeze(n);
      }
      var React__namespace = /* @__PURE__ */ _interopNamespace(React4);
      var STORAGE_KEY = "positions";
      var positions = {};
      if (typeof document !== "undefined") {
        let sessionPositions = sessionStorage.getItem(STORAGE_KEY);
        if (sessionPositions) {
          positions = JSON.parse(sessionPositions);
        }
      }
      function ScrollRestoration2({
        nonce = void 0
      }) {
        useScrollRestoration();
        React__namespace.useEffect(() => {
          window.history.scrollRestoration = "manual";
        }, []);
        components.useBeforeUnload(React__namespace.useCallback(() => {
          window.history.scrollRestoration = "auto";
        }, []));
        let restoreScroll = ((STORAGE_KEY2) => {
          if (!window.history.state || !window.history.state.key) {
            let key = Math.random().toString(32).slice(2);
            window.history.replaceState({
              key
            }, "");
          }
          try {
            let positions2 = JSON.parse(sessionStorage.getItem(STORAGE_KEY2) || "{}");
            let storedY = positions2[window.history.state.key];
            if (typeof storedY === "number") {
              window.scrollTo(0, storedY);
            }
          } catch (error) {
            console.error(error);
            sessionStorage.removeItem(STORAGE_KEY2);
          }
        }).toString();
        return /* @__PURE__ */ React__namespace.createElement("script", {
          nonce,
          suppressHydrationWarning: true,
          dangerouslySetInnerHTML: {
            __html: `(${restoreScroll})(${JSON.stringify(STORAGE_KEY)})`
          }
        });
      }
      var hydrated = false;
      function useScrollRestoration() {
        let location = reactRouterDom.useLocation();
        let transition = components.useTransition();
        let wasSubmissionRef = React__namespace.useRef(false);
        React__namespace.useEffect(() => {
          if (transition.submission) {
            wasSubmissionRef.current = true;
          }
        }, [transition]);
        React__namespace.useEffect(() => {
          if (transition.location) {
            positions[location.key] = window.scrollY;
          }
        }, [transition, location]);
        components.useBeforeUnload(React__namespace.useCallback(() => {
          sessionStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        }, []));
        if (typeof document !== "undefined") {
          React__namespace.useLayoutEffect(() => {
            if (!hydrated) {
              hydrated = true;
              return;
            }
            let y = positions[location.key];
            if (y != void 0) {
              window.scrollTo(0, y);
              return;
            }
            if (location.hash) {
              let el = document.getElementById(location.hash.slice(1));
              if (el) {
                el.scrollIntoView();
                return;
              }
            }
            if (wasSubmissionRef.current === true) {
              wasSubmissionRef.current = false;
              return;
            }
            window.scrollTo(0, 0);
          }, [location]);
        }
        React__namespace.useEffect(() => {
          if (transition.submission) {
            wasSubmissionRef.current = true;
          }
        }, [transition]);
      }
      exports.ScrollRestoration = ScrollRestoration2;
    }
  });

  // node_modules/@remix-run/react/server.js
  var require_server2 = __commonJS({
    "node_modules/@remix-run/react/server.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var history = require_main();
      var React4 = require_react();
      var components = require_components();
      function _interopNamespace(e) {
        if (e && e.__esModule)
          return e;
        var n = /* @__PURE__ */ Object.create(null);
        if (e) {
          Object.keys(e).forEach(function(k) {
            if (k !== "default") {
              var d = Object.getOwnPropertyDescriptor(e, k);
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: function() {
                  return e[k];
                }
              });
            }
          });
        }
        n["default"] = e;
        return Object.freeze(n);
      }
      var React__namespace = /* @__PURE__ */ _interopNamespace(React4);
      function RemixServer2({
        context,
        url
      }) {
        if (typeof url === "string") {
          url = new URL(url);
        }
        let location = {
          pathname: url.pathname,
          search: url.search,
          hash: "",
          state: null,
          key: "default"
        };
        let staticNavigator = {
          createHref(to) {
            return typeof to === "string" ? to : history.createPath(to);
          },
          push(to) {
            throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
          },
          replace(to) {
            throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
          },
          go(delta) {
            throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
          },
          back() {
            throw new Error(`You cannot use navigator.back() on the server because it is a stateless environment.`);
          },
          forward() {
            throw new Error(`You cannot use navigator.forward() on the server because it is a stateless environment.`);
          },
          block() {
            throw new Error(`You cannot use navigator.block() on the server because it is a stateless environment.`);
          }
        };
        return /* @__PURE__ */ React__namespace.createElement(components.RemixEntry, {
          context,
          action: history.Action.Pop,
          location,
          navigator: staticNavigator,
          static: true
        });
      }
      exports.RemixServer = RemixServer2;
    }
  });

  // node_modules/@remix-run/react/index.js
  var require_react2 = __commonJS({
    "node_modules/@remix-run/react/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var browser = require_browser();
      var reactRouterDom = require_main3();
      var components = require_components();
      var errorBoundaries = require_errorBoundaries();
      var scrollRestoration = require_scroll_restoration();
      var server = require_server2();
      exports.RemixBrowser = browser.RemixBrowser;
      Object.defineProperty(exports, "Outlet", {
        enumerable: true,
        get: function() {
          return reactRouterDom.Outlet;
        }
      });
      Object.defineProperty(exports, "useHref", {
        enumerable: true,
        get: function() {
          return reactRouterDom.useHref;
        }
      });
      Object.defineProperty(exports, "useLocation", {
        enumerable: true,
        get: function() {
          return reactRouterDom.useLocation;
        }
      });
      Object.defineProperty(exports, "useNavigate", {
        enumerable: true,
        get: function() {
          return reactRouterDom.useNavigate;
        }
      });
      Object.defineProperty(exports, "useNavigationType", {
        enumerable: true,
        get: function() {
          return reactRouterDom.useNavigationType;
        }
      });
      Object.defineProperty(exports, "useOutlet", {
        enumerable: true,
        get: function() {
          return reactRouterDom.useOutlet;
        }
      });
      Object.defineProperty(exports, "useOutletContext", {
        enumerable: true,
        get: function() {
          return reactRouterDom.useOutletContext;
        }
      });
      Object.defineProperty(exports, "useParams", {
        enumerable: true,
        get: function() {
          return reactRouterDom.useParams;
        }
      });
      Object.defineProperty(exports, "useResolvedPath", {
        enumerable: true,
        get: function() {
          return reactRouterDom.useResolvedPath;
        }
      });
      Object.defineProperty(exports, "useSearchParams", {
        enumerable: true,
        get: function() {
          return reactRouterDom.useSearchParams;
        }
      });
      exports.Form = components.Form;
      exports.Link = components.Link;
      exports.Links = components.Links;
      exports.LiveReload = components.LiveReload;
      exports.Meta = components.Meta;
      exports.NavLink = components.NavLink;
      exports.PrefetchPageLinks = components.PrefetchPageLinks;
      exports.Scripts = components.Scripts;
      exports.useActionData = components.useActionData;
      exports.useBeforeUnload = components.useBeforeUnload;
      exports.useFetcher = components.useFetcher;
      exports.useFetchers = components.useFetchers;
      exports.useFormAction = components.useFormAction;
      exports.useLoaderData = components.useLoaderData;
      exports.useMatches = components.useMatches;
      exports.useSubmit = components.useSubmit;
      exports.useTransition = components.useTransition;
      exports.useCatch = errorBoundaries.useCatch;
      exports.ScrollRestoration = scrollRestoration.ScrollRestoration;
      exports.RemixServer = server.RemixServer;
    }
  });

  // node_modules/remix-validated-form/dist/remix-validated-form.cjs.js
  var require_remix_validated_form_cjs = __commonJS({
    "node_modules/remix-validated-form/dist/remix-validated-form.cjs.js"(exports) {
      "use strict";
      var Dn = Object.defineProperty;
      var Mn = Object.defineProperties;
      var jn = Object.getOwnPropertyDescriptors;
      var le = Object.getOwnPropertySymbols;
      var Tr = Object.prototype.hasOwnProperty;
      var wr = Object.prototype.propertyIsEnumerable;
      var Or = (e, r, t) => r in e ? Dn(e, r, { enumerable: true, configurable: true, writable: true, value: t }) : e[r] = t;
      var x = (e, r) => {
        for (var t in r || (r = {}))
          Tr.call(r, t) && Or(e, t, r[t]);
        if (le)
          for (var t of le(r))
            wr.call(r, t) && Or(e, t, r[t]);
        return e;
      };
      var K = (e, r) => Mn(e, jn(r));
      var Cr = (e, r) => {
        var t = {};
        for (var n in e)
          Tr.call(e, n) && r.indexOf(n) < 0 && (t[n] = e[n]);
        if (e != null && le)
          for (var n of le(e))
            r.indexOf(n) < 0 && wr.call(e, n) && (t[n] = e[n]);
        return t;
      };
      Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
      var y = require_react();
      var ee = require_react2();
      var Rn = require_server_runtime();
      function Ln(e) {
        return e && typeof e == "object" && "default" in e ? e : { default: e };
      }
      var D = Ln(y);
      var de = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
      function Gn() {
        this.__data__ = [], this.size = 0;
      }
      var Hn = Gn;
      function Vn(e, r) {
        return e === r || e !== e && r !== r;
      }
      var Qe = Vn;
      var Kn = Qe;
      function Nn(e, r) {
        for (var t = e.length; t--; )
          if (Kn(e[t][0], r))
            return t;
        return -1;
      }
      var _e = Nn;
      var Un = _e;
      var Bn = Array.prototype;
      var qn = Bn.splice;
      function zn(e) {
        var r = this.__data__, t = Un(r, e);
        if (t < 0)
          return false;
        var n = r.length - 1;
        return t == n ? r.pop() : qn.call(r, t, 1), --this.size, true;
      }
      var Wn = zn;
      var Xn = _e;
      function kn(e) {
        var r = this.__data__, t = Xn(r, e);
        return t < 0 ? void 0 : r[t][1];
      }
      var Yn = kn;
      var Zn = _e;
      function Jn(e) {
        return Zn(this.__data__, e) > -1;
      }
      var Qn = Jn;
      var ea = _e;
      function ra(e, r) {
        var t = this.__data__, n = ea(t, e);
        return n < 0 ? (++this.size, t.push([e, r])) : t[n][1] = r, this;
      }
      var ta = ra;
      var na = Hn;
      var aa = Wn;
      var sa = Yn;
      var oa = Qn;
      var ia = ta;
      function q(e) {
        var r = -1, t = e == null ? 0 : e.length;
        for (this.clear(); ++r < t; ) {
          var n = e[r];
          this.set(n[0], n[1]);
        }
      }
      q.prototype.clear = na;
      q.prototype.delete = aa;
      q.prototype.get = sa;
      q.prototype.has = oa;
      q.prototype.set = ia;
      var $e = q;
      var ua = $e;
      function ca() {
        this.__data__ = new ua(), this.size = 0;
      }
      var fa = ca;
      function la(e) {
        var r = this.__data__, t = r.delete(e);
        return this.size = r.size, t;
      }
      var da = la;
      function va(e) {
        return this.__data__.get(e);
      }
      var ha = va;
      function ya(e) {
        return this.__data__.has(e);
      }
      var pa = ya;
      var ma = typeof de == "object" && de && de.Object === Object && de;
      var $t = ma;
      var ga = $t;
      var ba = typeof self == "object" && self && self.Object === Object && self;
      var _a = ga || ba || Function("return this")();
      var M = _a;
      var $a = M;
      var Sa = $a.Symbol;
      var Se = Sa;
      var xr = Se;
      var St = Object.prototype;
      var Pa = St.hasOwnProperty;
      var Ea = St.toString;
      var Z = xr ? xr.toStringTag : void 0;
      function Fa(e) {
        var r = Pa.call(e, Z), t = e[Z];
        try {
          e[Z] = void 0;
          var n = true;
        } catch {
        }
        var a = Ea.call(e);
        return n && (r ? e[Z] = t : delete e[Z]), a;
      }
      var Ia = Fa;
      var Aa = Object.prototype;
      var Oa = Aa.toString;
      function Ta(e) {
        return Oa.call(e);
      }
      var wa = Ta;
      var Dr = Se;
      var Ca = Ia;
      var xa = wa;
      var Da = "[object Null]";
      var Ma = "[object Undefined]";
      var Mr = Dr ? Dr.toStringTag : void 0;
      function ja(e) {
        return e == null ? e === void 0 ? Ma : Da : Mr && Mr in Object(e) ? Ca(e) : xa(e);
      }
      var ne = ja;
      function Ra(e) {
        var r = typeof e;
        return e != null && (r == "object" || r == "function");
      }
      var ae = Ra;
      var La = ne;
      var Ga = ae;
      var Ha = "[object AsyncFunction]";
      var Va = "[object Function]";
      var Ka = "[object GeneratorFunction]";
      var Na = "[object Proxy]";
      function Ua(e) {
        if (!Ga(e))
          return false;
        var r = La(e);
        return r == Va || r == Ka || r == Ha || r == Na;
      }
      var Pt = Ua;
      var Ba = M;
      var qa = Ba["__core-js_shared__"];
      var za = qa;
      var Te = za;
      var jr = function() {
        var e = /[^.]+$/.exec(Te && Te.keys && Te.keys.IE_PROTO || "");
        return e ? "Symbol(src)_1." + e : "";
      }();
      function Wa(e) {
        return !!jr && jr in e;
      }
      var Xa = Wa;
      var ka = Function.prototype;
      var Ya = ka.toString;
      function Za(e) {
        if (e != null) {
          try {
            return Ya.call(e);
          } catch {
          }
          try {
            return e + "";
          } catch {
          }
        }
        return "";
      }
      var Et = Za;
      var Ja = Pt;
      var Qa = Xa;
      var es = ae;
      var rs = Et;
      var ts = /[\\^$.*+?()[\]{}|]/g;
      var ns = /^\[object .+?Constructor\]$/;
      var as = Function.prototype;
      var ss = Object.prototype;
      var os = as.toString;
      var is = ss.hasOwnProperty;
      var us = RegExp("^" + os.call(is).replace(ts, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      function cs(e) {
        if (!es(e) || Qa(e))
          return false;
        var r = Ja(e) ? us : ns;
        return r.test(rs(e));
      }
      var fs = cs;
      function ls(e, r) {
        return e == null ? void 0 : e[r];
      }
      var ds = ls;
      var vs = fs;
      var hs = ds;
      function ys(e, r) {
        var t = hs(e, r);
        return vs(t) ? t : void 0;
      }
      var V = ys;
      var ps = V;
      var ms = M;
      var gs = ps(ms, "Map");
      var er = gs;
      var bs = V;
      var _s = bs(Object, "create");
      var Pe = _s;
      var Rr = Pe;
      function $s() {
        this.__data__ = Rr ? Rr(null) : {}, this.size = 0;
      }
      var Ss = $s;
      function Ps(e) {
        var r = this.has(e) && delete this.__data__[e];
        return this.size -= r ? 1 : 0, r;
      }
      var Es = Ps;
      var Fs = Pe;
      var Is = "__lodash_hash_undefined__";
      var As = Object.prototype;
      var Os = As.hasOwnProperty;
      function Ts(e) {
        var r = this.__data__;
        if (Fs) {
          var t = r[e];
          return t === Is ? void 0 : t;
        }
        return Os.call(r, e) ? r[e] : void 0;
      }
      var ws = Ts;
      var Cs = Pe;
      var xs = Object.prototype;
      var Ds = xs.hasOwnProperty;
      function Ms(e) {
        var r = this.__data__;
        return Cs ? r[e] !== void 0 : Ds.call(r, e);
      }
      var js = Ms;
      var Rs = Pe;
      var Ls = "__lodash_hash_undefined__";
      function Gs(e, r) {
        var t = this.__data__;
        return this.size += this.has(e) ? 0 : 1, t[e] = Rs && r === void 0 ? Ls : r, this;
      }
      var Hs = Gs;
      var Vs = Ss;
      var Ks = Es;
      var Ns = ws;
      var Us = js;
      var Bs = Hs;
      function z(e) {
        var r = -1, t = e == null ? 0 : e.length;
        for (this.clear(); ++r < t; ) {
          var n = e[r];
          this.set(n[0], n[1]);
        }
      }
      z.prototype.clear = Vs;
      z.prototype.delete = Ks;
      z.prototype.get = Ns;
      z.prototype.has = Us;
      z.prototype.set = Bs;
      var qs = z;
      var Lr = qs;
      var zs = $e;
      var Ws = er;
      function Xs() {
        this.size = 0, this.__data__ = { hash: new Lr(), map: new (Ws || zs)(), string: new Lr() };
      }
      var ks = Xs;
      function Ys(e) {
        var r = typeof e;
        return r == "string" || r == "number" || r == "symbol" || r == "boolean" ? e !== "__proto__" : e === null;
      }
      var Zs = Ys;
      var Js = Zs;
      function Qs(e, r) {
        var t = e.__data__;
        return Js(r) ? t[typeof r == "string" ? "string" : "hash"] : t.map;
      }
      var Ee = Qs;
      var eo = Ee;
      function ro(e) {
        var r = eo(this, e).delete(e);
        return this.size -= r ? 1 : 0, r;
      }
      var to = ro;
      var no = Ee;
      function ao(e) {
        return no(this, e).get(e);
      }
      var so = ao;
      var oo = Ee;
      function io(e) {
        return oo(this, e).has(e);
      }
      var uo = io;
      var co = Ee;
      function fo(e, r) {
        var t = co(this, e), n = t.size;
        return t.set(e, r), this.size += t.size == n ? 0 : 1, this;
      }
      var lo = fo;
      var vo = ks;
      var ho = to;
      var yo = so;
      var po = uo;
      var mo = lo;
      function W(e) {
        var r = -1, t = e == null ? 0 : e.length;
        for (this.clear(); ++r < t; ) {
          var n = e[r];
          this.set(n[0], n[1]);
        }
      }
      W.prototype.clear = vo;
      W.prototype.delete = ho;
      W.prototype.get = yo;
      W.prototype.has = po;
      W.prototype.set = mo;
      var rr = W;
      var go = $e;
      var bo = er;
      var _o = rr;
      var $o = 200;
      function So(e, r) {
        var t = this.__data__;
        if (t instanceof go) {
          var n = t.__data__;
          if (!bo || n.length < $o - 1)
            return n.push([e, r]), this.size = ++t.size, this;
          t = this.__data__ = new _o(n);
        }
        return t.set(e, r), this.size = t.size, this;
      }
      var Po = So;
      var Eo = $e;
      var Fo = fa;
      var Io = da;
      var Ao = ha;
      var Oo = pa;
      var To = Po;
      function X(e) {
        var r = this.__data__ = new Eo(e);
        this.size = r.size;
      }
      X.prototype.clear = Fo;
      X.prototype.delete = Io;
      X.prototype.get = Ao;
      X.prototype.has = Oo;
      X.prototype.set = To;
      var Ft = X;
      var wo = "__lodash_hash_undefined__";
      function Co(e) {
        return this.__data__.set(e, wo), this;
      }
      var xo = Co;
      function Do(e) {
        return this.__data__.has(e);
      }
      var Mo = Do;
      var jo = rr;
      var Ro = xo;
      var Lo = Mo;
      function ye(e) {
        var r = -1, t = e == null ? 0 : e.length;
        for (this.__data__ = new jo(); ++r < t; )
          this.add(e[r]);
      }
      ye.prototype.add = ye.prototype.push = Ro;
      ye.prototype.has = Lo;
      var It = ye;
      function Go(e, r) {
        for (var t = -1, n = e == null ? 0 : e.length; ++t < n; )
          if (r(e[t], t, e))
            return true;
        return false;
      }
      var Ho = Go;
      function Vo(e, r) {
        return e.has(r);
      }
      var At = Vo;
      var Ko = It;
      var No = Ho;
      var Uo = At;
      var Bo = 1;
      var qo = 2;
      function zo(e, r, t, n, a, s) {
        var o = t & Bo, i = e.length, u = r.length;
        if (i != u && !(o && u > i))
          return false;
        var c = s.get(e), f = s.get(r);
        if (c && f)
          return c == r && f == e;
        var d = -1, l = true, v = t & qo ? new Ko() : void 0;
        for (s.set(e, r), s.set(r, e); ++d < i; ) {
          var m = e[d], g = r[d];
          if (n)
            var S = o ? n(g, m, d, r, e, s) : n(m, g, d, e, r, s);
          if (S !== void 0) {
            if (S)
              continue;
            l = false;
            break;
          }
          if (v) {
            if (!No(r, function(b, $) {
              if (!Uo(v, $) && (m === b || a(m, b, t, n, s)))
                return v.push($);
            })) {
              l = false;
              break;
            }
          } else if (!(m === g || a(m, g, t, n, s))) {
            l = false;
            break;
          }
        }
        return s.delete(e), s.delete(r), l;
      }
      var Ot = zo;
      var Wo = M;
      var Xo = Wo.Uint8Array;
      var ko = Xo;
      function Yo(e) {
        var r = -1, t = Array(e.size);
        return e.forEach(function(n, a) {
          t[++r] = [a, n];
        }), t;
      }
      var Zo = Yo;
      function Jo(e) {
        var r = -1, t = Array(e.size);
        return e.forEach(function(n) {
          t[++r] = n;
        }), t;
      }
      var tr = Jo;
      var Gr = Se;
      var Hr = ko;
      var Qo = Qe;
      var ei = Ot;
      var ri = Zo;
      var ti = tr;
      var ni = 1;
      var ai = 2;
      var si = "[object Boolean]";
      var oi = "[object Date]";
      var ii = "[object Error]";
      var ui = "[object Map]";
      var ci = "[object Number]";
      var fi = "[object RegExp]";
      var li = "[object Set]";
      var di = "[object String]";
      var vi = "[object Symbol]";
      var hi = "[object ArrayBuffer]";
      var yi = "[object DataView]";
      var Vr = Gr ? Gr.prototype : void 0;
      var we = Vr ? Vr.valueOf : void 0;
      function pi(e, r, t, n, a, s, o) {
        switch (t) {
          case yi:
            if (e.byteLength != r.byteLength || e.byteOffset != r.byteOffset)
              return false;
            e = e.buffer, r = r.buffer;
          case hi:
            return !(e.byteLength != r.byteLength || !s(new Hr(e), new Hr(r)));
          case si:
          case oi:
          case ci:
            return Qo(+e, +r);
          case ii:
            return e.name == r.name && e.message == r.message;
          case fi:
          case di:
            return e == r + "";
          case ui:
            var i = ri;
          case li:
            var u = n & ni;
            if (i || (i = ti), e.size != r.size && !u)
              return false;
            var c = o.get(e);
            if (c)
              return c == r;
            n |= ai, o.set(e, r);
            var f = ei(i(e), i(r), n, a, s, o);
            return o.delete(e), f;
          case vi:
            if (we)
              return we.call(e) == we.call(r);
        }
        return false;
      }
      var mi = pi;
      function gi(e, r) {
        for (var t = -1, n = r.length, a = e.length; ++t < n; )
          e[a + t] = r[t];
        return e;
      }
      var Tt = gi;
      var bi = Array.isArray;
      var j = bi;
      var _i = Tt;
      var $i = j;
      function Si(e, r, t) {
        var n = r(e);
        return $i(e) ? n : _i(n, t(e));
      }
      var wt = Si;
      function Pi(e, r) {
        for (var t = -1, n = e == null ? 0 : e.length, a = 0, s = []; ++t < n; ) {
          var o = e[t];
          r(o, t, e) && (s[a++] = o);
        }
        return s;
      }
      var Ei = Pi;
      function Fi() {
        return [];
      }
      var Ct = Fi;
      var Ii = Ei;
      var Ai = Ct;
      var Oi = Object.prototype;
      var Ti = Oi.propertyIsEnumerable;
      var Kr = Object.getOwnPropertySymbols;
      var wi = Kr ? function(e) {
        return e == null ? [] : (e = Object(e), Ii(Kr(e), function(r) {
          return Ti.call(e, r);
        }));
      } : Ai;
      var xt = wi;
      function Ci(e, r) {
        for (var t = -1, n = Array(e); ++t < e; )
          n[t] = r(t);
        return n;
      }
      var xi = Ci;
      function Di(e) {
        return e != null && typeof e == "object";
      }
      var se = Di;
      var Mi = ne;
      var ji = se;
      var Ri = "[object Arguments]";
      function Li(e) {
        return ji(e) && Mi(e) == Ri;
      }
      var Gi = Li;
      var Nr = Gi;
      var Hi = se;
      var Dt = Object.prototype;
      var Vi = Dt.hasOwnProperty;
      var Ki = Dt.propertyIsEnumerable;
      var Ni = Nr(function() {
        return arguments;
      }()) ? Nr : function(e) {
        return Hi(e) && Vi.call(e, "callee") && !Ki.call(e, "callee");
      };
      var Mt = Ni;
      var pe = { exports: {} };
      function Ui() {
        return false;
      }
      var Bi = Ui;
      (function(e, r) {
        var t = M, n = Bi, a = r && !r.nodeType && r, s = a && true && e && !e.nodeType && e, o = s && s.exports === a, i = o ? t.Buffer : void 0, u = i ? i.isBuffer : void 0, c = u || n;
        e.exports = c;
      })(pe, pe.exports);
      var qi = 9007199254740991;
      var zi = /^(?:0|[1-9]\d*)$/;
      function Wi(e, r) {
        var t = typeof e;
        return r = r == null ? qi : r, !!r && (t == "number" || t != "symbol" && zi.test(e)) && e > -1 && e % 1 == 0 && e < r;
      }
      var nr = Wi;
      var Xi = 9007199254740991;
      function ki(e) {
        return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Xi;
      }
      var ar = ki;
      var Yi = ne;
      var Zi = ar;
      var Ji = se;
      var Qi = "[object Arguments]";
      var eu = "[object Array]";
      var ru = "[object Boolean]";
      var tu = "[object Date]";
      var nu = "[object Error]";
      var au = "[object Function]";
      var su = "[object Map]";
      var ou = "[object Number]";
      var iu = "[object Object]";
      var uu = "[object RegExp]";
      var cu = "[object Set]";
      var fu = "[object String]";
      var lu = "[object WeakMap]";
      var du = "[object ArrayBuffer]";
      var vu = "[object DataView]";
      var hu = "[object Float32Array]";
      var yu = "[object Float64Array]";
      var pu = "[object Int8Array]";
      var mu = "[object Int16Array]";
      var gu = "[object Int32Array]";
      var bu = "[object Uint8Array]";
      var _u = "[object Uint8ClampedArray]";
      var $u = "[object Uint16Array]";
      var Su = "[object Uint32Array]";
      var _ = {};
      _[hu] = _[yu] = _[pu] = _[mu] = _[gu] = _[bu] = _[_u] = _[$u] = _[Su] = true;
      _[Qi] = _[eu] = _[du] = _[ru] = _[vu] = _[tu] = _[nu] = _[au] = _[su] = _[ou] = _[iu] = _[uu] = _[cu] = _[fu] = _[lu] = false;
      function Pu(e) {
        return Ji(e) && Zi(e.length) && !!_[Yi(e)];
      }
      var Eu = Pu;
      function Fu(e) {
        return function(r) {
          return e(r);
        };
      }
      var Iu = Fu;
      var Ve = { exports: {} };
      (function(e, r) {
        var t = $t, n = r && !r.nodeType && r, a = n && true && e && !e.nodeType && e, s = a && a.exports === n, o = s && t.process, i = function() {
          try {
            var u = a && a.require && a.require("util").types;
            return u || o && o.binding && o.binding("util");
          } catch {
          }
        }();
        e.exports = i;
      })(Ve, Ve.exports);
      var Au = Eu;
      var Ou = Iu;
      var Ur = Ve.exports;
      var Br = Ur && Ur.isTypedArray;
      var Tu = Br ? Ou(Br) : Au;
      var jt = Tu;
      var wu = xi;
      var Cu = Mt;
      var xu = j;
      var Du = pe.exports;
      var Mu = nr;
      var ju = jt;
      var Ru = Object.prototype;
      var Lu = Ru.hasOwnProperty;
      function Gu(e, r) {
        var t = xu(e), n = !t && Cu(e), a = !t && !n && Du(e), s = !t && !n && !a && ju(e), o = t || n || a || s, i = o ? wu(e.length, String) : [], u = i.length;
        for (var c in e)
          (r || Lu.call(e, c)) && !(o && (c == "length" || a && (c == "offset" || c == "parent") || s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || Mu(c, u))) && i.push(c);
        return i;
      }
      var Rt = Gu;
      var Hu = Object.prototype;
      function Vu(e) {
        var r = e && e.constructor, t = typeof r == "function" && r.prototype || Hu;
        return e === t;
      }
      var Lt = Vu;
      function Ku(e, r) {
        return function(t) {
          return e(r(t));
        };
      }
      var Gt = Ku;
      var Nu = Gt;
      var Uu = Nu(Object.keys, Object);
      var Bu = Uu;
      var qu = Lt;
      var zu = Bu;
      var Wu = Object.prototype;
      var Xu = Wu.hasOwnProperty;
      function ku(e) {
        if (!qu(e))
          return zu(e);
        var r = [];
        for (var t in Object(e))
          Xu.call(e, t) && t != "constructor" && r.push(t);
        return r;
      }
      var Yu = ku;
      var Zu = Pt;
      var Ju = ar;
      function Qu(e) {
        return e != null && Ju(e.length) && !Zu(e);
      }
      var Ht = Qu;
      var ec = Rt;
      var rc = Yu;
      var tc = Ht;
      function nc(e) {
        return tc(e) ? ec(e) : rc(e);
      }
      var Vt = nc;
      var ac = wt;
      var sc = xt;
      var oc = Vt;
      function ic(e) {
        return ac(e, oc, sc);
      }
      var uc = ic;
      var qr = uc;
      var cc = 1;
      var fc = Object.prototype;
      var lc = fc.hasOwnProperty;
      function dc(e, r, t, n, a, s) {
        var o = t & cc, i = qr(e), u = i.length, c = qr(r), f = c.length;
        if (u != f && !o)
          return false;
        for (var d = u; d--; ) {
          var l = i[d];
          if (!(o ? l in r : lc.call(r, l)))
            return false;
        }
        var v = s.get(e), m = s.get(r);
        if (v && m)
          return v == r && m == e;
        var g = true;
        s.set(e, r), s.set(r, e);
        for (var S = o; ++d < u; ) {
          l = i[d];
          var b = e[l], $ = r[l];
          if (n)
            var I = o ? n($, b, l, r, e, s) : n(b, $, l, e, r, s);
          if (!(I === void 0 ? b === $ || a(b, $, t, n, s) : I)) {
            g = false;
            break;
          }
          S || (S = l == "constructor");
        }
        if (g && !S) {
          var P = e.constructor, T = r.constructor;
          P != T && "constructor" in e && "constructor" in r && !(typeof P == "function" && P instanceof P && typeof T == "function" && T instanceof T) && (g = false);
        }
        return s.delete(e), s.delete(r), g;
      }
      var vc = dc;
      var hc = V;
      var yc = M;
      var pc = hc(yc, "DataView");
      var mc = pc;
      var gc = V;
      var bc = M;
      var _c = gc(bc, "Promise");
      var $c = _c;
      var Sc = V;
      var Pc = M;
      var Ec = Sc(Pc, "Set");
      var Kt = Ec;
      var Fc = V;
      var Ic = M;
      var Ac = Fc(Ic, "WeakMap");
      var Oc = Ac;
      var Ke = mc;
      var Ne = er;
      var Ue = $c;
      var Be = Kt;
      var qe = Oc;
      var Nt = ne;
      var k = Et;
      var zr = "[object Map]";
      var Tc = "[object Object]";
      var Wr = "[object Promise]";
      var Xr = "[object Set]";
      var kr = "[object WeakMap]";
      var Yr = "[object DataView]";
      var wc = k(Ke);
      var Cc = k(Ne);
      var xc = k(Ue);
      var Dc = k(Be);
      var Mc = k(qe);
      var L = Nt;
      (Ke && L(new Ke(new ArrayBuffer(1))) != Yr || Ne && L(new Ne()) != zr || Ue && L(Ue.resolve()) != Wr || Be && L(new Be()) != Xr || qe && L(new qe()) != kr) && (L = function(e) {
        var r = Nt(e), t = r == Tc ? e.constructor : void 0, n = t ? k(t) : "";
        if (n)
          switch (n) {
            case wc:
              return Yr;
            case Cc:
              return zr;
            case xc:
              return Wr;
            case Dc:
              return Xr;
            case Mc:
              return kr;
          }
        return r;
      });
      var jc = L;
      var Ce = Ft;
      var Rc = Ot;
      var Lc = mi;
      var Gc = vc;
      var Zr = jc;
      var Jr = j;
      var Qr = pe.exports;
      var Hc = jt;
      var Vc = 1;
      var et = "[object Arguments]";
      var rt = "[object Array]";
      var ve = "[object Object]";
      var Kc = Object.prototype;
      var tt = Kc.hasOwnProperty;
      function Nc(e, r, t, n, a, s) {
        var o = Jr(e), i = Jr(r), u = o ? rt : Zr(e), c = i ? rt : Zr(r);
        u = u == et ? ve : u, c = c == et ? ve : c;
        var f = u == ve, d = c == ve, l = u == c;
        if (l && Qr(e)) {
          if (!Qr(r))
            return false;
          o = true, f = false;
        }
        if (l && !f)
          return s || (s = new Ce()), o || Hc(e) ? Rc(e, r, t, n, a, s) : Lc(e, r, u, t, n, a, s);
        if (!(t & Vc)) {
          var v = f && tt.call(e, "__wrapped__"), m = d && tt.call(r, "__wrapped__");
          if (v || m) {
            var g = v ? e.value() : e, S = m ? r.value() : r;
            return s || (s = new Ce()), a(g, S, t, n, s);
          }
        }
        return l ? (s || (s = new Ce()), Gc(e, r, t, n, a, s)) : false;
      }
      var Uc = Nc;
      var Bc = Uc;
      var nt = se;
      function Ut(e, r, t, n, a) {
        return e === r ? true : e == null || r == null || !nt(e) && !nt(r) ? e !== e && r !== r : Bc(e, r, t, n, Ut, a);
      }
      var sr = Ut;
      var qc = Ft;
      var zc = sr;
      var Wc = 1;
      var Xc = 2;
      function kc(e, r, t, n) {
        var a = t.length, s = a, o = !n;
        if (e == null)
          return !s;
        for (e = Object(e); a--; ) {
          var i = t[a];
          if (o && i[2] ? i[1] !== e[i[0]] : !(i[0] in e))
            return false;
        }
        for (; ++a < s; ) {
          i = t[a];
          var u = i[0], c = e[u], f = i[1];
          if (o && i[2]) {
            if (c === void 0 && !(u in e))
              return false;
          } else {
            var d = new qc();
            if (n)
              var l = n(c, f, u, e, r, d);
            if (!(l === void 0 ? zc(f, c, Wc | Xc, n, d) : l))
              return false;
          }
        }
        return true;
      }
      var Yc = kc;
      var Zc = ae;
      function Jc(e) {
        return e === e && !Zc(e);
      }
      var Bt = Jc;
      var Qc = Bt;
      var ef = Vt;
      function rf(e) {
        for (var r = ef(e), t = r.length; t--; ) {
          var n = r[t], a = e[n];
          r[t] = [n, a, Qc(a)];
        }
        return r;
      }
      var tf = rf;
      function nf(e, r) {
        return function(t) {
          return t == null ? false : t[e] === r && (r !== void 0 || e in Object(t));
        };
      }
      var qt = nf;
      var af = Yc;
      var sf = tf;
      var of = qt;
      function uf(e) {
        var r = sf(e);
        return r.length == 1 && r[0][2] ? of(r[0][0], r[0][1]) : function(t) {
          return t === e || af(t, e, r);
        };
      }
      var cf = uf;
      var ff = ne;
      var lf = se;
      var df = "[object Symbol]";
      function vf(e) {
        return typeof e == "symbol" || lf(e) && ff(e) == df;
      }
      var or = vf;
      var hf = j;
      var yf = or;
      var pf = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var mf = /^\w*$/;
      function gf(e, r) {
        if (hf(e))
          return false;
        var t = typeof e;
        return t == "number" || t == "symbol" || t == "boolean" || e == null || yf(e) ? true : mf.test(e) || !pf.test(e) || r != null && e in Object(r);
      }
      var ir = gf;
      var zt = rr;
      var bf = "Expected a function";
      function ur(e, r) {
        if (typeof e != "function" || r != null && typeof r != "function")
          throw new TypeError(bf);
        var t = function() {
          var n = arguments, a = r ? r.apply(this, n) : n[0], s = t.cache;
          if (s.has(a))
            return s.get(a);
          var o = e.apply(this, n);
          return t.cache = s.set(a, o) || s, o;
        };
        return t.cache = new (ur.Cache || zt)(), t;
      }
      ur.Cache = zt;
      var _f = ur;
      var $f = _f;
      var Sf = 500;
      function Pf(e) {
        var r = $f(e, function(n) {
          return t.size === Sf && t.clear(), n;
        }), t = r.cache;
        return r;
      }
      var Ef = Pf;
      var Ff = Ef;
      var If = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var Af = /\\(\\)?/g;
      var Of = Ff(function(e) {
        var r = [];
        return e.charCodeAt(0) === 46 && r.push(""), e.replace(If, function(t, n, a, s) {
          r.push(a ? s.replace(Af, "$1") : n || t);
        }), r;
      });
      var Tf = Of;
      function wf(e, r) {
        for (var t = -1, n = e == null ? 0 : e.length, a = Array(n); ++t < n; )
          a[t] = r(e[t], t, e);
        return a;
      }
      var Wt = wf;
      var at = Se;
      var Cf = Wt;
      var xf = j;
      var Df = or;
      var Mf = 1 / 0;
      var st = at ? at.prototype : void 0;
      var ot = st ? st.toString : void 0;
      function Xt(e) {
        if (typeof e == "string")
          return e;
        if (xf(e))
          return Cf(e, Xt) + "";
        if (Df(e))
          return ot ? ot.call(e) : "";
        var r = e + "";
        return r == "0" && 1 / e == -Mf ? "-0" : r;
      }
      var jf = Xt;
      var Rf = jf;
      function Lf(e) {
        return e == null ? "" : Rf(e);
      }
      var Gf = Lf;
      var Hf = j;
      var Vf = ir;
      var Kf = Tf;
      var Nf = Gf;
      function Uf(e, r) {
        return Hf(e) ? e : Vf(e, r) ? [e] : Kf(Nf(e));
      }
      var Fe = Uf;
      var Bf = or;
      var qf = 1 / 0;
      function zf(e) {
        if (typeof e == "string" || Bf(e))
          return e;
        var r = e + "";
        return r == "0" && 1 / e == -qf ? "-0" : r;
      }
      var oe = zf;
      var Wf = Fe;
      var Xf = oe;
      function kf(e, r) {
        r = Wf(r, e);
        for (var t = 0, n = r.length; e != null && t < n; )
          e = e[Xf(r[t++])];
        return t && t == n ? e : void 0;
      }
      var cr = kf;
      var Yf = cr;
      function Zf(e, r, t) {
        var n = e == null ? void 0 : Yf(e, r);
        return n === void 0 ? t : n;
      }
      var ze = Zf;
      function Jf(e, r) {
        return e != null && r in Object(e);
      }
      var Qf = Jf;
      var el = Fe;
      var rl = Mt;
      var tl = j;
      var nl = nr;
      var al = ar;
      var sl = oe;
      function ol(e, r, t) {
        r = el(r, e);
        for (var n = -1, a = r.length, s = false; ++n < a; ) {
          var o = sl(r[n]);
          if (!(s = e != null && t(e, o)))
            break;
          e = e[o];
        }
        return s || ++n != a ? s : (a = e == null ? 0 : e.length, !!a && al(a) && nl(o, a) && (tl(e) || rl(e)));
      }
      var il = ol;
      var ul = Qf;
      var cl = il;
      function fl(e, r) {
        return e != null && cl(e, r, ul);
      }
      var ll = fl;
      var dl = sr;
      var vl = ze;
      var hl = ll;
      var yl = ir;
      var pl = Bt;
      var ml = qt;
      var gl = oe;
      var bl = 1;
      var _l = 2;
      function $l(e, r) {
        return yl(e) && pl(r) ? ml(gl(e), r) : function(t) {
          var n = vl(t, e);
          return n === void 0 && n === r ? hl(t, e) : dl(r, n, bl | _l);
        };
      }
      var Sl = $l;
      function Pl(e) {
        return e;
      }
      var El = Pl;
      function Fl(e) {
        return function(r) {
          return r == null ? void 0 : r[e];
        };
      }
      var Il = Fl;
      var Al = cr;
      function Ol(e) {
        return function(r) {
          return Al(r, e);
        };
      }
      var Tl = Ol;
      var wl = Il;
      var Cl = Tl;
      var xl = ir;
      var Dl = oe;
      function Ml(e) {
        return xl(e) ? wl(Dl(e)) : Cl(e);
      }
      var jl = Ml;
      var Rl = cf;
      var Ll = Sl;
      var Gl = El;
      var Hl = j;
      var Vl = jl;
      function Kl(e) {
        return typeof e == "function" ? e : e == null ? Gl : typeof e == "object" ? Hl(e) ? Ll(e[0], e[1]) : Rl(e) : Vl(e);
      }
      var kt = Kl;
      var Nl = "Expected a function";
      function Ul(e) {
        if (typeof e != "function")
          throw new TypeError(Nl);
        return function() {
          var r = arguments;
          switch (r.length) {
            case 0:
              return !e.call(this);
            case 1:
              return !e.call(this, r[0]);
            case 2:
              return !e.call(this, r[0], r[1]);
            case 3:
              return !e.call(this, r[0], r[1], r[2]);
          }
          return !e.apply(this, r);
        };
      }
      var Bl = Ul;
      var ql = V;
      var zl = function() {
        try {
          var e = ql(Object, "defineProperty");
          return e({}, "", {}), e;
        } catch {
        }
      }();
      var Wl = zl;
      var it = Wl;
      function Xl(e, r, t) {
        r == "__proto__" && it ? it(e, r, { configurable: true, enumerable: true, value: t, writable: true }) : e[r] = t;
      }
      var kl = Xl;
      var Yl = kl;
      var Zl = Qe;
      var Jl = Object.prototype;
      var Ql = Jl.hasOwnProperty;
      function ed(e, r, t) {
        var n = e[r];
        (!(Ql.call(e, r) && Zl(n, t)) || t === void 0 && !(r in e)) && Yl(e, r, t);
      }
      var rd = ed;
      var td = rd;
      var nd = Fe;
      var ad = nr;
      var ut = ae;
      var sd = oe;
      function od(e, r, t, n) {
        if (!ut(e))
          return e;
        r = nd(r, e);
        for (var a = -1, s = r.length, o = s - 1, i = e; i != null && ++a < s; ) {
          var u = sd(r[a]), c = t;
          if (u === "__proto__" || u === "constructor" || u === "prototype")
            return e;
          if (a != o) {
            var f = i[u];
            c = n ? n(f, u, i) : void 0, c === void 0 && (c = ut(f) ? f : ad(r[a + 1]) ? [] : {});
          }
          td(i, u, c), i = i[u];
        }
        return e;
      }
      var Yt = od;
      var id = cr;
      var ud = Yt;
      var cd = Fe;
      function fd(e, r, t) {
        for (var n = -1, a = r.length, s = {}; ++n < a; ) {
          var o = r[n], i = id(e, o);
          t(i, o) && ud(s, cd(o, e), i);
        }
        return s;
      }
      var ld = fd;
      var dd = Gt;
      var vd = dd(Object.getPrototypeOf, Object);
      var hd = vd;
      var yd = Tt;
      var pd = hd;
      var md = xt;
      var gd = Ct;
      var bd = Object.getOwnPropertySymbols;
      var _d = bd ? function(e) {
        for (var r = []; e; )
          yd(r, md(e)), e = pd(e);
        return r;
      } : gd;
      var $d = _d;
      function Sd(e) {
        var r = [];
        if (e != null)
          for (var t in Object(e))
            r.push(t);
        return r;
      }
      var Pd = Sd;
      var Ed = ae;
      var Fd = Lt;
      var Id = Pd;
      var Ad = Object.prototype;
      var Od = Ad.hasOwnProperty;
      function Td(e) {
        if (!Ed(e))
          return Id(e);
        var r = Fd(e), t = [];
        for (var n in e)
          n == "constructor" && (r || !Od.call(e, n)) || t.push(n);
        return t;
      }
      var wd = Td;
      var Cd = Rt;
      var xd = wd;
      var Dd = Ht;
      function Md(e) {
        return Dd(e) ? Cd(e, true) : xd(e);
      }
      var jd = Md;
      var Rd = wt;
      var Ld = $d;
      var Gd = jd;
      function Hd(e) {
        return Rd(e, Gd, Ld);
      }
      var Vd = Hd;
      var Kd = Wt;
      var Nd = kt;
      var Ud = ld;
      var Bd = Vd;
      function qd(e, r) {
        if (e == null)
          return {};
        var t = Kd(Bd(e), function(n) {
          return [n];
        });
        return r = Nd(r), Ud(e, t, function(n, a) {
          return r(n, a[0]);
        });
      }
      var zd = qd;
      var Wd = kt;
      var Xd = Bl;
      var kd = zd;
      function Yd(e, r) {
        return kd(e, Xd(Wd(r)));
      }
      var Zd = Yd;
      var Jd = (e = "on", r) => {
        if (Array.isArray(r))
          return r.some((t) => t === true || t === e);
        if (typeof r == "boolean")
          return r;
        if (typeof r == "string")
          return r === e;
      };
      var Qd = (e = "on", r) => {
        if (typeof r == "string")
          return r === e;
      };
      var ev = { initial: "onBlur", whenTouched: "onChange", whenSubmitted: "onChange" };
      var rv = ({ clearError: e, validate: r, defaultValue: t, touched: n, setTouched: a, hasBeenSubmitted: s, validationBehavior: o, name: i }) => {
        const u = x(x({}, ev), o);
        return (c = {}) => {
          const f = s ? u.whenSubmitted : n ? u.whenTouched : u.initial, d = K(x({}, c), { onChange: (...l) => {
            var v;
            return f === "onChange" ? r() : e(), (v = c == null ? void 0 : c.onChange) == null ? void 0 : v.call(c, ...l);
          }, onBlur: (...l) => {
            var v;
            return f === "onBlur" && r(), a(true), (v = c == null ? void 0 : c.onBlur) == null ? void 0 : v.call(c, ...l);
          }, name: i });
          return c.type === "checkbox" ? d.defaultChecked = Jd(c.value, t) : c.type === "radio" ? d.defaultChecked = Qd(c.value, t) : c.value === void 0 && (d.defaultValue = t), Zd(d, (l) => l === void 0);
        };
      };
      var tv = true;
      var xe = "Invariant failed";
      function N(e, r) {
        if (!e) {
          if (tv)
            throw new Error(xe);
          var t = typeof r == "function" ? r() : r, n = t ? xe + ": " + t : xe;
          throw new Error(n);
        }
      }
      var he = "__rvfInternalFormId";
      var nv = "__rvfInternalFormDefaults";
      var Zt = (e) => `${nv}_${e}`;
      var Jt = y.createContext(null);
      var fr = (e) => ({ hydrateTo: () => e, map: (r) => fr(r(e)) });
      var lr = () => ({ hydrateTo: (e) => e, map: () => lr() });
      var av = (e, r) => r ? lr() : fr(e);
      var J = { serverData: fr, hydratedData: lr, from: av };
      var ct = (e) => {
        let r;
        const t = /* @__PURE__ */ new Set(), n = (u, c) => {
          const f = typeof u == "function" ? u(r) : u;
          if (f !== r) {
            const d = r;
            r = c ? f : Object.assign({}, r, f), t.forEach((l) => l(r, d));
          }
        }, a = () => r, i = { setState: n, getState: a, subscribe: (u) => (t.add(u), () => t.delete(u)), destroy: () => t.clear() };
        return r = e(n, a, i), i;
      };
      var sv = (e) => e ? ct(e) : ct;
      var Qt = { exports: {} };
      var en = {};
      var rn = { exports: {} };
      var tn = {};
      var U = D.default;
      function ov(e, r) {
        return e === r && (e !== 0 || 1 / e === 1 / r) || e !== e && r !== r;
      }
      var iv = typeof Object.is == "function" ? Object.is : ov;
      var uv = U.useState;
      var cv = U.useEffect;
      var fv = U.useLayoutEffect;
      var lv = U.useDebugValue;
      function dv(e, r) {
        var t = r(), n = uv({ inst: { value: t, getSnapshot: r } }), a = n[0].inst, s = n[1];
        return fv(function() {
          a.value = t, a.getSnapshot = r, De(a) && s({ inst: a });
        }, [e, t, r]), cv(function() {
          return De(a) && s({ inst: a }), e(function() {
            De(a) && s({ inst: a });
          });
        }, [e]), lv(t), t;
      }
      function De(e) {
        var r = e.getSnapshot;
        e = e.value;
        try {
          var t = r();
          return !iv(e, t);
        } catch {
          return true;
        }
      }
      function vv(e, r) {
        return r();
      }
      var hv = typeof window == "undefined" || typeof window.document == "undefined" || typeof window.document.createElement == "undefined" ? vv : dv;
      tn.useSyncExternalStore = U.useSyncExternalStore !== void 0 ? U.useSyncExternalStore : hv;
      rn.exports = tn;
      var Ie = D.default;
      var yv = rn.exports;
      function pv(e, r) {
        return e === r && (e !== 0 || 1 / e === 1 / r) || e !== e && r !== r;
      }
      var mv = typeof Object.is == "function" ? Object.is : pv;
      var gv = yv.useSyncExternalStore;
      var bv = Ie.useRef;
      var _v = Ie.useEffect;
      var $v = Ie.useMemo;
      var Sv = Ie.useDebugValue;
      en.useSyncExternalStoreWithSelector = function(e, r, t, n, a) {
        var s = bv(null);
        if (s.current === null) {
          var o = { hasValue: false, value: null };
          s.current = o;
        } else
          o = s.current;
        s = $v(function() {
          function u(v) {
            if (!c) {
              if (c = true, f = v, v = n(v), a !== void 0 && o.hasValue) {
                var m = o.value;
                if (a(m, v))
                  return d = m;
              }
              return d = v;
            }
            if (m = d, mv(f, v))
              return m;
            var g = n(v);
            return a !== void 0 && a(m, g) ? m : (f = v, d = g);
          }
          var c = false, f, d, l = t === void 0 ? null : t;
          return [function() {
            return u(r());
          }, l === null ? void 0 : function() {
            return u(l());
          }];
        }, [r, t, n, a]);
        var i = gv(e, s[0], s[1]);
        return _v(function() {
          o.hasValue = true, o.value = i;
        }, [i]), Sv(i), i;
      };
      Qt.exports = en;
      function Pv(e, r = e.getState, t) {
        const n = Qt.exports.useSyncExternalStoreWithSelector(e.subscribe, e.getState, e.getServerState || e.getState, r, t);
        return y.useDebugValue(n), n;
      }
      var ft = (e) => {
        const r = typeof e == "function" ? sv(e) : e, t = (n, a) => Pv(r, n, a);
        return Object.assign(t, r), t;
      };
      var Ev = (e) => e ? ft(e) : ft;
      var nn = Ev;
      function O(e) {
        for (var r = arguments.length, t = Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)
          t[n - 1] = arguments[n];
        throw Error("[Immer] minified error nr: " + e + (t.length ? " " + t.map(function(a) {
          return "'" + a + "'";
        }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
      }
      function B(e) {
        return !!e && !!e[E];
      }
      function H(e) {
        return !!e && (function(r) {
          if (!r || typeof r != "object")
            return false;
          var t = Object.getPrototypeOf(r);
          if (t === null)
            return true;
          var n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
          return n === Object || typeof n == "function" && Function.toString.call(n) === xv;
        }(e) || Array.isArray(e) || !!e[gt] || !!e.constructor[gt] || dr(e) || vr(e));
      }
      function re(e, r, t) {
        t === void 0 && (t = false), Y(e) === 0 ? (t ? Object.keys : gr)(e).forEach(function(n) {
          t && typeof n == "symbol" || r(n, e[n], e);
        }) : e.forEach(function(n, a) {
          return r(a, n, e);
        });
      }
      function Y(e) {
        var r = e[E];
        return r ? r.i > 3 ? r.i - 4 : r.i : Array.isArray(e) ? 1 : dr(e) ? 2 : vr(e) ? 3 : 0;
      }
      function We(e, r) {
        return Y(e) === 2 ? e.has(r) : Object.prototype.hasOwnProperty.call(e, r);
      }
      function Fv(e, r) {
        return Y(e) === 2 ? e.get(r) : e[r];
      }
      function an(e, r, t) {
        var n = Y(e);
        n === 2 ? e.set(r, t) : n === 3 ? (e.delete(r), e.add(t)) : e[r] = t;
      }
      function Iv(e, r) {
        return e === r ? e !== 0 || 1 / e == 1 / r : e != e && r != r;
      }
      function dr(e) {
        return wv && e instanceof Map;
      }
      function vr(e) {
        return Cv && e instanceof Set;
      }
      function G(e) {
        return e.o || e.t;
      }
      function hr(e) {
        if (Array.isArray(e))
          return Array.prototype.slice.call(e);
        var r = Dv(e);
        delete r[E];
        for (var t = gr(r), n = 0; n < t.length; n++) {
          var a = t[n], s = r[a];
          s.writable === false && (s.writable = true, s.configurable = true), (s.get || s.set) && (r[a] = { configurable: true, writable: true, enumerable: s.enumerable, value: e[a] });
        }
        return Object.create(Object.getPrototypeOf(e), r);
      }
      function yr(e, r) {
        return r === void 0 && (r = false), pr(e) || B(e) || !H(e) || (Y(e) > 1 && (e.set = e.add = e.clear = e.delete = Av), Object.freeze(e), r && re(e, function(t, n) {
          return yr(n, true);
        }, true)), e;
      }
      function Av() {
        O(2);
      }
      function pr(e) {
        return e == null || typeof e != "object" || Object.isFrozen(e);
      }
      function C(e) {
        var r = Mv[e];
        return r || O(18, e), r;
      }
      function lt() {
        return te;
      }
      function Me(e, r) {
        r && (C("Patches"), e.u = [], e.s = [], e.v = r);
      }
      function me(e) {
        Xe(e), e.p.forEach(Ov), e.p = null;
      }
      function Xe(e) {
        e === te && (te = e.l);
      }
      function dt(e) {
        return te = { p: [], l: te, h: e, m: true, _: 0 };
      }
      function Ov(e) {
        var r = e[E];
        r.i === 0 || r.i === 1 ? r.j() : r.O = true;
      }
      function je(e, r) {
        r._ = r.p.length;
        var t = r.p[0], n = e !== void 0 && e !== t;
        return r.h.g || C("ES5").S(r, e, n), n ? (t[E].P && (me(r), O(4)), H(e) && (e = ge(r, e), r.l || be(r, e)), r.u && C("Patches").M(t[E].t, e, r.u, r.s)) : e = ge(r, t, []), me(r), r.u && r.v(r.u, r.s), e !== sn ? e : void 0;
      }
      function ge(e, r, t) {
        if (pr(r))
          return r;
        var n = r[E];
        if (!n)
          return re(r, function(s, o) {
            return vt(e, n, r, s, o, t);
          }, true), r;
        if (n.A !== e)
          return r;
        if (!n.P)
          return be(e, n.t, true), n.t;
        if (!n.I) {
          n.I = true, n.A._--;
          var a = n.i === 4 || n.i === 5 ? n.o = hr(n.k) : n.o;
          re(n.i === 3 ? new Set(a) : a, function(s, o) {
            return vt(e, n, a, s, o, t);
          }), be(e, a, false), t && e.u && C("Patches").R(n, t, e.u, e.s);
        }
        return n.o;
      }
      function vt(e, r, t, n, a, s) {
        if (B(a)) {
          var o = ge(e, a, s && r && r.i !== 3 && !We(r.D, n) ? s.concat(n) : void 0);
          if (an(t, n, o), !B(o))
            return;
          e.m = false;
        }
        if (H(a) && !pr(a)) {
          if (!e.h.F && e._ < 1)
            return;
          ge(e, a), r && r.A.l || be(e, a);
        }
      }
      function be(e, r, t) {
        t === void 0 && (t = false), e.h.F && e.m && yr(r, t);
      }
      function Re(e, r) {
        var t = e[E];
        return (t ? G(t) : e)[r];
      }
      function ht(e, r) {
        if (r in e)
          for (var t = Object.getPrototypeOf(e); t; ) {
            var n = Object.getOwnPropertyDescriptor(t, r);
            if (n)
              return n;
            t = Object.getPrototypeOf(t);
          }
      }
      function ke(e) {
        e.P || (e.P = true, e.l && ke(e.l));
      }
      function Le(e) {
        e.o || (e.o = hr(e.t));
      }
      function Ye(e, r, t) {
        var n = dr(r) ? C("MapSet").N(r, t) : vr(r) ? C("MapSet").T(r, t) : e.g ? function(a, s) {
          var o = Array.isArray(a), i = { i: o ? 1 : 0, A: s ? s.A : lt(), P: false, I: false, D: {}, l: s, t: a, k: null, o: null, j: null, C: false }, u = i, c = Ze;
          o && (u = [i], c = Q);
          var f = Proxy.revocable(u, c), d = f.revoke, l = f.proxy;
          return i.k = l, i.j = d, l;
        }(r, t) : C("ES5").J(r, t);
        return (t ? t.A : lt()).p.push(n), n;
      }
      function Tv(e) {
        return B(e) || O(22, e), function r(t) {
          if (!H(t))
            return t;
          var n, a = t[E], s = Y(t);
          if (a) {
            if (!a.P && (a.i < 4 || !C("ES5").K(a)))
              return a.t;
            a.I = true, n = yt(t, s), a.I = false;
          } else
            n = yt(t, s);
          return re(n, function(o, i) {
            a && Fv(a.t, o) === i || an(n, o, r(i));
          }), s === 3 ? new Set(n) : n;
        }(e);
      }
      function yt(e, r) {
        switch (r) {
          case 2:
            return new Map(e);
          case 3:
            return Array.from(e);
        }
        return hr(e);
      }
      var pt;
      var te;
      var mr = typeof Symbol != "undefined" && typeof Symbol("x") == "symbol";
      var wv = typeof Map != "undefined";
      var Cv = typeof Set != "undefined";
      var mt = typeof Proxy != "undefined" && Proxy.revocable !== void 0 && typeof Reflect != "undefined";
      var sn = mr ? Symbol.for("immer-nothing") : ((pt = {})["immer-nothing"] = true, pt);
      var gt = mr ? Symbol.for("immer-draftable") : "__$immer_draftable";
      var E = mr ? Symbol.for("immer-state") : "__$immer_state";
      var xv = "" + Object.prototype.constructor;
      var gr = typeof Reflect != "undefined" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(e) {
        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
      } : Object.getOwnPropertyNames;
      var Dv = Object.getOwnPropertyDescriptors || function(e) {
        var r = {};
        return gr(e).forEach(function(t) {
          r[t] = Object.getOwnPropertyDescriptor(e, t);
        }), r;
      };
      var Mv = {};
      var Ze = { get: function(e, r) {
        if (r === E)
          return e;
        var t = G(e);
        if (!We(t, r))
          return function(a, s, o) {
            var i, u = ht(s, o);
            return u ? "value" in u ? u.value : (i = u.get) === null || i === void 0 ? void 0 : i.call(a.k) : void 0;
          }(e, t, r);
        var n = t[r];
        return e.I || !H(n) ? n : n === Re(e.t, r) ? (Le(e), e.o[r] = Ye(e.A.h, n, e)) : n;
      }, has: function(e, r) {
        return r in G(e);
      }, ownKeys: function(e) {
        return Reflect.ownKeys(G(e));
      }, set: function(e, r, t) {
        var n = ht(G(e), r);
        if (n != null && n.set)
          return n.set.call(e.k, t), true;
        if (!e.P) {
          var a = Re(G(e), r), s = a == null ? void 0 : a[E];
          if (s && s.t === t)
            return e.o[r] = t, e.D[r] = false, true;
          if (Iv(t, a) && (t !== void 0 || We(e.t, r)))
            return true;
          Le(e), ke(e);
        }
        return e.o[r] === t && typeof t != "number" && (t !== void 0 || r in e.o) || (e.o[r] = t, e.D[r] = true, true);
      }, deleteProperty: function(e, r) {
        return Re(e.t, r) !== void 0 || r in e.t ? (e.D[r] = false, Le(e), ke(e)) : delete e.D[r], e.o && delete e.o[r], true;
      }, getOwnPropertyDescriptor: function(e, r) {
        var t = G(e), n = Reflect.getOwnPropertyDescriptor(t, r);
        return n && { writable: true, configurable: e.i !== 1 || r !== "length", enumerable: n.enumerable, value: t[r] };
      }, defineProperty: function() {
        O(11);
      }, getPrototypeOf: function(e) {
        return Object.getPrototypeOf(e.t);
      }, setPrototypeOf: function() {
        O(12);
      } };
      var Q = {};
      re(Ze, function(e, r) {
        Q[e] = function() {
          return arguments[0] = arguments[0][0], r.apply(this, arguments);
        };
      }), Q.deleteProperty = function(e, r) {
        return Q.set.call(this, e, r, void 0);
      }, Q.set = function(e, r, t) {
        return Ze.set.call(this, e[0], r, t, e[0]);
      };
      var jv = function() {
        function e(t) {
          var n = this;
          this.g = mt, this.F = true, this.produce = function(a, s, o) {
            if (typeof a == "function" && typeof s != "function") {
              var i = s;
              s = a;
              var u = n;
              return function(g) {
                var S = this;
                g === void 0 && (g = i);
                for (var b = arguments.length, $ = Array(b > 1 ? b - 1 : 0), I = 1; I < b; I++)
                  $[I - 1] = arguments[I];
                return u.produce(g, function(P) {
                  var T;
                  return (T = s).call.apply(T, [S, P].concat($));
                });
              };
            }
            var c;
            if (typeof s != "function" && O(6), o !== void 0 && typeof o != "function" && O(7), H(a)) {
              var f = dt(n), d = Ye(n, a, void 0), l = true;
              try {
                c = s(d), l = false;
              } finally {
                l ? me(f) : Xe(f);
              }
              return typeof Promise != "undefined" && c instanceof Promise ? c.then(function(g) {
                return Me(f, o), je(g, f);
              }, function(g) {
                throw me(f), g;
              }) : (Me(f, o), je(c, f));
            }
            if (!a || typeof a != "object") {
              if ((c = s(a)) === void 0 && (c = a), c === sn && (c = void 0), n.F && yr(c, true), o) {
                var v = [], m = [];
                C("Patches").M(a, c, v, m), o(v, m);
              }
              return c;
            }
            O(21, a);
          }, this.produceWithPatches = function(a, s) {
            if (typeof a == "function")
              return function(c) {
                for (var f = arguments.length, d = Array(f > 1 ? f - 1 : 0), l = 1; l < f; l++)
                  d[l - 1] = arguments[l];
                return n.produceWithPatches(c, function(v) {
                  return a.apply(void 0, [v].concat(d));
                });
              };
            var o, i, u = n.produce(a, s, function(c, f) {
              o = c, i = f;
            });
            return typeof Promise != "undefined" && u instanceof Promise ? u.then(function(c) {
              return [c, o, i];
            }) : [u, o, i];
          }, typeof (t == null ? void 0 : t.useProxies) == "boolean" && this.setUseProxies(t.useProxies), typeof (t == null ? void 0 : t.autoFreeze) == "boolean" && this.setAutoFreeze(t.autoFreeze);
        }
        var r = e.prototype;
        return r.createDraft = function(t) {
          H(t) || O(8), B(t) && (t = Tv(t));
          var n = dt(this), a = Ye(this, t, void 0);
          return a[E].C = true, Xe(n), a;
        }, r.finishDraft = function(t, n) {
          var a = t && t[E], s = a.A;
          return Me(s, n), je(void 0, s);
        }, r.setAutoFreeze = function(t) {
          this.F = t;
        }, r.setUseProxies = function(t) {
          t && !mt && O(20), this.g = t;
        }, r.applyPatches = function(t, n) {
          var a;
          for (a = n.length - 1; a >= 0; a--) {
            var s = n[a];
            if (s.path.length === 0 && s.op === "replace") {
              t = s.value;
              break;
            }
          }
          a > -1 && (n = n.slice(a + 1));
          var o = C("Patches").$;
          return B(t) ? o(t, n) : this.produce(t, function(i) {
            return o(i, n);
          });
        }, e;
      }();
      var F = new jv();
      var Rv = F.produce;
      F.produceWithPatches.bind(F);
      F.setAutoFreeze.bind(F);
      F.setUseProxies.bind(F);
      F.applyPatches.bind(F);
      F.createDraft.bind(F);
      F.finishDraft.bind(F);
      var Lv = (e) => (r, t, n) => (n.setState = (a, s, ...o) => {
        const i = typeof a == "function" ? Rv(a) : a;
        return r(i, s, ...o);
      }, e(n.setState, t, n));
      var on = Lv;
      var w = nn()(on((e, r) => ({ forms: {}, register: (t, n) => e((a) => {
        a.forms[t] || (a.forms[t] = {}), a.forms[t][n] ? a.forms[t][n].refCount++ : a.forms[t][n] = { refCount: 1, value: void 0, hydrated: false, valueUpdatePromise: void 0, resolveValueUpdate: void 0 };
      }), unregister: (t, n) => e((a) => {
        var i;
        const s = (i = a.forms) == null ? void 0 : i[t], o = s == null ? void 0 : s[n];
        !o || (o.refCount--, o.refCount === 0 && delete s[n]);
      }), getField: (t, n) => {
        var a, s;
        return (s = (a = r().forms) == null ? void 0 : a[t]) == null ? void 0 : s[n];
      }, setValue: (t, n, a) => e((s) => {
        var u, c;
        const o = (c = (u = s.forms) == null ? void 0 : u[t]) == null ? void 0 : c[n];
        if (!o)
          return;
        o.value = a;
        const i = new Promise((f) => {
          o.resolveValueUpdate = f;
        });
        o.valueUpdatePromise = i;
      }), hydrateWithDefault: (t, n, a) => e((s) => {
        var i;
        const o = (i = s.forms[t]) == null ? void 0 : i[n];
        !o || (o.value = a, o.defaultValue = a, o.hydrated = true);
      }), awaitValueUpdate: async (t, n) => {
        var a;
        await ((a = r().getField(t, n)) == null ? void 0 : a.valueUpdatePromise);
      }, reset: (t) => e((n) => {
        const a = n.forms[t];
        !a || Object.values(a).forEach((s) => {
          !s || (s.value = s.defaultValue);
        });
      }) })));
      var A = () => {
      };
      var Gv = { isHydrated: false, isSubmitting: false, hasBeenSubmitted: false, touchedFields: {}, fieldErrors: {}, formElement: null, isValid: () => true, startSubmit: A, endSubmit: A, setTouched: A, setFieldError: A, setFieldErrors: A, clearFieldError: A, reset: () => A, syncFormProps: A, setHydrated: A, setFormElement: A, validateField: async () => null, validate: async () => {
        throw new Error("Validate called before form was initialized.");
      }, submit: async () => {
        throw new Error("Submit called before form was initialized.");
      }, resetFormElement: A };
      var Hv = (e, r, t) => ({ isHydrated: false, isSubmitting: false, hasBeenSubmitted: false, touchedFields: {}, fieldErrors: {}, formElement: null, isValid: () => Object.keys(t().fieldErrors).length === 0, startSubmit: () => r((n) => {
        n.isSubmitting = true, n.hasBeenSubmitted = true;
      }), endSubmit: () => r((n) => {
        n.isSubmitting = false;
      }), setTouched: (n, a) => r((s) => {
        s.touchedFields[n] = a;
      }), setFieldError: (n, a) => r((s) => {
        s.fieldErrors[n] = a;
      }), setFieldErrors: (n) => r((a) => {
        a.fieldErrors = n;
      }), clearFieldError: (n) => r((a) => {
        delete a.fieldErrors[n];
      }), reset: () => r((n) => {
        n.fieldErrors = {}, n.touchedFields = {}, n.hasBeenSubmitted = false;
      }), syncFormProps: (n) => r((a) => {
        a.formProps = n, a.isHydrated = true;
      }), setHydrated: () => r((n) => {
        n.isHydrated = true;
      }), setFormElement: (n) => {
        t().formElement !== n && r((a) => {
          a.formElement = n;
        });
      }, validateField: async (n) => {
        var i, u, c;
        const a = t().formElement;
        N(a, "Cannot find reference to form. This is probably a bug in remix-validated-form.");
        const s = (i = t().formProps) == null ? void 0 : i.validator;
        N(s, "Cannot validator. This is probably a bug in remix-validated-form."), await ((c = (u = w.getState()).awaitValueUpdate) == null ? void 0 : c.call(u, e, n));
        const { error: o } = await s.validateField(new FormData(a), n);
        return o ? (t().setFieldError(n, o), o) : (t().clearFieldError(n), null);
      }, validate: async () => {
        var o;
        const n = t().formElement;
        N(n, "Cannot find reference to form. This is probably a bug in remix-validated-form.");
        const a = (o = t().formProps) == null ? void 0 : o.validator;
        N(a, "Cannot validator. This is probably a bug in remix-validated-form.");
        const s = await a.validate(new FormData(n));
        return s.error && t().setFieldErrors(s.error.fieldErrors), s;
      }, submit: () => {
        const n = t().formElement;
        N(n, "Cannot find reference to form. This is probably a bug in remix-validated-form."), n.submit();
      }, resetFormElement: () => {
        var n;
        return (n = t().formElement) == null ? void 0 : n.reset();
      } });
      var Je = nn()(on((e, r) => ({ forms: {}, form: (t) => {
        var n;
        return (n = r().forms[t]) != null ? n : Gv;
      }, cleanupForm: (t) => {
        e((n) => {
          delete n.forms[t];
        });
      }, registerForm: (t) => {
        r().forms[t] || e((n) => {
          n.forms[t] = Hv(t, (a) => e((s) => a(s.forms[t])), () => r().forms[t]);
        });
      } })));
      var p = (e, r) => Je((t) => r(t.form(e)));
      var R = (e, r) => {
        const t = y.useContext(Jt);
        if (e)
          return { formId: e };
        if (t)
          return t;
        throw new Error(`Unable to determine form for ${r}. Please use it inside a ValidatedForm or pass a 'formId'.`);
      };
      function br({ fetcher: e, subaction: r, formId: t }) {
        var a;
        const n = ee.useActionData();
        return e ? (a = e.data) != null && a.fieldErrors ? e.data : null : n != null && n.fieldErrors ? typeof t == "string" && n.formId ? n.formId === t ? n : null : !r && !n.subaction || n.subaction === r ? n : null : null;
      }
      var un = (e) => {
        const r = br(e), t = p(e.formId, (n) => n.isHydrated);
        return J.from(r == null ? void 0 : r.fieldErrors, t);
      };
      var cn = ({ formId: e }) => {
        const r = ee.useMatches();
        if (typeof e == "string") {
          const t = Zt(e), n = r.reverse().find((a) => a.data && t in a.data);
          return n == null ? void 0 : n.data[t];
        }
        return null;
      };
      var fn = (e) => {
        const { formId: r, defaultValuesProp: t } = e, n = p(r, (o) => o.isHydrated), a = br(e), s = cn(e);
        return n ? J.hydratedData() : a != null && a.repopulateFields ? (N(typeof a.repopulateFields == "object", "repopulateFields returned something other than an object"), J.serverData(a.repopulateFields)) : t ? J.serverData(t) : J.serverData(s);
      };
      var Vv = ({ fetcher: e }) => {
        const r = ee.useTransition();
        return e ? e.state === "submitting" : !!r.submission;
      };
      var Kv = (e, { formId: r }) => {
        const t = p(r, (s) => s.touchedFields[e]), n = p(r, (s) => s.setTouched), a = y.useCallback((s) => n(e, s), [e, n]);
        return [t, a];
      };
      var Nv = (e, r) => {
        const t = un(r), n = p(r.formId, (a) => a.fieldErrors[e]);
        return t.map((a) => a == null ? void 0 : a[e]).hydrateTo(n);
      };
      var ln = (e) => {
        const { formId: r } = e;
        return p(r, (t) => t.clearFieldError);
      };
      var dn = (e, r) => {
        const t = fn(r), n = gn(r.formId);
        return t.map((a) => ze(a, e)).hydrateTo(ze(n, e));
      };
      var vn = (e) => p(e, (r) => r.isSubmitting);
      var hn = (e) => p(e, (r) => r.isValid());
      var yn = (e) => p(e, (r) => r.hasBeenSubmitted);
      var pn = (e) => p(e, (r) => r.validateField);
      var Uv = (e) => p(e, (r) => r.validate);
      var Bv = () => () => {
      };
      var mn = (e) => p(e, (r) => {
        var t, n;
        return (n = (t = r.formProps) == null ? void 0 : t.registerReceiveFocus) != null ? n : Bv;
      });
      var qv = {};
      var gn = (e) => p(e, (r) => {
        var t, n;
        return (n = (t = r.formProps) == null ? void 0 : t.defaultValues) != null ? n : qv;
      });
      var zv = ({ formId: e }) => p(e, (r) => r.setTouched);
      var Wv = (e) => p(e, (r) => r.touchedFields);
      var Xv = (e) => p(e, (r) => r.fieldErrors);
      var bn = (e) => p(e, (r) => r.setFieldErrors);
      var kv = (e) => p(e, (r) => r.resetFormElement);
      var Yv = (e) => p(e, (r) => r.submit);
      var Zv = (e) => p(e, (r) => {
        var t;
        return (t = r.formProps) == null ? void 0 : t.action;
      });
      var Jv = (e) => p(e, (r) => {
        var t;
        return (t = r.formProps) == null ? void 0 : t.subaction;
      });
      var Qv = (e, r) => {
        const t = w((i) => {
          var u;
          return (u = i.getField(e.formId, r)) == null ? void 0 : u.value;
        }), n = p(e.formId, (i) => i.isHydrated), a = dn(r, e), s = w((i) => {
          var u, c;
          return (c = (u = i.getField(e.formId, r)) == null ? void 0 : u.hydrated) != null ? c : false;
        }), o = w((i) => i.hydrateWithDefault);
        return y.useEffect(() => {
          n && !s && o(e.formId, r, a);
        }, [e.formId, a, r, o, s, n]), s ? t : a;
      };
      var eh = (e, r) => {
        const t = w((u) => {
          var c;
          return (c = u.getField(e.formId, r)) == null ? void 0 : c.resolveValueUpdate;
        });
        y.useEffect(() => {
          t == null || t();
        }, [t]);
        const n = w((u) => u.register), a = w((u) => u.unregister);
        y.useEffect(() => (n(e.formId, r), () => a(e.formId, r)), [e.formId, r, n, a]);
        const s = w((u) => u.setValue), o = y.useCallback((u) => s(e.formId, r, u), [e.formId, r, s]);
        return [Qv(e, r), o];
      };
      var rh = (e) => {
        const r = w((t) => t.setValue);
        return y.useCallback((t, n) => r(e, t, n), [e, r]);
      };
      var _n = (e) => {
        const r = R(e, "useIsSubmitting");
        return vn(r.formId);
      };
      var $n = (e) => {
        const r = R(e, "useIsValid");
        return hn(r.formId);
      };
      var th = (e, r) => {
        const { formId: t, handleReceiveFocus: n } = r != null ? r : {}, a = R(t, "useField"), s = dn(e, a), [o, i] = Kv(e, a), u = Nv(e, a), c = ln(a), f = yn(a.formId), d = pn(a.formId), l = mn(a.formId);
        return y.useEffect(() => {
          if (n)
            return l(e, n);
        }, [n, e, l]), y.useMemo(() => {
          const m = { error: u, clearError: () => c(e), validate: () => {
            d(e);
          }, defaultValue: s, touched: o, setTouched: i }, g = rv(K(x({}, m), { name: e, hasBeenSubmitted: f, validationBehavior: r == null ? void 0 : r.validationBehavior }));
          return K(x({}, m), { getInputProps: g });
        }, [u, c, s, o, i, e, f, r == null ? void 0 : r.validationBehavior, d]);
      };
      var nh = (e, r) => {
        const t = R(r, "useControlField"), [n, a] = eh(t, e);
        return [n, a];
      };
      var ah = (e) => {
        const r = R(e, "useControlField");
        return rh(r.formId);
      };
      function sh(e, r, t) {
        return Rn.json({ fieldErrors: e.fieldErrors, subaction: e.subaction, repopulateFields: r, formId: e.formId }, x({ status: 422 }, t));
      }
      var oh = (e, r) => ({ [Zt(e)]: r });
      function ih(e, r, t, n) {
        for (var a = e.length, s = t + (n ? 1 : -1); n ? s-- : ++s < a; )
          if (r(e[s], s, e))
            return s;
        return -1;
      }
      var uh = ih;
      function ch(e) {
        return e !== e;
      }
      var fh = ch;
      function lh(e, r, t) {
        for (var n = t - 1, a = e.length; ++n < a; )
          if (e[n] === r)
            return n;
        return -1;
      }
      var dh = lh;
      var vh = uh;
      var hh = fh;
      var yh = dh;
      function ph(e, r, t) {
        return r === r ? yh(e, r, t) : vh(e, hh, t);
      }
      var mh = ph;
      var gh = mh;
      function bh(e, r) {
        var t = e == null ? 0 : e.length;
        return !!t && gh(e, r, 0) > -1;
      }
      var _h = bh;
      function $h(e, r, t) {
        for (var n = -1, a = e == null ? 0 : e.length; ++n < a; )
          if (t(r, e[n]))
            return true;
        return false;
      }
      var Sh = $h;
      function Ph() {
      }
      var Eh = Ph;
      var Ge = Kt;
      var Fh = Eh;
      var Ih = tr;
      var Ah = 1 / 0;
      var Oh = Ge && 1 / Ih(new Ge([, -0]))[1] == Ah ? function(e) {
        return new Ge(e);
      } : Fh;
      var Th = Oh;
      var wh = It;
      var Ch = _h;
      var xh = Sh;
      var Dh = At;
      var Mh = Th;
      var jh = tr;
      var Rh = 200;
      function Lh(e, r, t) {
        var n = -1, a = Ch, s = e.length, o = true, i = [], u = i;
        if (t)
          o = false, a = xh;
        else if (s >= Rh) {
          var c = r ? null : Mh(e);
          if (c)
            return jh(c);
          o = false, a = Dh, u = new wh();
        } else
          u = r ? [] : i;
        e:
          for (; ++n < s; ) {
            var f = e[n], d = r ? r(f) : f;
            if (f = t || f !== 0 ? f : 0, o && d === d) {
              for (var l = u.length; l--; )
                if (u[l] === d)
                  continue e;
              r && u.push(d), i.push(f);
            } else
              a(u, d, t) || (u !== i && u.push(d), i.push(f));
          }
        return i;
      }
      var Gh = Lh;
      var Hh = Gh;
      function Vh(e) {
        return e && e.length ? Hh(e) : [];
      }
      var Kh = Vh;
      var Sn = class {
        constructor() {
          this.dict = /* @__PURE__ */ new Map(), this.add = (r, t) => {
            this.dict.has(r) ? this.dict.get(r).push(t) : this.dict.set(r, [t]);
          }, this.delete = (r) => {
            this.dict.delete(r);
          }, this.remove = (r, t) => {
            if (!this.dict.has(r))
              return;
            const n = this.dict.get(r), a = n.indexOf(t);
            a !== -1 && n.splice(a, 1), n.length === 0 && this.dict.delete(r);
          }, this.getAll = (r) => {
            var t;
            return (t = this.dict.get(r)) != null ? t : [];
          }, this.entries = () => this.dict.entries(), this.values = () => this.dict.values(), this.has = (r) => this.dict.has(r);
        }
      };
      var Nh = () => {
        const e = y.useRef(null);
        return y.useCallback(() => (e.current || (e.current = new Sn()), e.current), []);
      };
      function Pn(e, r) {
        const t = y.useRef(false);
        y.useEffect(() => {
          e && (t.current = true), !e && t.current && (t.current = false, r());
        });
      }
      var Uh = sr;
      function Bh(e, r) {
        return Uh(e, r);
      }
      var qh = Bh;
      var zh = (e) => (r) => {
        e.filter(Boolean).forEach((t) => {
          typeof t == "function" ? t(r) : t != null && (t.current = r);
        });
      };
      var He = typeof window != "undefined" ? y.useLayoutEffect : y.useEffect;
      var Wh = (e) => {
        const r = y.useRef(e), t = r.current === e || qh(r.current, e);
        return y.useEffect(() => {
          t || (r.current = e);
        }), t ? r.current : e;
      };
      var Xh = (e) => new FormData(e);
      function kh(e) {
        return e !== null;
      }
      var Yh = (e, r, t) => {
        var s;
        const n = [...t.elements].map((o) => {
          const i = o instanceof RadioNodeList ? o[0] : o;
          return i instanceof HTMLInputElement ? i.name : null;
        }).filter(kh).filter((o) => o in e), a = Kh(n);
        for (const o of a) {
          if (r.has(o)) {
            r.getAll(o).forEach((u) => {
              u();
            });
            break;
          }
          const i = t.elements.namedItem(o);
          if (!!i) {
            if (i instanceof RadioNodeList) {
              const u = (s = [...i].filter((c) => c instanceof HTMLInputElement).find((c) => c.value === i.value)) != null ? s : i[0];
              if (u && u instanceof HTMLInputElement) {
                u.focus();
                break;
              }
            }
            if (i instanceof HTMLInputElement) {
              if (i.type === "hidden")
                continue;
              i.focus();
              break;
            }
          }
        }
      };
      var Zh = (e) => {
        const [r] = y.useState(() => Symbol("remix-validated-form-id"));
        return e != null ? e : r;
      };
      var Jh = ({ resetAfterSubmit: e, formRef: r }) => {
        const t = _n(), n = $n();
        return Pn(t, () => {
          var a;
          n && e && ((a = r.current) == null || a.reset());
        }), null;
      };
      function Qh(e) {
        let r = false;
        return new Proxy(e, { get: (t, n) => n === "preventDefault" ? () => {
          r = true;
        } : n === "defaultPrevented" ? r : t[n] });
      }
      function ey(g) {
        var S = g, { validator: e, onSubmit: r, children: t, fetcher: n, action: a, defaultValues: s, formRef: o, onReset: i, subaction: u, resetAfterSubmit: c = false, disableFocusOnError: f, method: d, replace: l, id: v } = S, m = Cr(S, ["validator", "onSubmit", "children", "fetcher", "action", "defaultValues", "formRef", "onReset", "subaction", "resetAfterSubmit", "disableFocusOnError", "method", "replace", "id"]);
        var Fr;
        const b = Zh(v), $ = Wh(s), I = y.useMemo(() => ({ formId: b, action: a, subaction: u, defaultValuesProp: $, fetcher: n }), [a, n, b, $, u]), P = br(I), T = cn(I), En = Vv(I), ie = y.useRef(null), Fn = (Fr = n == null ? void 0 : n.Form) != null ? Fr : ee.Form, In = ee.useSubmit(), Ae = bn(b), An = p(b, (h) => h.setFieldError), On = p(b, (h) => h.reset), Tn = w((h) => h.reset), wn = p(b, (h) => h.startSubmit), Oe = p(b, (h) => h.endSubmit), _r = p(b, (h) => h.syncFormProps), $r = p(b, (h) => h.setFormElement), Sr = Je((h) => h.cleanupForm), Pr = Je((h) => h.registerForm), ue = Nh(), Er = y.useCallback((h, ce) => (ue().add(h, ce), () => {
          ue().remove(h, ce);
        }), [ue]);
        He(() => (Pr(b), () => Sr(b)), [Sr, b, Pr]), He(() => {
          var h;
          _r({ action: a, defaultValues: (h = $ != null ? $ : T) != null ? h : {}, subaction: u, registerReceiveFocus: Er, validator: e });
        }, [a, $, Er, u, _r, T, e]), He(() => {
          $r(ie.current);
        }, [$r]), y.useEffect(() => {
          var h;
          Ae((h = P == null ? void 0 : P.fieldErrors) != null ? h : {});
        }, [P == null ? void 0 : P.fieldErrors, Ae, An]), Pn(En, () => {
          Oe();
        });
        const Cn = async (h, ce, xn) => {
          wn();
          const fe = await e.validate(Xh(h.currentTarget));
          if (fe.error)
            Oe(), Ae(fe.error.fieldErrors), f || Yh(fe.error.fieldErrors, ue(), ie.current);
          else {
            const Ir = Qh(h);
            if (await (r == null ? void 0 : r(fe.data, Ir)), Ir.defaultPrevented) {
              Oe();
              return;
            }
            const Ar = xn.submitter;
            n ? n.submit(Ar || h.currentTarget) : In(Ar || ce, { method: d, replace: l });
          }
        };
        return D.default.createElement(Fn, K(x({ ref: zh([ie, o]) }, m), { id: v, action: a, method: d, replace: l, onSubmit: (h) => {
          h.preventDefault(), Cn(h, h.currentTarget, h.nativeEvent);
        }, onReset: (h) => {
          i == null || i(h), !h.defaultPrevented && (On(), Tn(b));
        } }), D.default.createElement(Jt.Provider, { value: I }, D.default.createElement(D.default.Fragment, null, D.default.createElement(Jh, { formRef: ie, resetAfterSubmit: c }), u && D.default.createElement("input", { type: "hidden", value: u, name: "subaction" }), v && D.default.createElement("input", { type: "hidden", value: v, name: he }), t)));
      }
      var ry = Yt;
      function ty(e, r, t) {
        return e == null ? e : ry(e, r, t);
      }
      var ny = ty;
      var bt = (e) => {
        const r = new Sn();
        return e.forEach(([t, n]) => r.add(t, n)), [...r.entries()].reduce((t, [n, a]) => ny(t, n, a.length === 1 ? a[0] : a), {});
      };
      var _t = (e) => "entries" in e && typeof e.entries == "function" ? bt([...e.entries()]) : bt(Object.entries(e));
      function ay(e) {
        return { validate: async (r) => {
          const t = _t(r), n = await e.validate(t);
          return n.error ? { data: void 0, error: { fieldErrors: n.error, subaction: t.subaction, formId: t[he] }, submittedData: t, formId: t[he] } : { data: n.data, error: void 0, submittedData: t, formId: t[he] };
        }, validateField: (r, t) => e.validateField(_t(r), t) };
      }
      var sy = (e) => {
        const r = R(e, "useFormState"), t = vn(r.formId), n = yn(r.formId), a = Wv(r.formId), s = hn(r.formId), o = Zv(r.formId), i = Jv(r.formId), u = gn(r.formId), f = fn(r).hydrateTo(u), d = Xv(r.formId), v = un(r).hydrateTo(d);
        return y.useMemo(() => ({ action: o, subaction: i, defaultValues: f, fieldErrors: v != null ? v : {}, hasBeenSubmitted: n, isSubmitting: t, touchedFields: a, isValid: s }), [o, n, f, v, t, s, i, a]);
      };
      var oy = (e) => {
        const r = R(e, "useFormHelpers"), t = zv(r), n = pn(r.formId), a = Uv(r.formId), s = ln(r), o = bn(r.formId), i = kv(r.formId), u = Yv(r.formId);
        return y.useMemo(() => ({ setTouched: t, validateField: n, clearError: s, validate: a, clearAllErrors: () => o({}), reset: i, submit: u }), [s, i, o, t, u, a, n]);
      };
      var iy = (e) => {
        const r = R(e, "useFormContext"), t = sy(e), { clearError: n, setTouched: a, validateField: s, clearAllErrors: o, validate: i, reset: u, submit: c } = oy(e), f = mn(r.formId), d = y.useCallback((...l) => {
          l.forEach((v) => {
            n(v);
          });
        }, [n]);
        return y.useMemo(() => K(x({}, t), { setFieldTouched: a, validateField: s, clearError: d, registerReceiveFocus: f, clearAllErrors: o, validate: i, reset: u, submit: c }), [o, d, f, u, a, t, c, i, s]);
      };
      exports.ValidatedForm = ey;
      exports.createValidator = ay;
      exports.setFormDefaults = oh;
      exports.useControlField = nh;
      exports.useField = th;
      exports.useFormContext = iy;
      exports.useIsSubmitting = _n;
      exports.useIsValid = $n;
      exports.useUpdateControlledField = ah;
      exports.validationError = sh;
    }
  });

  // node_modules/spark-md5/spark-md5.js
  var require_spark_md5 = __commonJS({
    "node_modules/spark-md5/spark-md5.js"(exports, module) {
      (function(factory) {
        if (typeof exports === "object") {
          module.exports = factory();
        } else if (typeof define === "function" && define.amd) {
          define(factory);
        } else {
          var glob;
          try {
            glob = window;
          } catch (e) {
            glob = self;
          }
          glob.SparkMD5 = factory();
        }
      })(function(undefined2) {
        "use strict";
        var add32 = function(a, b) {
          return a + b & 4294967295;
        }, hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        function cmn(q, a, b, x, s, t) {
          a = add32(add32(a, q), add32(x, t));
          return add32(a << s | a >>> 32 - s, b);
        }
        function md5cycle(x, k) {
          var a = x[0], b = x[1], c = x[2], d = x[3];
          a += (b & c | ~b & d) + k[0] - 680876936 | 0;
          a = (a << 7 | a >>> 25) + b | 0;
          d += (a & b | ~a & c) + k[1] - 389564586 | 0;
          d = (d << 12 | d >>> 20) + a | 0;
          c += (d & a | ~d & b) + k[2] + 606105819 | 0;
          c = (c << 17 | c >>> 15) + d | 0;
          b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
          b = (b << 22 | b >>> 10) + c | 0;
          a += (b & c | ~b & d) + k[4] - 176418897 | 0;
          a = (a << 7 | a >>> 25) + b | 0;
          d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
          d = (d << 12 | d >>> 20) + a | 0;
          c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
          c = (c << 17 | c >>> 15) + d | 0;
          b += (c & d | ~c & a) + k[7] - 45705983 | 0;
          b = (b << 22 | b >>> 10) + c | 0;
          a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
          a = (a << 7 | a >>> 25) + b | 0;
          d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
          d = (d << 12 | d >>> 20) + a | 0;
          c += (d & a | ~d & b) + k[10] - 42063 | 0;
          c = (c << 17 | c >>> 15) + d | 0;
          b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
          b = (b << 22 | b >>> 10) + c | 0;
          a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
          a = (a << 7 | a >>> 25) + b | 0;
          d += (a & b | ~a & c) + k[13] - 40341101 | 0;
          d = (d << 12 | d >>> 20) + a | 0;
          c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
          c = (c << 17 | c >>> 15) + d | 0;
          b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
          b = (b << 22 | b >>> 10) + c | 0;
          a += (b & d | c & ~d) + k[1] - 165796510 | 0;
          a = (a << 5 | a >>> 27) + b | 0;
          d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
          d = (d << 9 | d >>> 23) + a | 0;
          c += (d & b | a & ~b) + k[11] + 643717713 | 0;
          c = (c << 14 | c >>> 18) + d | 0;
          b += (c & a | d & ~a) + k[0] - 373897302 | 0;
          b = (b << 20 | b >>> 12) + c | 0;
          a += (b & d | c & ~d) + k[5] - 701558691 | 0;
          a = (a << 5 | a >>> 27) + b | 0;
          d += (a & c | b & ~c) + k[10] + 38016083 | 0;
          d = (d << 9 | d >>> 23) + a | 0;
          c += (d & b | a & ~b) + k[15] - 660478335 | 0;
          c = (c << 14 | c >>> 18) + d | 0;
          b += (c & a | d & ~a) + k[4] - 405537848 | 0;
          b = (b << 20 | b >>> 12) + c | 0;
          a += (b & d | c & ~d) + k[9] + 568446438 | 0;
          a = (a << 5 | a >>> 27) + b | 0;
          d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
          d = (d << 9 | d >>> 23) + a | 0;
          c += (d & b | a & ~b) + k[3] - 187363961 | 0;
          c = (c << 14 | c >>> 18) + d | 0;
          b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
          b = (b << 20 | b >>> 12) + c | 0;
          a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
          a = (a << 5 | a >>> 27) + b | 0;
          d += (a & c | b & ~c) + k[2] - 51403784 | 0;
          d = (d << 9 | d >>> 23) + a | 0;
          c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
          c = (c << 14 | c >>> 18) + d | 0;
          b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
          b = (b << 20 | b >>> 12) + c | 0;
          a += (b ^ c ^ d) + k[5] - 378558 | 0;
          a = (a << 4 | a >>> 28) + b | 0;
          d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
          d = (d << 11 | d >>> 21) + a | 0;
          c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
          c = (c << 16 | c >>> 16) + d | 0;
          b += (c ^ d ^ a) + k[14] - 35309556 | 0;
          b = (b << 23 | b >>> 9) + c | 0;
          a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
          a = (a << 4 | a >>> 28) + b | 0;
          d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
          d = (d << 11 | d >>> 21) + a | 0;
          c += (d ^ a ^ b) + k[7] - 155497632 | 0;
          c = (c << 16 | c >>> 16) + d | 0;
          b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
          b = (b << 23 | b >>> 9) + c | 0;
          a += (b ^ c ^ d) + k[13] + 681279174 | 0;
          a = (a << 4 | a >>> 28) + b | 0;
          d += (a ^ b ^ c) + k[0] - 358537222 | 0;
          d = (d << 11 | d >>> 21) + a | 0;
          c += (d ^ a ^ b) + k[3] - 722521979 | 0;
          c = (c << 16 | c >>> 16) + d | 0;
          b += (c ^ d ^ a) + k[6] + 76029189 | 0;
          b = (b << 23 | b >>> 9) + c | 0;
          a += (b ^ c ^ d) + k[9] - 640364487 | 0;
          a = (a << 4 | a >>> 28) + b | 0;
          d += (a ^ b ^ c) + k[12] - 421815835 | 0;
          d = (d << 11 | d >>> 21) + a | 0;
          c += (d ^ a ^ b) + k[15] + 530742520 | 0;
          c = (c << 16 | c >>> 16) + d | 0;
          b += (c ^ d ^ a) + k[2] - 995338651 | 0;
          b = (b << 23 | b >>> 9) + c | 0;
          a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
          a = (a << 6 | a >>> 26) + b | 0;
          d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
          d = (d << 10 | d >>> 22) + a | 0;
          c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
          c = (c << 15 | c >>> 17) + d | 0;
          b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
          b = (b << 21 | b >>> 11) + c | 0;
          a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
          a = (a << 6 | a >>> 26) + b | 0;
          d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
          d = (d << 10 | d >>> 22) + a | 0;
          c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
          c = (c << 15 | c >>> 17) + d | 0;
          b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
          b = (b << 21 | b >>> 11) + c | 0;
          a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
          a = (a << 6 | a >>> 26) + b | 0;
          d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
          d = (d << 10 | d >>> 22) + a | 0;
          c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
          c = (c << 15 | c >>> 17) + d | 0;
          b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
          b = (b << 21 | b >>> 11) + c | 0;
          a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
          a = (a << 6 | a >>> 26) + b | 0;
          d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
          d = (d << 10 | d >>> 22) + a | 0;
          c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
          c = (c << 15 | c >>> 17) + d | 0;
          b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
          b = (b << 21 | b >>> 11) + c | 0;
          x[0] = a + x[0] | 0;
          x[1] = b + x[1] | 0;
          x[2] = c + x[2] | 0;
          x[3] = d + x[3] | 0;
        }
        function md5blk(s) {
          var md5blks = [], i;
          for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
          }
          return md5blks;
        }
        function md5blk_array(a) {
          var md5blks = [], i;
          for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
          }
          return md5blks;
        }
        function md51(s) {
          var n = s.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
          for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
          }
          s = s.substring(i - 64);
          length = s.length;
          tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
          }
          tail[i >> 2] |= 128 << (i % 4 << 3);
          if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
              tail[i] = 0;
            }
          }
          tmp = n * 8;
          tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp[2], 16);
          hi = parseInt(tmp[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(state, tail);
          return state;
        }
        function md51_array(a) {
          var n = a.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
          for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
          }
          a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);
          length = a.length;
          tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << (i % 4 << 3);
          }
          tail[i >> 2] |= 128 << (i % 4 << 3);
          if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
              tail[i] = 0;
            }
          }
          tmp = n * 8;
          tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp[2], 16);
          hi = parseInt(tmp[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(state, tail);
          return state;
        }
        function rhex(n) {
          var s = "", j;
          for (j = 0; j < 4; j += 1) {
            s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
          }
          return s;
        }
        function hex(x) {
          var i;
          for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
          }
          return x.join("");
        }
        if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") {
          add32 = function(x, y) {
            var lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return msw << 16 | lsw & 65535;
          };
        }
        if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
          (function() {
            function clamp(val, length) {
              val = val | 0 || 0;
              if (val < 0) {
                return Math.max(val + length, 0);
              }
              return Math.min(val, length);
            }
            ArrayBuffer.prototype.slice = function(from, to) {
              var length = this.byteLength, begin = clamp(from, length), end = length, num, target, targetArray, sourceArray;
              if (to !== undefined2) {
                end = clamp(to, length);
              }
              if (begin > end) {
                return new ArrayBuffer(0);
              }
              num = end - begin;
              target = new ArrayBuffer(num);
              targetArray = new Uint8Array(target);
              sourceArray = new Uint8Array(this, begin, num);
              targetArray.set(sourceArray);
              return target;
            };
          })();
        }
        function toUtf8(str) {
          if (/[\u0080-\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
          }
          return str;
        }
        function utf8Str2ArrayBuffer(str, returnUInt8Array) {
          var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i;
          for (i = 0; i < length; i += 1) {
            arr[i] = str.charCodeAt(i);
          }
          return returnUInt8Array ? arr : buff;
        }
        function arrayBuffer2Utf8Str(buff) {
          return String.fromCharCode.apply(null, new Uint8Array(buff));
        }
        function concatenateArrayBuffers(first, second, returnUInt8Array) {
          var result = new Uint8Array(first.byteLength + second.byteLength);
          result.set(new Uint8Array(first));
          result.set(new Uint8Array(second), first.byteLength);
          return returnUInt8Array ? result : result.buffer;
        }
        function hexToBinaryString(hex2) {
          var bytes = [], length = hex2.length, x;
          for (x = 0; x < length - 1; x += 2) {
            bytes.push(parseInt(hex2.substr(x, 2), 16));
          }
          return String.fromCharCode.apply(String, bytes);
        }
        function SparkMD5() {
          this.reset();
        }
        SparkMD5.prototype.append = function(str) {
          this.appendBinary(toUtf8(str));
          return this;
        };
        SparkMD5.prototype.appendBinary = function(contents) {
          this._buff += contents;
          this._length += contents.length;
          var length = this._buff.length, i;
          for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
          }
          this._buff = this._buff.substring(i - 64);
          return this;
        };
        SparkMD5.prototype.end = function(raw) {
          var buff = this._buff, length = buff.length, i, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
          for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
          }
          this._finish(tail, length);
          ret = hex(this._hash);
          if (raw) {
            ret = hexToBinaryString(ret);
          }
          this.reset();
          return ret;
        };
        SparkMD5.prototype.reset = function() {
          this._buff = "";
          this._length = 0;
          this._hash = [1732584193, -271733879, -1732584194, 271733878];
          return this;
        };
        SparkMD5.prototype.getState = function() {
          return {
            buff: this._buff,
            length: this._length,
            hash: this._hash.slice()
          };
        };
        SparkMD5.prototype.setState = function(state) {
          this._buff = state.buff;
          this._length = state.length;
          this._hash = state.hash;
          return this;
        };
        SparkMD5.prototype.destroy = function() {
          delete this._hash;
          delete this._buff;
          delete this._length;
        };
        SparkMD5.prototype._finish = function(tail, length) {
          var i = length, tmp, lo, hi;
          tail[i >> 2] |= 128 << (i % 4 << 3);
          if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
              tail[i] = 0;
            }
          }
          tmp = this._length * 8;
          tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp[2], 16);
          hi = parseInt(tmp[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(this._hash, tail);
        };
        SparkMD5.hash = function(str, raw) {
          return SparkMD5.hashBinary(toUtf8(str), raw);
        };
        SparkMD5.hashBinary = function(content, raw) {
          var hash = md51(content), ret = hex(hash);
          return raw ? hexToBinaryString(ret) : ret;
        };
        SparkMD5.ArrayBuffer = function() {
          this.reset();
        };
        SparkMD5.ArrayBuffer.prototype.append = function(arr) {
          var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i;
          this._length += arr.byteLength;
          for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
          }
          this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);
          return this;
        };
        SparkMD5.ArrayBuffer.prototype.end = function(raw) {
          var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i, ret;
          for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << (i % 4 << 3);
          }
          this._finish(tail, length);
          ret = hex(this._hash);
          if (raw) {
            ret = hexToBinaryString(ret);
          }
          this.reset();
          return ret;
        };
        SparkMD5.ArrayBuffer.prototype.reset = function() {
          this._buff = new Uint8Array(0);
          this._length = 0;
          this._hash = [1732584193, -271733879, -1732584194, 271733878];
          return this;
        };
        SparkMD5.ArrayBuffer.prototype.getState = function() {
          var state = SparkMD5.prototype.getState.call(this);
          state.buff = arrayBuffer2Utf8Str(state.buff);
          return state;
        };
        SparkMD5.ArrayBuffer.prototype.setState = function(state) {
          state.buff = utf8Str2ArrayBuffer(state.buff, true);
          return SparkMD5.prototype.setState.call(this, state);
        };
        SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
        SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
        SparkMD5.ArrayBuffer.hash = function(arr, raw) {
          var hash = md51_array(new Uint8Array(arr)), ret = hex(hash);
          return raw ? hexToBinaryString(ret) : ret;
        };
        return SparkMD5;
      });
    }
  });

  // node_modules/lodash/_baseHas.js
  var require_baseHas = __commonJS({
    "node_modules/lodash/_baseHas.js"(exports, module) {
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseHas(object2, key) {
        return object2 != null && hasOwnProperty.call(object2, key);
      }
      module.exports = baseHas;
    }
  });

  // node_modules/lodash/isArray.js
  var require_isArray = __commonJS({
    "node_modules/lodash/isArray.js"(exports, module) {
      var isArray = Array.isArray;
      module.exports = isArray;
    }
  });

  // node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "node_modules/lodash/_freeGlobal.js"(exports, module) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module.exports = freeGlobal;
    }
  });

  // node_modules/lodash/_root.js
  var require_root = __commonJS({
    "node_modules/lodash/_root.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module.exports = root;
    }
  });

  // node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "node_modules/lodash/_Symbol.js"(exports, module) {
      var root = require_root();
      var Symbol2 = root.Symbol;
      module.exports = Symbol2;
    }
  });

  // node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "node_modules/lodash/_getRawTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module.exports = getRawTag;
    }
  });

  // node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "node_modules/lodash/_objectToString.js"(exports, module) {
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module.exports = objectToString;
    }
  });

  // node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "node_modules/lodash/_baseGetTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module.exports = baseGetTag;
    }
  });

  // node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/lodash/isObjectLike.js"(exports, module) {
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module.exports = isObjectLike;
    }
  });

  // node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "node_modules/lodash/isSymbol.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      module.exports = isSymbol;
    }
  });

  // node_modules/lodash/_isKey.js
  var require_isKey = __commonJS({
    "node_modules/lodash/_isKey.js"(exports, module) {
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      function isKey(value, object2) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
      }
      module.exports = isKey;
    }
  });

  // node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "node_modules/lodash/isObject.js"(exports, module) {
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      module.exports = isObject2;
    }
  });

  // node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "node_modules/lodash/isFunction.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObject2 = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      module.exports = isFunction;
    }
  });

  // node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "node_modules/lodash/_coreJsData.js"(exports, module) {
      var root = require_root();
      var coreJsData = root["__core-js_shared__"];
      module.exports = coreJsData;
    }
  });

  // node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "node_modules/lodash/_isMasked.js"(exports, module) {
      var coreJsData = require_coreJsData();
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module.exports = isMasked;
    }
  });

  // node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "node_modules/lodash/_toSource.js"(exports, module) {
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      module.exports = toSource;
    }
  });

  // node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "node_modules/lodash/_baseIsNative.js"(exports, module) {
      var isFunction = require_isFunction();
      var isMasked = require_isMasked();
      var isObject2 = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module.exports = baseIsNative;
    }
  });

  // node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "node_modules/lodash/_getValue.js"(exports, module) {
      function getValue(object2, key) {
        return object2 == null ? void 0 : object2[key];
      }
      module.exports = getValue;
    }
  });

  // node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "node_modules/lodash/_getNative.js"(exports, module) {
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object2, key) {
        var value = getValue(object2, key);
        return baseIsNative(value) ? value : void 0;
      }
      module.exports = getNative;
    }
  });

  // node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "node_modules/lodash/_nativeCreate.js"(exports, module) {
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module.exports = nativeCreate;
    }
  });

  // node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "node_modules/lodash/_hashClear.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module.exports = hashClear;
    }
  });

  // node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "node_modules/lodash/_hashDelete.js"(exports, module) {
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = hashDelete;
    }
  });

  // node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "node_modules/lodash/_hashGet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      module.exports = hashGet;
    }
  });

  // node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "node_modules/lodash/_hashHas.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      module.exports = hashHas;
    }
  });

  // node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "node_modules/lodash/_hashSet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module.exports = hashSet;
    }
  });

  // node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "node_modules/lodash/_Hash.js"(exports, module) {
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry2 = entries[index];
          this.set(entry2[0], entry2[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      module.exports = Hash;
    }
  });

  // node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "node_modules/lodash/_listCacheClear.js"(exports, module) {
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module.exports = listCacheClear;
    }
  });

  // node_modules/lodash/eq.js
  var require_eq = __commonJS({
    "node_modules/lodash/eq.js"(exports, module) {
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      module.exports = eq;
    }
  });

  // node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "node_modules/lodash/_assocIndexOf.js"(exports, module) {
      var eq = require_eq();
      function assocIndexOf(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      module.exports = assocIndexOf;
    }
  });

  // node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "node_modules/lodash/_listCacheDelete.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      module.exports = listCacheDelete;
    }
  });

  // node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "node_modules/lodash/_listCacheGet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      module.exports = listCacheGet;
    }
  });

  // node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "node_modules/lodash/_listCacheHas.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module.exports = listCacheHas;
    }
  });

  // node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "node_modules/lodash/_listCacheSet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      module.exports = listCacheSet;
    }
  });

  // node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "node_modules/lodash/_ListCache.js"(exports, module) {
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry2 = entries[index];
          this.set(entry2[0], entry2[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module.exports = ListCache;
    }
  });

  // node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "node_modules/lodash/_Map.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Map2 = getNative(root, "Map");
      module.exports = Map2;
    }
  });

  // node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "node_modules/lodash/_mapCacheClear.js"(exports, module) {
      var Hash = require_Hash();
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      module.exports = mapCacheClear;
    }
  });

  // node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "node_modules/lodash/_isKeyable.js"(exports, module) {
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      module.exports = isKeyable;
    }
  });

  // node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "node_modules/lodash/_getMapData.js"(exports, module) {
      var isKeyable = require_isKeyable();
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      module.exports = getMapData;
    }
  });

  // node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = mapCacheDelete;
    }
  });

  // node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "node_modules/lodash/_mapCacheGet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module.exports = mapCacheGet;
    }
  });

  // node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "node_modules/lodash/_mapCacheHas.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module.exports = mapCacheHas;
    }
  });

  // node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "node_modules/lodash/_mapCacheSet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      module.exports = mapCacheSet;
    }
  });

  // node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "node_modules/lodash/_MapCache.js"(exports, module) {
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry2 = entries[index];
          this.set(entry2[0], entry2[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module.exports = MapCache;
    }
  });

  // node_modules/lodash/memoize.js
  var require_memoize = __commonJS({
    "node_modules/lodash/memoize.js"(exports, module) {
      var MapCache = require_MapCache();
      var FUNC_ERROR_TEXT = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      module.exports = memoize;
    }
  });

  // node_modules/lodash/_memoizeCapped.js
  var require_memoizeCapped = __commonJS({
    "node_modules/lodash/_memoizeCapped.js"(exports, module) {
      var memoize = require_memoize();
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      module.exports = memoizeCapped;
    }
  });

  // node_modules/lodash/_stringToPath.js
  var require_stringToPath = __commonJS({
    "node_modules/lodash/_stringToPath.js"(exports, module) {
      var memoizeCapped = require_memoizeCapped();
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string2) {
        var result = [];
        if (string2.charCodeAt(0) === 46) {
          result.push("");
        }
        string2.replace(rePropName, function(match, number2, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
        });
        return result;
      });
      module.exports = stringToPath;
    }
  });

  // node_modules/lodash/_arrayMap.js
  var require_arrayMap = __commonJS({
    "node_modules/lodash/_arrayMap.js"(exports, module) {
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      module.exports = arrayMap;
    }
  });

  // node_modules/lodash/_baseToString.js
  var require_baseToString = __commonJS({
    "node_modules/lodash/_baseToString.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var arrayMap = require_arrayMap();
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString2 = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString2 ? symbolToString2.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = baseToString;
    }
  });

  // node_modules/lodash/toString.js
  var require_toString = __commonJS({
    "node_modules/lodash/toString.js"(exports, module) {
      var baseToString = require_baseToString();
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      module.exports = toString2;
    }
  });

  // node_modules/lodash/_castPath.js
  var require_castPath = __commonJS({
    "node_modules/lodash/_castPath.js"(exports, module) {
      var isArray = require_isArray();
      var isKey = require_isKey();
      var stringToPath = require_stringToPath();
      var toString2 = require_toString();
      function castPath(value, object2) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object2) ? [value] : stringToPath(toString2(value));
      }
      module.exports = castPath;
    }
  });

  // node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS({
    "node_modules/lodash/_baseIsArguments.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      module.exports = baseIsArguments;
    }
  });

  // node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/lodash/isArguments.js"(exports, module) {
      var baseIsArguments = require_baseIsArguments();
      var isObjectLike = require_isObjectLike();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      module.exports = isArguments;
    }
  });

  // node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS({
    "node_modules/lodash/_isIndex.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      module.exports = isIndex;
    }
  });

  // node_modules/lodash/isLength.js
  var require_isLength = __commonJS({
    "node_modules/lodash/isLength.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      module.exports = isLength;
    }
  });

  // node_modules/lodash/_toKey.js
  var require_toKey = __commonJS({
    "node_modules/lodash/_toKey.js"(exports, module) {
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = toKey;
    }
  });

  // node_modules/lodash/_hasPath.js
  var require_hasPath = __commonJS({
    "node_modules/lodash/_hasPath.js"(exports, module) {
      var castPath = require_castPath();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isIndex = require_isIndex();
      var isLength = require_isLength();
      var toKey = require_toKey();
      function hasPath(object2, path, hasFunc) {
        path = castPath(path, object2);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object2 != null && hasFunc(object2, key))) {
            break;
          }
          object2 = object2[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object2 == null ? 0 : object2.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments(object2));
      }
      module.exports = hasPath;
    }
  });

  // node_modules/lodash/has.js
  var require_has = __commonJS({
    "node_modules/lodash/has.js"(exports, module) {
      var baseHas = require_baseHas();
      var hasPath = require_hasPath();
      function has4(object2, path) {
        return object2 != null && hasPath(object2, path, baseHas);
      }
      module.exports = has4;
    }
  });

  // node_modules/lodash/_defineProperty.js
  var require_defineProperty = __commonJS({
    "node_modules/lodash/_defineProperty.js"(exports, module) {
      var getNative = require_getNative();
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      module.exports = defineProperty;
    }
  });

  // node_modules/lodash/_baseAssignValue.js
  var require_baseAssignValue = __commonJS({
    "node_modules/lodash/_baseAssignValue.js"(exports, module) {
      var defineProperty = require_defineProperty();
      function baseAssignValue(object2, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object2, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object2[key] = value;
        }
      }
      module.exports = baseAssignValue;
    }
  });

  // node_modules/lodash/_createBaseFor.js
  var require_createBaseFor = __commonJS({
    "node_modules/lodash/_createBaseFor.js"(exports, module) {
      function createBaseFor(fromRight) {
        return function(object2, iteratee, keysFunc) {
          var index = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object2;
        };
      }
      module.exports = createBaseFor;
    }
  });

  // node_modules/lodash/_baseFor.js
  var require_baseFor = __commonJS({
    "node_modules/lodash/_baseFor.js"(exports, module) {
      var createBaseFor = require_createBaseFor();
      var baseFor = createBaseFor();
      module.exports = baseFor;
    }
  });

  // node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS({
    "node_modules/lodash/_baseTimes.js"(exports, module) {
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      module.exports = baseTimes;
    }
  });

  // node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS({
    "node_modules/lodash/stubFalse.js"(exports, module) {
      function stubFalse() {
        return false;
      }
      module.exports = stubFalse;
    }
  });

  // node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS({
    "node_modules/lodash/isBuffer.js"(exports, module) {
      var root = require_root();
      var stubFalse = require_stubFalse();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      module.exports = isBuffer;
    }
  });

  // node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS({
    "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isLength = require_isLength();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      module.exports = baseIsTypedArray;
    }
  });

  // node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS({
    "node_modules/lodash/_baseUnary.js"(exports, module) {
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      module.exports = baseUnary;
    }
  });

  // node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS({
    "node_modules/lodash/_nodeUtil.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      module.exports = nodeUtil;
    }
  });

  // node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS({
    "node_modules/lodash/isTypedArray.js"(exports, module) {
      var baseIsTypedArray = require_baseIsTypedArray();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module.exports = isTypedArray;
    }
  });

  // node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS({
    "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
      var baseTimes = require_baseTimes();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isIndex = require_isIndex();
      var isTypedArray = require_isTypedArray();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = arrayLikeKeys;
    }
  });

  // node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS({
    "node_modules/lodash/_isPrototype.js"(exports, module) {
      var objectProto = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      module.exports = isPrototype;
    }
  });

  // node_modules/lodash/_overArg.js
  var require_overArg = __commonJS({
    "node_modules/lodash/_overArg.js"(exports, module) {
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      module.exports = overArg;
    }
  });

  // node_modules/lodash/_nativeKeys.js
  var require_nativeKeys = __commonJS({
    "node_modules/lodash/_nativeKeys.js"(exports, module) {
      var overArg = require_overArg();
      var nativeKeys = overArg(Object.keys, Object);
      module.exports = nativeKeys;
    }
  });

  // node_modules/lodash/_baseKeys.js
  var require_baseKeys = __commonJS({
    "node_modules/lodash/_baseKeys.js"(exports, module) {
      var isPrototype = require_isPrototype();
      var nativeKeys = require_nativeKeys();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys(object2);
        }
        var result = [];
        for (var key in Object(object2)) {
          if (hasOwnProperty.call(object2, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = baseKeys;
    }
  });

  // node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "node_modules/lodash/isArrayLike.js"(exports, module) {
      var isFunction = require_isFunction();
      var isLength = require_isLength();
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      module.exports = isArrayLike;
    }
  });

  // node_modules/lodash/keys.js
  var require_keys = __commonJS({
    "node_modules/lodash/keys.js"(exports, module) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeys = require_baseKeys();
      var isArrayLike = require_isArrayLike();
      function keys(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      module.exports = keys;
    }
  });

  // node_modules/lodash/_baseForOwn.js
  var require_baseForOwn = __commonJS({
    "node_modules/lodash/_baseForOwn.js"(exports, module) {
      var baseFor = require_baseFor();
      var keys = require_keys();
      function baseForOwn(object2, iteratee) {
        return object2 && baseFor(object2, iteratee, keys);
      }
      module.exports = baseForOwn;
    }
  });

  // node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS({
    "node_modules/lodash/_stackClear.js"(exports, module) {
      var ListCache = require_ListCache();
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      module.exports = stackClear;
    }
  });

  // node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS({
    "node_modules/lodash/_stackDelete.js"(exports, module) {
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      module.exports = stackDelete;
    }
  });

  // node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS({
    "node_modules/lodash/_stackGet.js"(exports, module) {
      function stackGet(key) {
        return this.__data__.get(key);
      }
      module.exports = stackGet;
    }
  });

  // node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS({
    "node_modules/lodash/_stackHas.js"(exports, module) {
      function stackHas(key) {
        return this.__data__.has(key);
      }
      module.exports = stackHas;
    }
  });

  // node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS({
    "node_modules/lodash/_stackSet.js"(exports, module) {
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      var MapCache = require_MapCache();
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      module.exports = stackSet;
    }
  });

  // node_modules/lodash/_Stack.js
  var require_Stack = __commonJS({
    "node_modules/lodash/_Stack.js"(exports, module) {
      var ListCache = require_ListCache();
      var stackClear = require_stackClear();
      var stackDelete = require_stackDelete();
      var stackGet = require_stackGet();
      var stackHas = require_stackHas();
      var stackSet = require_stackSet();
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      module.exports = Stack;
    }
  });

  // node_modules/lodash/_setCacheAdd.js
  var require_setCacheAdd = __commonJS({
    "node_modules/lodash/_setCacheAdd.js"(exports, module) {
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      module.exports = setCacheAdd;
    }
  });

  // node_modules/lodash/_setCacheHas.js
  var require_setCacheHas = __commonJS({
    "node_modules/lodash/_setCacheHas.js"(exports, module) {
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      module.exports = setCacheHas;
    }
  });

  // node_modules/lodash/_SetCache.js
  var require_SetCache = __commonJS({
    "node_modules/lodash/_SetCache.js"(exports, module) {
      var MapCache = require_MapCache();
      var setCacheAdd = require_setCacheAdd();
      var setCacheHas = require_setCacheHas();
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      module.exports = SetCache;
    }
  });

  // node_modules/lodash/_arraySome.js
  var require_arraySome = __commonJS({
    "node_modules/lodash/_arraySome.js"(exports, module) {
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      module.exports = arraySome;
    }
  });

  // node_modules/lodash/_cacheHas.js
  var require_cacheHas = __commonJS({
    "node_modules/lodash/_cacheHas.js"(exports, module) {
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      module.exports = cacheHas;
    }
  });

  // node_modules/lodash/_equalArrays.js
  var require_equalArrays = __commonJS({
    "node_modules/lodash/_equalArrays.js"(exports, module) {
      var SetCache = require_SetCache();
      var arraySome = require_arraySome();
      var cacheHas = require_cacheHas();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array2);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array2;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array2, other);
        stack.set(other, array2);
        while (++index < arrLength) {
          var arrValue = array2[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array2);
        stack["delete"](other);
        return result;
      }
      module.exports = equalArrays;
    }
  });

  // node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS({
    "node_modules/lodash/_Uint8Array.js"(exports, module) {
      var root = require_root();
      var Uint8Array2 = root.Uint8Array;
      module.exports = Uint8Array2;
    }
  });

  // node_modules/lodash/_mapToArray.js
  var require_mapToArray = __commonJS({
    "node_modules/lodash/_mapToArray.js"(exports, module) {
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      module.exports = mapToArray;
    }
  });

  // node_modules/lodash/_setToArray.js
  var require_setToArray = __commonJS({
    "node_modules/lodash/_setToArray.js"(exports, module) {
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      module.exports = setToArray;
    }
  });

  // node_modules/lodash/_equalByTag.js
  var require_equalByTag = __commonJS({
    "node_modules/lodash/_equalByTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var Uint8Array2 = require_Uint8Array();
      var eq = require_eq();
      var equalArrays = require_equalArrays();
      var mapToArray = require_mapToArray();
      var setToArray = require_setToArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object2, other);
            var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      module.exports = equalByTag;
    }
  });

  // node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS({
    "node_modules/lodash/_arrayPush.js"(exports, module) {
      function arrayPush(array2, values) {
        var index = -1, length = values.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values[index];
        }
        return array2;
      }
      module.exports = arrayPush;
    }
  });

  // node_modules/lodash/_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS({
    "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var isArray = require_isArray();
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result = keysFunc(object2);
        return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
      }
      module.exports = baseGetAllKeys;
    }
  });

  // node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "node_modules/lodash/_arrayFilter.js"(exports, module) {
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module.exports = arrayFilter;
    }
  });

  // node_modules/lodash/stubArray.js
  var require_stubArray = __commonJS({
    "node_modules/lodash/stubArray.js"(exports, module) {
      function stubArray() {
        return [];
      }
      module.exports = stubArray;
    }
  });

  // node_modules/lodash/_getSymbols.js
  var require_getSymbols = __commonJS({
    "node_modules/lodash/_getSymbols.js"(exports, module) {
      var arrayFilter = require_arrayFilter();
      var stubArray = require_stubArray();
      var objectProto = Object.prototype;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object(object2);
        return arrayFilter(nativeGetSymbols(object2), function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        });
      };
      module.exports = getSymbols;
    }
  });

  // node_modules/lodash/_getAllKeys.js
  var require_getAllKeys = __commonJS({
    "node_modules/lodash/_getAllKeys.js"(exports, module) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbols = require_getSymbols();
      var keys = require_keys();
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys, getSymbols);
      }
      module.exports = getAllKeys;
    }
  });

  // node_modules/lodash/_equalObjects.js
  var require_equalObjects = __commonJS({
    "node_modules/lodash/_equalObjects.js"(exports, module) {
      var getAllKeys = require_getAllKeys();
      var COMPARE_PARTIAL_FLAG = 1;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object2);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object2;
        }
        var result = true;
        stack.set(object2, other);
        stack.set(other, object2);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object2[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object2);
        stack["delete"](other);
        return result;
      }
      module.exports = equalObjects;
    }
  });

  // node_modules/lodash/_DataView.js
  var require_DataView = __commonJS({
    "node_modules/lodash/_DataView.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var DataView = getNative(root, "DataView");
      module.exports = DataView;
    }
  });

  // node_modules/lodash/_Promise.js
  var require_Promise = __commonJS({
    "node_modules/lodash/_Promise.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Promise2 = getNative(root, "Promise");
      module.exports = Promise2;
    }
  });

  // node_modules/lodash/_Set.js
  var require_Set = __commonJS({
    "node_modules/lodash/_Set.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Set2 = getNative(root, "Set");
      module.exports = Set2;
    }
  });

  // node_modules/lodash/_WeakMap.js
  var require_WeakMap = __commonJS({
    "node_modules/lodash/_WeakMap.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var WeakMap2 = getNative(root, "WeakMap");
      module.exports = WeakMap2;
    }
  });

  // node_modules/lodash/_getTag.js
  var require_getTag = __commonJS({
    "node_modules/lodash/_getTag.js"(exports, module) {
      var DataView = require_DataView();
      var Map2 = require_Map();
      var Promise2 = require_Promise();
      var Set2 = require_Set();
      var WeakMap2 = require_WeakMap();
      var baseGetTag = require_baseGetTag();
      var toSource = require_toSource();
      var mapTag = "[object Map]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag = "[object Set]";
      var weakMapTag = "[object WeakMap]";
      var dataViewTag = "[object DataView]";
      var dataViewCtorString = toSource(DataView);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      module.exports = getTag;
    }
  });

  // node_modules/lodash/_baseIsEqualDeep.js
  var require_baseIsEqualDeep = __commonJS({
    "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
      var Stack = require_Stack();
      var equalArrays = require_equalArrays();
      var equalByTag = require_equalByTag();
      var equalObjects = require_equalObjects();
      var getTag = require_getTag();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isTypedArray = require_isTypedArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object2)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
      }
      module.exports = baseIsEqualDeep;
    }
  });

  // node_modules/lodash/_baseIsEqual.js
  var require_baseIsEqual = __commonJS({
    "node_modules/lodash/_baseIsEqual.js"(exports, module) {
      var baseIsEqualDeep = require_baseIsEqualDeep();
      var isObjectLike = require_isObjectLike();
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      module.exports = baseIsEqual;
    }
  });

  // node_modules/lodash/_baseIsMatch.js
  var require_baseIsMatch = __commonJS({
    "node_modules/lodash/_baseIsMatch.js"(exports, module) {
      var Stack = require_Stack();
      var baseIsEqual = require_baseIsEqual();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseIsMatch(object2, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object2 == null) {
          return !length;
        }
        object2 = Object(object2);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object2[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object2)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object2, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      module.exports = baseIsMatch;
    }
  });

  // node_modules/lodash/_isStrictComparable.js
  var require_isStrictComparable = __commonJS({
    "node_modules/lodash/_isStrictComparable.js"(exports, module) {
      var isObject2 = require_isObject();
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      module.exports = isStrictComparable;
    }
  });

  // node_modules/lodash/_getMatchData.js
  var require_getMatchData = __commonJS({
    "node_modules/lodash/_getMatchData.js"(exports, module) {
      var isStrictComparable = require_isStrictComparable();
      var keys = require_keys();
      function getMatchData(object2) {
        var result = keys(object2), length = result.length;
        while (length--) {
          var key = result[length], value = object2[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      module.exports = getMatchData;
    }
  });

  // node_modules/lodash/_matchesStrictComparable.js
  var require_matchesStrictComparable = __commonJS({
    "node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
      function matchesStrictComparable(key, srcValue) {
        return function(object2) {
          if (object2 == null) {
            return false;
          }
          return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
        };
      }
      module.exports = matchesStrictComparable;
    }
  });

  // node_modules/lodash/_baseMatches.js
  var require_baseMatches = __commonJS({
    "node_modules/lodash/_baseMatches.js"(exports, module) {
      var baseIsMatch = require_baseIsMatch();
      var getMatchData = require_getMatchData();
      var matchesStrictComparable = require_matchesStrictComparable();
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object2) {
          return object2 === source || baseIsMatch(object2, source, matchData);
        };
      }
      module.exports = baseMatches;
    }
  });

  // node_modules/lodash/_baseGet.js
  var require_baseGet = __commonJS({
    "node_modules/lodash/_baseGet.js"(exports, module) {
      var castPath = require_castPath();
      var toKey = require_toKey();
      function baseGet(object2, path) {
        path = castPath(path, object2);
        var index = 0, length = path.length;
        while (object2 != null && index < length) {
          object2 = object2[toKey(path[index++])];
        }
        return index && index == length ? object2 : void 0;
      }
      module.exports = baseGet;
    }
  });

  // node_modules/lodash/get.js
  var require_get = __commonJS({
    "node_modules/lodash/get.js"(exports, module) {
      var baseGet = require_baseGet();
      function get(object2, path, defaultValue) {
        var result = object2 == null ? void 0 : baseGet(object2, path);
        return result === void 0 ? defaultValue : result;
      }
      module.exports = get;
    }
  });

  // node_modules/lodash/_baseHasIn.js
  var require_baseHasIn = __commonJS({
    "node_modules/lodash/_baseHasIn.js"(exports, module) {
      function baseHasIn(object2, key) {
        return object2 != null && key in Object(object2);
      }
      module.exports = baseHasIn;
    }
  });

  // node_modules/lodash/hasIn.js
  var require_hasIn = __commonJS({
    "node_modules/lodash/hasIn.js"(exports, module) {
      var baseHasIn = require_baseHasIn();
      var hasPath = require_hasPath();
      function hasIn(object2, path) {
        return object2 != null && hasPath(object2, path, baseHasIn);
      }
      module.exports = hasIn;
    }
  });

  // node_modules/lodash/_baseMatchesProperty.js
  var require_baseMatchesProperty = __commonJS({
    "node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
      var baseIsEqual = require_baseIsEqual();
      var get = require_get();
      var hasIn = require_hasIn();
      var isKey = require_isKey();
      var isStrictComparable = require_isStrictComparable();
      var matchesStrictComparable = require_matchesStrictComparable();
      var toKey = require_toKey();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object2) {
          var objValue = get(object2, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      module.exports = baseMatchesProperty;
    }
  });

  // node_modules/lodash/identity.js
  var require_identity = __commonJS({
    "node_modules/lodash/identity.js"(exports, module) {
      function identity(value) {
        return value;
      }
      module.exports = identity;
    }
  });

  // node_modules/lodash/_baseProperty.js
  var require_baseProperty = __commonJS({
    "node_modules/lodash/_baseProperty.js"(exports, module) {
      function baseProperty(key) {
        return function(object2) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      module.exports = baseProperty;
    }
  });

  // node_modules/lodash/_basePropertyDeep.js
  var require_basePropertyDeep = __commonJS({
    "node_modules/lodash/_basePropertyDeep.js"(exports, module) {
      var baseGet = require_baseGet();
      function basePropertyDeep(path) {
        return function(object2) {
          return baseGet(object2, path);
        };
      }
      module.exports = basePropertyDeep;
    }
  });

  // node_modules/lodash/property.js
  var require_property = __commonJS({
    "node_modules/lodash/property.js"(exports, module) {
      var baseProperty = require_baseProperty();
      var basePropertyDeep = require_basePropertyDeep();
      var isKey = require_isKey();
      var toKey = require_toKey();
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      module.exports = property;
    }
  });

  // node_modules/lodash/_baseIteratee.js
  var require_baseIteratee = __commonJS({
    "node_modules/lodash/_baseIteratee.js"(exports, module) {
      var baseMatches = require_baseMatches();
      var baseMatchesProperty = require_baseMatchesProperty();
      var identity = require_identity();
      var isArray = require_isArray();
      var property = require_property();
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      module.exports = baseIteratee;
    }
  });

  // node_modules/lodash/mapValues.js
  var require_mapValues = __commonJS({
    "node_modules/lodash/mapValues.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var baseForOwn = require_baseForOwn();
      var baseIteratee = require_baseIteratee();
      function mapValues3(object2, iteratee) {
        var result = {};
        iteratee = baseIteratee(iteratee, 3);
        baseForOwn(object2, function(value, key, object3) {
          baseAssignValue(result, key, iteratee(value, key, object3));
        });
        return result;
      }
      module.exports = mapValues3;
    }
  });

  // node_modules/property-expr/index.js
  var require_property_expr = __commonJS({
    "node_modules/property-expr/index.js"(exports, module) {
      "use strict";
      function Cache(maxSize) {
        this._maxSize = maxSize;
        this.clear();
      }
      Cache.prototype.clear = function() {
        this._size = 0;
        this._values = /* @__PURE__ */ Object.create(null);
      };
      Cache.prototype.get = function(key) {
        return this._values[key];
      };
      Cache.prototype.set = function(key, value) {
        this._size >= this._maxSize && this.clear();
        if (!(key in this._values))
          this._size++;
        return this._values[key] = value;
      };
      var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g;
      var DIGIT_REGEX = /^\d+$/;
      var LEAD_DIGIT_REGEX = /^\d/;
      var SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g;
      var CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/;
      var MAX_CACHE_SIZE = 512;
      var pathCache = new Cache(MAX_CACHE_SIZE);
      var setCache = new Cache(MAX_CACHE_SIZE);
      var getCache = new Cache(MAX_CACHE_SIZE);
      module.exports = {
        Cache,
        split: split2,
        normalizePath,
        setter: function(path) {
          var parts = normalizePath(path);
          return setCache.get(path) || setCache.set(path, function setter(obj, value) {
            var index = 0;
            var len = parts.length;
            var data = obj;
            while (index < len - 1) {
              var part = parts[index];
              if (part === "__proto__" || part === "constructor" || part === "prototype") {
                return obj;
              }
              data = data[parts[index++]];
            }
            data[parts[index]] = value;
          });
        },
        getter: function(path, safe) {
          var parts = normalizePath(path);
          return getCache.get(path) || getCache.set(path, function getter3(data) {
            var index = 0, len = parts.length;
            while (index < len) {
              if (data != null || !safe)
                data = data[parts[index++]];
              else
                return;
            }
            return data;
          });
        },
        join: function(segments) {
          return segments.reduce(function(path, part) {
            return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
          }, "");
        },
        forEach: function(path, cb, thisArg) {
          forEach2(Array.isArray(path) ? path : split2(path), cb, thisArg);
        }
      };
      function normalizePath(path) {
        return pathCache.get(path) || pathCache.set(path, split2(path).map(function(part) {
          return part.replace(CLEAN_QUOTES_REGEX, "$2");
        }));
      }
      function split2(path) {
        return path.match(SPLIT_REGEX) || [""];
      }
      function forEach2(parts, iter, thisArg) {
        var len = parts.length, part, idx, isArray, isBracket;
        for (idx = 0; idx < len; idx++) {
          part = parts[idx];
          if (part) {
            if (shouldBeQuoted(part)) {
              part = '"' + part + '"';
            }
            isBracket = isQuoted(part);
            isArray = !isBracket && /^\d+$/.test(part);
            iter.call(thisArg, part, isBracket, isArray, idx, parts);
          }
        }
      }
      function isQuoted(str) {
        return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
      }
      function hasLeadingNumber(part) {
        return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
      }
      function hasSpecialChars(part) {
        return SPEC_CHAR_REGEX.test(part);
      }
      function shouldBeQuoted(part) {
        return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
      }
    }
  });

  // node_modules/lodash/_arrayReduce.js
  var require_arrayReduce = __commonJS({
    "node_modules/lodash/_arrayReduce.js"(exports, module) {
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      module.exports = arrayReduce;
    }
  });

  // node_modules/lodash/_basePropertyOf.js
  var require_basePropertyOf = __commonJS({
    "node_modules/lodash/_basePropertyOf.js"(exports, module) {
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      module.exports = basePropertyOf;
    }
  });

  // node_modules/lodash/_deburrLetter.js
  var require_deburrLetter = __commonJS({
    "node_modules/lodash/_deburrLetter.js"(exports, module) {
      var basePropertyOf = require_basePropertyOf();
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var deburrLetter = basePropertyOf(deburredLetters);
      module.exports = deburrLetter;
    }
  });

  // node_modules/lodash/deburr.js
  var require_deburr = __commonJS({
    "node_modules/lodash/deburr.js"(exports, module) {
      var deburrLetter = require_deburrLetter();
      var toString2 = require_toString();
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsCombo = "[" + rsComboRange + "]";
      var reComboMark = RegExp(rsCombo, "g");
      function deburr(string2) {
        string2 = toString2(string2);
        return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      module.exports = deburr;
    }
  });

  // node_modules/lodash/_asciiWords.js
  var require_asciiWords = __commonJS({
    "node_modules/lodash/_asciiWords.js"(exports, module) {
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      module.exports = asciiWords;
    }
  });

  // node_modules/lodash/_hasUnicodeWord.js
  var require_hasUnicodeWord = __commonJS({
    "node_modules/lodash/_hasUnicodeWord.js"(exports, module) {
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      module.exports = hasUnicodeWord;
    }
  });

  // node_modules/lodash/_unicodeWords.js
  var require_unicodeWords = __commonJS({
    "node_modules/lodash/_unicodeWords.js"(exports, module) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsDingbatRange = "\\u2700-\\u27bf";
      var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
      var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
      var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
      var rsPunctuationRange = "\\u2000-\\u206f";
      var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
      var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]";
      var rsBreak = "[" + rsBreakRange + "]";
      var rsCombo = "[" + rsComboRange + "]";
      var rsDigits = "\\d+";
      var rsDingbat = "[" + rsDingbatRange + "]";
      var rsLower = "[" + rsLowerRange + "]";
      var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsUpper = "[" + rsUpperRange + "]";
      var rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
      var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
      var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
      var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
      var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      module.exports = unicodeWords;
    }
  });

  // node_modules/lodash/words.js
  var require_words = __commonJS({
    "node_modules/lodash/words.js"(exports, module) {
      var asciiWords = require_asciiWords();
      var hasUnicodeWord = require_hasUnicodeWord();
      var toString2 = require_toString();
      var unicodeWords = require_unicodeWords();
      function words(string2, pattern, guard) {
        string2 = toString2(string2);
        pattern = guard ? void 0 : pattern;
        if (pattern === void 0) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern) || [];
      }
      module.exports = words;
    }
  });

  // node_modules/lodash/_createCompounder.js
  var require_createCompounder = __commonJS({
    "node_modules/lodash/_createCompounder.js"(exports, module) {
      var arrayReduce = require_arrayReduce();
      var deburr = require_deburr();
      var words = require_words();
      var rsApos = "['\u2019]";
      var reApos = RegExp(rsApos, "g");
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      module.exports = createCompounder;
    }
  });

  // node_modules/lodash/snakeCase.js
  var require_snakeCase = __commonJS({
    "node_modules/lodash/snakeCase.js"(exports, module) {
      var createCompounder = require_createCompounder();
      var snakeCase2 = createCompounder(function(result, word, index) {
        return result + (index ? "_" : "") + word.toLowerCase();
      });
      module.exports = snakeCase2;
    }
  });

  // node_modules/lodash/_baseSlice.js
  var require_baseSlice = __commonJS({
    "node_modules/lodash/_baseSlice.js"(exports, module) {
      function baseSlice(array2, start, end) {
        var index = -1, length = array2.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array2[index + start];
        }
        return result;
      }
      module.exports = baseSlice;
    }
  });

  // node_modules/lodash/_castSlice.js
  var require_castSlice = __commonJS({
    "node_modules/lodash/_castSlice.js"(exports, module) {
      var baseSlice = require_baseSlice();
      function castSlice(array2, start, end) {
        var length = array2.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array2 : baseSlice(array2, start, end);
      }
      module.exports = castSlice;
    }
  });

  // node_modules/lodash/_hasUnicode.js
  var require_hasUnicode = __commonJS({
    "node_modules/lodash/_hasUnicode.js"(exports, module) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsZWJ = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      module.exports = hasUnicode;
    }
  });

  // node_modules/lodash/_asciiToArray.js
  var require_asciiToArray = __commonJS({
    "node_modules/lodash/_asciiToArray.js"(exports, module) {
      function asciiToArray(string2) {
        return string2.split("");
      }
      module.exports = asciiToArray;
    }
  });

  // node_modules/lodash/_unicodeToArray.js
  var require_unicodeToArray = __commonJS({
    "node_modules/lodash/_unicodeToArray.js"(exports, module) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsCombo = "[" + rsComboRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ = "\\u200d";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      module.exports = unicodeToArray;
    }
  });

  // node_modules/lodash/_stringToArray.js
  var require_stringToArray = __commonJS({
    "node_modules/lodash/_stringToArray.js"(exports, module) {
      var asciiToArray = require_asciiToArray();
      var hasUnicode = require_hasUnicode();
      var unicodeToArray = require_unicodeToArray();
      function stringToArray2(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      module.exports = stringToArray2;
    }
  });

  // node_modules/lodash/_createCaseFirst.js
  var require_createCaseFirst = __commonJS({
    "node_modules/lodash/_createCaseFirst.js"(exports, module) {
      var castSlice = require_castSlice();
      var hasUnicode = require_hasUnicode();
      var stringToArray2 = require_stringToArray();
      var toString2 = require_toString();
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString2(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray2(string2) : void 0;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      module.exports = createCaseFirst;
    }
  });

  // node_modules/lodash/upperFirst.js
  var require_upperFirst = __commonJS({
    "node_modules/lodash/upperFirst.js"(exports, module) {
      var createCaseFirst = require_createCaseFirst();
      var upperFirst = createCaseFirst("toUpperCase");
      module.exports = upperFirst;
    }
  });

  // node_modules/lodash/capitalize.js
  var require_capitalize = __commonJS({
    "node_modules/lodash/capitalize.js"(exports, module) {
      var toString2 = require_toString();
      var upperFirst = require_upperFirst();
      function capitalize(string2) {
        return upperFirst(toString2(string2).toLowerCase());
      }
      module.exports = capitalize;
    }
  });

  // node_modules/lodash/camelCase.js
  var require_camelCase = __commonJS({
    "node_modules/lodash/camelCase.js"(exports, module) {
      var capitalize = require_capitalize();
      var createCompounder = require_createCompounder();
      var camelCase2 = createCompounder(function(result, word, index) {
        word = word.toLowerCase();
        return result + (index ? capitalize(word) : word);
      });
      module.exports = camelCase2;
    }
  });

  // node_modules/lodash/mapKeys.js
  var require_mapKeys = __commonJS({
    "node_modules/lodash/mapKeys.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var baseForOwn = require_baseForOwn();
      var baseIteratee = require_baseIteratee();
      function mapKeys2(object2, iteratee) {
        var result = {};
        iteratee = baseIteratee(iteratee, 3);
        baseForOwn(object2, function(value, key, object3) {
          baseAssignValue(result, iteratee(value, key, object3), value);
        });
        return result;
      }
      module.exports = mapKeys2;
    }
  });

  // node_modules/toposort/index.js
  var require_toposort = __commonJS({
    "node_modules/toposort/index.js"(exports, module) {
      module.exports = function(edges) {
        return toposort2(uniqueNodes(edges), edges);
      };
      module.exports.array = toposort2;
      function toposort2(nodes, edges) {
        var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
        edges.forEach(function(edge) {
          if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
            throw new Error("Unknown node. There is an unknown node in the supplied edges.");
          }
        });
        while (i--) {
          if (!visited[i])
            visit(nodes[i], i, /* @__PURE__ */ new Set());
        }
        return sorted;
        function visit(node, i2, predecessors) {
          if (predecessors.has(node)) {
            var nodeRep;
            try {
              nodeRep = ", node was:" + JSON.stringify(node);
            } catch (e) {
              nodeRep = "";
            }
            throw new Error("Cyclic dependency" + nodeRep);
          }
          if (!nodesHash.has(node)) {
            throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
          }
          if (visited[i2])
            return;
          visited[i2] = true;
          var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
          outgoing = Array.from(outgoing);
          if (i2 = outgoing.length) {
            predecessors.add(node);
            do {
              var child = outgoing[--i2];
              visit(child, nodesHash.get(child), predecessors);
            } while (i2);
            predecessors.delete(node);
          }
          sorted[--cursor] = node;
        }
      }
      function uniqueNodes(arr) {
        var res = /* @__PURE__ */ new Set();
        for (var i = 0, len = arr.length; i < len; i++) {
          var edge = arr[i];
          res.add(edge[0]);
          res.add(edge[1]);
        }
        return Array.from(res);
      }
      function makeOutgoingEdges(arr) {
        var edges = /* @__PURE__ */ new Map();
        for (var i = 0, len = arr.length; i < len; i++) {
          var edge = arr[i];
          if (!edges.has(edge[0]))
            edges.set(edge[0], /* @__PURE__ */ new Set());
          if (!edges.has(edge[1]))
            edges.set(edge[1], /* @__PURE__ */ new Set());
          edges.get(edge[0]).add(edge[1]);
        }
        return edges;
      }
      function makeNodesHash(arr) {
        var res = /* @__PURE__ */ new Map();
        for (var i = 0, len = arr.length; i < len; i++) {
          res.set(arr[i], i);
        }
        return res;
      }
    }
  });

  // node_modules/@remix-run/cloudflare-workers/esm/worker.js
  var import_kv_asset_handler = __toESM(require_dist());
  var import_cloudflare = __toESM(require_cloudflare());
  function createRequestHandler({
    build,
    getLoadContext,
    mode
  }) {
    let handleRequest2 = (0, import_cloudflare.createRequestHandler)(build, mode);
    return (event) => {
      let loadContext = getLoadContext === null || getLoadContext === void 0 ? void 0 : getLoadContext(event);
      return handleRequest2(event.request, loadContext);
    };
  }
  async function handleAsset(event, build, options) {
    try {
      if (true) {
        return await (0, import_kv_asset_handler.getAssetFromKV)(event, {
          cacheControl: {
            bypassCache: true
          },
          ...options
        });
      }
      let cacheControl = {};
      let url = new URL(event.request.url);
      let assetpath = build.assets.url.split("/").slice(0, -1).join("/");
      let requestpath = url.pathname.split("/").slice(0, -1).join("/");
      if (requestpath.startsWith(assetpath)) {
        cacheControl = {
          bypassCache: false,
          edgeTTL: 31536e3,
          browserTTL: 31536e3
        };
      } else {
        cacheControl = {
          bypassCache: false,
          edgeTTL: 31536e3
        };
      }
      return await (0, import_kv_asset_handler.getAssetFromKV)(event, {
        cacheControl,
        ...options
      });
    } catch (error) {
      if (error instanceof import_kv_asset_handler.MethodNotAllowedError || error instanceof import_kv_asset_handler.NotFoundError) {
        return null;
      }
      throw error;
    }
  }
  function createEventHandler({
    build,
    getLoadContext,
    mode
  }) {
    let handleRequest2 = createRequestHandler({
      build,
      getLoadContext,
      mode
    });
    let handleEvent = async (event) => {
      let response = await handleAsset(event, build);
      if (!response) {
        response = await handleRequest2(event);
      }
      return response;
    };
    return (event) => {
      try {
        event.respondWith(handleEvent(event));
      } catch (e) {
        if (true) {
          event.respondWith(new Response(e.message || e.toString(), {
            status: 500
          }));
          return;
        }
        event.respondWith(new Response("Internal Error", {
          status: 500
        }));
      }
    };
  }

  // build/index.js
  var build_exports = {};
  __export(build_exports, {
    assets: () => assets_manifest_default,
    entry: () => entry,
    routes: () => routes
  });
  var React3 = __toESM(require_react());
  var import_server = __toESM(require_server_browser());
  var import_cloudflare2 = __toESM(require_cloudflare());
  var import_server_runtime = __toESM(require_server_runtime());
  var import_react3 = __toESM(require_react2());

  // node_modules/react-icons/lib/esm/iconBase.js
  var import_react2 = __toESM(require_react());

  // node_modules/react-icons/lib/esm/iconContext.js
  var import_react = __toESM(require_react());
  var DefaultContext = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0
  };
  var IconContext = import_react.default.createContext && import_react.default.createContext(DefaultContext);

  // node_modules/react-icons/lib/esm/iconBase.js
  var __assign = function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __rest = function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  function Tree2Element(tree) {
    return tree && tree.map(function(node, i) {
      return import_react2.default.createElement(node.tag, __assign({
        key: i
      }, node.attr), Tree2Element(node.child));
    });
  }
  function GenIcon(data) {
    return function(props) {
      return import_react2.default.createElement(IconBase, __assign({
        attr: __assign({}, data.attr)
      }, props), Tree2Element(data.child));
    };
  }
  function IconBase(props) {
    var elem = function(conf) {
      var attr = props.attr, size = props.size, title = props.title, svgProps = __rest(props, ["attr", "size", "title"]);
      var computedSize = size || conf.size || "1em";
      var className;
      if (conf.className)
        className = conf.className;
      if (props.className)
        className = (className ? className + " " : "") + props.className;
      return import_react2.default.createElement("svg", __assign({
        stroke: "currentColor",
        fill: "currentColor",
        strokeWidth: "0"
      }, conf.attr, attr, svgProps, {
        className,
        style: __assign(__assign({
          color: props.color || conf.color
        }, conf.style), props.style),
        height: computedSize,
        width: computedSize,
        xmlns: "http://www.w3.org/2000/svg"
      }), title && import_react2.default.createElement("title", null, title), props.children);
    };
    return IconContext !== void 0 ? import_react2.default.createElement(IconContext.Consumer, null, function(conf) {
      return elem(conf);
    }) : elem(DefaultContext);
  }

  // node_modules/react-icons/ti/index.esm.js
  function TiArrowRightThick(props) {
    return GenIcon({ "tag": "svg", "attr": { "version": "1.2", "baseProfile": "tiny", "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M10.586 6.586c-.781.779-.781 2.047 0 2.828l1.586 1.586h-7.244c-1.104 0-2 .895-2 2 0 1.104.896 2 2 2h7.244l-1.586 1.586c-.781.779-.781 2.047 0 2.828.391.391.902.586 1.414.586s1.023-.195 1.414-.586l6.414-6.414-6.414-6.414c-.781-.781-2.047-.781-2.828 0z" } }] })(props);
  }
  function TiDeleteOutline(props) {
    return GenIcon({ "tag": "svg", "attr": { "version": "1.2", "baseProfile": "tiny", "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M12 3c-4.963 0-9 4.038-9 9s4.037 9 9 9 9-4.038 9-9-4.037-9-9-9zm0 16c-3.859 0-7-3.14-7-7s3.141-7 7-7 7 3.14 7 7-3.141 7-7 7zM12.707 12l2.646-2.646c.194-.194.194-.512 0-.707-.195-.194-.513-.194-.707 0l-2.646 2.646-2.646-2.647c-.195-.194-.513-.194-.707 0-.195.195-.195.513 0 .707l2.646 2.647-2.646 2.646c-.195.195-.195.513 0 .707.097.098.225.147.353.147s.256-.049.354-.146l2.646-2.647 2.646 2.646c.098.098.226.147.354.147s.256-.049.354-.146c.194-.194.194-.512 0-.707l-2.647-2.647z" } }] })(props);
  }
  function TiPlus(props) {
    return GenIcon({ "tag": "svg", "attr": { "version": "1.2", "baseProfile": "tiny", "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M18 10h-4v-4c0-1.104-.896-2-2-2s-2 .896-2 2l.071 4h-4.071c-1.104 0-2 .896-2 2s.896 2 2 2l4.071-.071-.071 4.071c0 1.104.896 2 2 2s2-.896 2-2v-4.071l4 .071c1.104 0 2-.896 2-2s-.896-2-2-2z" } }] })(props);
  }

  // node_modules/react-icons/hi/index.esm.js
  function HiTrendingDown(props) {
    return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M12 13a1 1 0 100 2h5a1 1 0 001-1V9a1 1 0 10-2 0v2.586l-4.293-4.293a1 1 0 00-1.414 0L8 9.586 3.707 5.293a1 1 0 00-1.414 1.414l5 5a1 1 0 001.414 0L11 9.414 14.586 13H12z", "clipRule": "evenodd" } }] })(props);
  }

  // node_modules/react-icons/ai/index.esm.js
  function AiFillSave(props) {
    return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 1024 1024" }, "child": [{ "tag": "path", "attr": { "d": "M893.3 293.3L730.7 130.7c-12-12-28.3-18.7-45.3-18.7H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V338.5c0-17-6.7-33.2-18.7-45.2zM384 176h256v112H384V176zm128 554c-79.5 0-144-64.5-144-144s64.5-144 144-144 144 64.5 144 144-64.5 144-144 144zm0-224c-44.2 0-80 35.8-80 80s35.8 80 80 80 80-35.8 80-80-35.8-80-80-80z" } }] })(props);
  }

  // build/index.js
  var import_remix_validated_form2 = __toESM(require_remix_validated_form_cjs());

  // node_modules/@remix-validated-form/with-yup/browser/index.js
  var import_remix_validated_form = __toESM(require_remix_validated_form_cjs());
  var validationErrorToFieldErrors = (error) => {
    const fieldErrors = {};
    error.inner.forEach((innerError) => {
      if (!innerError.path)
        return;
      fieldErrors[innerError.path] = innerError.message;
    });
    return fieldErrors;
  };
  var withYup = (validationSchema) => {
    return (0, import_remix_validated_form.createValidator)({
      validate: async (data) => {
        try {
          const validated = await validationSchema.validate(data, {
            abortEarly: false
          });
          return { data: validated, error: void 0 };
        } catch (err) {
          return {
            error: validationErrorToFieldErrors(err),
            data: void 0
          };
        }
      },
      validateField: async (data, field) => {
        try {
          await validationSchema.validateAt(field, data);
          return {};
        } catch (err) {
          return { error: err.message };
        }
      }
    });
  };

  // build/index.js
  var import_spark_md5 = __toESM(require_spark_md5());
  var import_react4 = __toESM(require_react());

  // node_modules/clsx/dist/clsx.m.js
  function toVal(mix) {
    var k, y, str = "";
    if (typeof mix === "string" || typeof mix === "number") {
      str += mix;
    } else if (typeof mix === "object") {
      if (Array.isArray(mix)) {
        for (k = 0; k < mix.length; k++) {
          if (mix[k]) {
            if (y = toVal(mix[k])) {
              str && (str += " ");
              str += y;
            }
          }
        }
      } else {
        for (k in mix) {
          if (mix[k]) {
            str && (str += " ");
            str += k;
          }
        }
      }
    }
    return str;
  }
  function clsx_m_default() {
    var i = 0, tmp, x, str = "";
    while (i < arguments.length) {
      if (tmp = arguments[i++]) {
        if (x = toVal(tmp)) {
          str && (str += " ");
          str += x;
        }
      }
    }
    return str;
  }

  // node_modules/nanoclone/src/index.js
  var map;
  try {
    map = Map;
  } catch (_) {
  }
  var set;
  try {
    set = Set;
  } catch (_) {
  }
  function baseClone(src, circulars, clones) {
    if (!src || typeof src !== "object" || typeof src === "function") {
      return src;
    }
    if (src.nodeType && "cloneNode" in src) {
      return src.cloneNode(true);
    }
    if (src instanceof Date) {
      return new Date(src.getTime());
    }
    if (src instanceof RegExp) {
      return new RegExp(src);
    }
    if (Array.isArray(src)) {
      return src.map(clone);
    }
    if (map && src instanceof map) {
      return new Map(Array.from(src.entries()));
    }
    if (set && src instanceof set) {
      return new Set(Array.from(src.values()));
    }
    if (src instanceof Object) {
      circulars.push(src);
      var obj = Object.create(src);
      clones.push(obj);
      for (var key in src) {
        var idx = circulars.findIndex(function(i) {
          return i === src[key];
        });
        obj[key] = idx > -1 ? clones[idx] : baseClone(src[key], circulars, clones);
      }
      return obj;
    }
    return src;
  }
  function clone(src) {
    return baseClone(src, [], []);
  }

  // node_modules/yup/es/util/printValue.js
  var toString = Object.prototype.toString;
  var errorToString = Error.prototype.toString;
  var regExpToString = RegExp.prototype.toString;
  var symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
  var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
  function printNumber(val) {
    if (val != +val)
      return "NaN";
    const isNegativeZero = val === 0 && 1 / val < 0;
    return isNegativeZero ? "-0" : "" + val;
  }
  function printSimpleValue(val, quoteStrings = false) {
    if (val == null || val === true || val === false)
      return "" + val;
    const typeOf = typeof val;
    if (typeOf === "number")
      return printNumber(val);
    if (typeOf === "string")
      return quoteStrings ? `"${val}"` : val;
    if (typeOf === "function")
      return "[Function " + (val.name || "anonymous") + "]";
    if (typeOf === "symbol")
      return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
    const tag = toString.call(val).slice(8, -1);
    if (tag === "Date")
      return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
    if (tag === "Error" || val instanceof Error)
      return "[" + errorToString.call(val) + "]";
    if (tag === "RegExp")
      return regExpToString.call(val);
    return null;
  }
  function printValue(value, quoteStrings) {
    let result = printSimpleValue(value, quoteStrings);
    if (result !== null)
      return result;
    return JSON.stringify(value, function(key, value2) {
      let result2 = printSimpleValue(this[key], quoteStrings);
      if (result2 !== null)
        return result2;
      return value2;
    }, 2);
  }

  // node_modules/yup/es/locale.js
  var mixed = {
    default: "${path} is invalid",
    required: "${path} is a required field",
    oneOf: "${path} must be one of the following values: ${values}",
    notOneOf: "${path} must not be one of the following values: ${values}",
    notType: ({
      path,
      type,
      value,
      originalValue
    }) => {
      let isCast = originalValue != null && originalValue !== value;
      let msg = `${path} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`` + (isCast ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".");
      if (value === null) {
        msg += `
 If "null" is intended as an empty value be sure to mark the schema as \`.nullable()\``;
      }
      return msg;
    },
    defined: "${path} must be defined"
  };
  var string = {
    length: "${path} must be exactly ${length} characters",
    min: "${path} must be at least ${min} characters",
    max: "${path} must be at most ${max} characters",
    matches: '${path} must match the following: "${regex}"',
    email: "${path} must be a valid email",
    url: "${path} must be a valid URL",
    uuid: "${path} must be a valid UUID",
    trim: "${path} must be a trimmed string",
    lowercase: "${path} must be a lowercase string",
    uppercase: "${path} must be a upper case string"
  };
  var number = {
    min: "${path} must be greater than or equal to ${min}",
    max: "${path} must be less than or equal to ${max}",
    lessThan: "${path} must be less than ${less}",
    moreThan: "${path} must be greater than ${more}",
    positive: "${path} must be a positive number",
    negative: "${path} must be a negative number",
    integer: "${path} must be an integer"
  };
  var date = {
    min: "${path} field must be later than ${min}",
    max: "${path} field must be at earlier than ${max}"
  };
  var boolean = {
    isValue: "${path} field must be ${value}"
  };
  var object = {
    noUnknown: "${path} field has unspecified keys: ${unknown}"
  };
  var array = {
    min: "${path} field must have at least ${min} items",
    max: "${path} field must have less than or equal to ${max} items",
    length: "${path} must have ${length} items"
  };
  var locale_default = Object.assign(/* @__PURE__ */ Object.create(null), {
    mixed,
    string,
    number,
    date,
    object,
    array,
    boolean
  });

  // node_modules/yup/es/Condition.js
  var import_has = __toESM(require_has());

  // node_modules/yup/es/util/isSchema.js
  var isSchema = (obj) => obj && obj.__isYupSchema__;
  var isSchema_default = isSchema;

  // node_modules/yup/es/Condition.js
  var Condition = class {
    constructor(refs, options) {
      this.fn = void 0;
      this.refs = refs;
      this.refs = refs;
      if (typeof options === "function") {
        this.fn = options;
        return;
      }
      if (!(0, import_has.default)(options, "is"))
        throw new TypeError("`is:` is required for `when()` conditions");
      if (!options.then && !options.otherwise)
        throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
      let {
        is,
        then,
        otherwise
      } = options;
      let check = typeof is === "function" ? is : (...values) => values.every((value) => value === is);
      this.fn = function(...args) {
        let options2 = args.pop();
        let schema = args.pop();
        let branch = check(...args) ? then : otherwise;
        if (!branch)
          return void 0;
        if (typeof branch === "function")
          return branch(schema);
        return schema.concat(branch.resolve(options2));
      };
    }
    resolve(base, options) {
      let values = this.refs.map((ref) => ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));
      let schema = this.fn.apply(base, values.concat(base, options));
      if (schema === void 0 || schema === base)
        return base;
      if (!isSchema_default(schema))
        throw new TypeError("conditions must return a schema object");
      return schema.resolve(options);
    }
  };
  var Condition_default = Condition;

  // node_modules/yup/es/util/toArray.js
  function toArray(value) {
    return value == null ? [] : [].concat(value);
  }

  // node_modules/yup/es/ValidationError.js
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  var strReg = /\$\{\s*(\w+)\s*\}/g;
  var ValidationError = class extends Error {
    static formatError(message, params) {
      const path = params.label || params.path || "this";
      if (path !== params.path)
        params = _extends({}, params, {
          path
        });
      if (typeof message === "string")
        return message.replace(strReg, (_, key) => printValue(params[key]));
      if (typeof message === "function")
        return message(params);
      return message;
    }
    static isError(err) {
      return err && err.name === "ValidationError";
    }
    constructor(errorOrErrors, value, field, type) {
      super();
      this.value = void 0;
      this.path = void 0;
      this.type = void 0;
      this.errors = void 0;
      this.params = void 0;
      this.inner = void 0;
      this.name = "ValidationError";
      this.value = value;
      this.path = field;
      this.type = type;
      this.errors = [];
      this.inner = [];
      toArray(errorOrErrors).forEach((err) => {
        if (ValidationError.isError(err)) {
          this.errors.push(...err.errors);
          this.inner = this.inner.concat(err.inner.length ? err.inner : err);
        } else {
          this.errors.push(err);
        }
      });
      this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ValidationError);
    }
  };

  // node_modules/yup/es/util/runTests.js
  var once = (cb) => {
    let fired = false;
    return (...args) => {
      if (fired)
        return;
      fired = true;
      cb(...args);
    };
  };
  function runTests(options, cb) {
    let {
      endEarly,
      tests,
      args,
      value,
      errors,
      sort,
      path
    } = options;
    let callback = once(cb);
    let count = tests.length;
    const nestedErrors = [];
    errors = errors ? errors : [];
    if (!count)
      return errors.length ? callback(new ValidationError(errors, value, path)) : callback(null, value);
    for (let i = 0; i < tests.length; i++) {
      const test = tests[i];
      test(args, function finishTestRun(err) {
        if (err) {
          if (!ValidationError.isError(err)) {
            return callback(err, value);
          }
          if (endEarly) {
            err.value = value;
            return callback(err, value);
          }
          nestedErrors.push(err);
        }
        if (--count <= 0) {
          if (nestedErrors.length) {
            if (sort)
              nestedErrors.sort(sort);
            if (errors.length)
              nestedErrors.push(...errors);
            errors = nestedErrors;
          }
          if (errors.length) {
            callback(new ValidationError(errors, value, path), value);
            return;
          }
          callback(null, value);
        }
      });
    }
  }

  // node_modules/yup/es/util/createValidation.js
  var import_mapValues = __toESM(require_mapValues());

  // node_modules/yup/es/Reference.js
  var import_property_expr = __toESM(require_property_expr());
  var prefixes = {
    context: "$",
    value: "."
  };
  var Reference = class {
    constructor(key, options = {}) {
      this.key = void 0;
      this.isContext = void 0;
      this.isValue = void 0;
      this.isSibling = void 0;
      this.path = void 0;
      this.getter = void 0;
      this.map = void 0;
      if (typeof key !== "string")
        throw new TypeError("ref must be a string, got: " + key);
      this.key = key.trim();
      if (key === "")
        throw new TypeError("ref must be a non-empty string");
      this.isContext = this.key[0] === prefixes.context;
      this.isValue = this.key[0] === prefixes.value;
      this.isSibling = !this.isContext && !this.isValue;
      let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
      this.path = this.key.slice(prefix.length);
      this.getter = this.path && (0, import_property_expr.getter)(this.path, true);
      this.map = options.map;
    }
    getValue(value, parent, context) {
      let result = this.isContext ? context : this.isValue ? value : parent;
      if (this.getter)
        result = this.getter(result || {});
      if (this.map)
        result = this.map(result);
      return result;
    }
    cast(value, options) {
      return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
    }
    resolve() {
      return this;
    }
    describe() {
      return {
        type: "ref",
        key: this.key
      };
    }
    toString() {
      return `Ref(${this.key})`;
    }
    static isRef(value) {
      return value && value.__isYupRef;
    }
  };
  Reference.prototype.__isYupRef = true;

  // node_modules/yup/es/util/createValidation.js
  function _extends2() {
    _extends2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function createValidation(config) {
    function validate(_ref, cb) {
      let {
        value,
        path = "",
        label,
        options,
        originalValue,
        sync
      } = _ref, rest = _objectWithoutPropertiesLoose(_ref, ["value", "path", "label", "options", "originalValue", "sync"]);
      const {
        name,
        test,
        params,
        message
      } = config;
      let {
        parent,
        context
      } = options;
      function resolve(item) {
        return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
      }
      function createError(overrides = {}) {
        const nextParams = (0, import_mapValues.default)(_extends2({
          value,
          originalValue,
          label,
          path: overrides.path || path
        }, params, overrides.params), resolve);
        const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name);
        error.params = nextParams;
        return error;
      }
      let ctx = _extends2({
        path,
        parent,
        type: name,
        createError,
        resolve,
        options,
        originalValue
      }, rest);
      if (!sync) {
        try {
          Promise.resolve(test.call(ctx, value, ctx)).then((validOrError) => {
            if (ValidationError.isError(validOrError))
              cb(validOrError);
            else if (!validOrError)
              cb(createError());
            else
              cb(null, validOrError);
          }).catch(cb);
        } catch (err) {
          cb(err);
        }
        return;
      }
      let result;
      try {
        var _ref2;
        result = test.call(ctx, value, ctx);
        if (typeof ((_ref2 = result) == null ? void 0 : _ref2.then) === "function") {
          throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
        }
      } catch (err) {
        cb(err);
        return;
      }
      if (ValidationError.isError(result))
        cb(result);
      else if (!result)
        cb(createError());
      else
        cb(null, result);
    }
    validate.OPTIONS = config;
    return validate;
  }

  // node_modules/yup/es/util/reach.js
  var import_property_expr2 = __toESM(require_property_expr());
  var trim = (part) => part.substr(0, part.length - 1).substr(1);
  function getIn(schema, path, value, context = value) {
    let parent, lastPart, lastPartDebug;
    if (!path)
      return {
        parent,
        parentPath: path,
        schema
      };
    (0, import_property_expr2.forEach)(path, (_part, isBracket, isArray) => {
      let part = isBracket ? trim(_part) : _part;
      schema = schema.resolve({
        context,
        parent,
        value
      });
      if (schema.innerType) {
        let idx = isArray ? parseInt(part, 10) : 0;
        if (value && idx >= value.length) {
          throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. because there is no value at that index. `);
        }
        parent = value;
        value = value && value[idx];
        schema = schema.innerType;
      }
      if (!isArray) {
        if (!schema.fields || !schema.fields[part])
          throw new Error(`The schema does not contain the path: ${path}. (failed at: ${lastPartDebug} which is a type: "${schema._type}")`);
        parent = value;
        value = value && value[part];
        schema = schema.fields[part];
      }
      lastPart = part;
      lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
    });
    return {
      schema,
      parent,
      parentPath: lastPart
    };
  }

  // node_modules/yup/es/util/ReferenceSet.js
  var ReferenceSet = class {
    constructor() {
      this.list = void 0;
      this.refs = void 0;
      this.list = /* @__PURE__ */ new Set();
      this.refs = /* @__PURE__ */ new Map();
    }
    get size() {
      return this.list.size + this.refs.size;
    }
    describe() {
      const description = [];
      for (const item of this.list)
        description.push(item);
      for (const [, ref] of this.refs)
        description.push(ref.describe());
      return description;
    }
    toArray() {
      return Array.from(this.list).concat(Array.from(this.refs.values()));
    }
    resolveAll(resolve) {
      return this.toArray().reduce((acc, e) => acc.concat(Reference.isRef(e) ? resolve(e) : e), []);
    }
    add(value) {
      Reference.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);
    }
    delete(value) {
      Reference.isRef(value) ? this.refs.delete(value.key) : this.list.delete(value);
    }
    clone() {
      const next = new ReferenceSet();
      next.list = new Set(this.list);
      next.refs = new Map(this.refs);
      return next;
    }
    merge(newItems, removeItems) {
      const next = this.clone();
      newItems.list.forEach((value) => next.add(value));
      newItems.refs.forEach((value) => next.add(value));
      removeItems.list.forEach((value) => next.delete(value));
      removeItems.refs.forEach((value) => next.delete(value));
      return next;
    }
  };

  // node_modules/yup/es/schema.js
  function _extends3() {
    _extends3 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends3.apply(this, arguments);
  }
  var BaseSchema = class {
    constructor(options) {
      this.deps = [];
      this.tests = void 0;
      this.transforms = void 0;
      this.conditions = [];
      this._mutate = void 0;
      this._typeError = void 0;
      this._whitelist = new ReferenceSet();
      this._blacklist = new ReferenceSet();
      this.exclusiveTests = /* @__PURE__ */ Object.create(null);
      this.spec = void 0;
      this.tests = [];
      this.transforms = [];
      this.withMutation(() => {
        this.typeError(mixed.notType);
      });
      this.type = (options == null ? void 0 : options.type) || "mixed";
      this.spec = _extends3({
        strip: false,
        strict: false,
        abortEarly: true,
        recursive: true,
        nullable: false,
        presence: "optional"
      }, options == null ? void 0 : options.spec);
    }
    get _type() {
      return this.type;
    }
    _typeCheck(_value) {
      return true;
    }
    clone(spec) {
      if (this._mutate) {
        if (spec)
          Object.assign(this.spec, spec);
        return this;
      }
      const next = Object.create(Object.getPrototypeOf(this));
      next.type = this.type;
      next._typeError = this._typeError;
      next._whitelistError = this._whitelistError;
      next._blacklistError = this._blacklistError;
      next._whitelist = this._whitelist.clone();
      next._blacklist = this._blacklist.clone();
      next.exclusiveTests = _extends3({}, this.exclusiveTests);
      next.deps = [...this.deps];
      next.conditions = [...this.conditions];
      next.tests = [...this.tests];
      next.transforms = [...this.transforms];
      next.spec = clone(_extends3({}, this.spec, spec));
      return next;
    }
    label(label) {
      let next = this.clone();
      next.spec.label = label;
      return next;
    }
    meta(...args) {
      if (args.length === 0)
        return this.spec.meta;
      let next = this.clone();
      next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
      return next;
    }
    withMutation(fn) {
      let before = this._mutate;
      this._mutate = true;
      let result = fn(this);
      this._mutate = before;
      return result;
    }
    concat(schema) {
      if (!schema || schema === this)
        return this;
      if (schema.type !== this.type && this.type !== "mixed")
        throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
      let base = this;
      let combined = schema.clone();
      const mergedSpec = _extends3({}, base.spec, combined.spec);
      combined.spec = mergedSpec;
      combined._typeError || (combined._typeError = base._typeError);
      combined._whitelistError || (combined._whitelistError = base._whitelistError);
      combined._blacklistError || (combined._blacklistError = base._blacklistError);
      combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
      combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
      combined.tests = base.tests;
      combined.exclusiveTests = base.exclusiveTests;
      combined.withMutation((next) => {
        schema.tests.forEach((fn) => {
          next.test(fn.OPTIONS);
        });
      });
      combined.transforms = [...base.transforms, ...combined.transforms];
      return combined;
    }
    isType(v) {
      if (this.spec.nullable && v === null)
        return true;
      return this._typeCheck(v);
    }
    resolve(options) {
      let schema = this;
      if (schema.conditions.length) {
        let conditions = schema.conditions;
        schema = schema.clone();
        schema.conditions = [];
        schema = conditions.reduce((schema2, condition) => condition.resolve(schema2, options), schema);
        schema = schema.resolve(options);
      }
      return schema;
    }
    cast(value, options = {}) {
      let resolvedSchema = this.resolve(_extends3({
        value
      }, options));
      let result = resolvedSchema._cast(value, options);
      if (value !== void 0 && options.assert !== false && resolvedSchema.isType(result) !== true) {
        let formattedValue = printValue(value);
        let formattedResult = printValue(result);
        throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema._type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
      }
      return result;
    }
    _cast(rawValue, _options) {
      let value = rawValue === void 0 ? rawValue : this.transforms.reduce((value2, fn) => fn.call(this, value2, rawValue, this), rawValue);
      if (value === void 0) {
        value = this.getDefault();
      }
      return value;
    }
    _validate(_value, options = {}, cb) {
      let {
        sync,
        path,
        from = [],
        originalValue = _value,
        strict = this.spec.strict,
        abortEarly = this.spec.abortEarly
      } = options;
      let value = _value;
      if (!strict) {
        value = this._cast(value, _extends3({
          assert: false
        }, options));
      }
      let args = {
        value,
        path,
        options,
        originalValue,
        schema: this,
        label: this.spec.label,
        sync,
        from
      };
      let initialTests = [];
      if (this._typeError)
        initialTests.push(this._typeError);
      let finalTests = [];
      if (this._whitelistError)
        finalTests.push(this._whitelistError);
      if (this._blacklistError)
        finalTests.push(this._blacklistError);
      runTests({
        args,
        value,
        path,
        sync,
        tests: initialTests,
        endEarly: abortEarly
      }, (err) => {
        if (err)
          return void cb(err, value);
        runTests({
          tests: this.tests.concat(finalTests),
          args,
          path,
          sync,
          value,
          endEarly: abortEarly
        }, cb);
      });
    }
    validate(value, options, maybeCb) {
      let schema = this.resolve(_extends3({}, options, {
        value
      }));
      return typeof maybeCb === "function" ? schema._validate(value, options, maybeCb) : new Promise((resolve, reject) => schema._validate(value, options, (err, value2) => {
        if (err)
          reject(err);
        else
          resolve(value2);
      }));
    }
    validateSync(value, options) {
      let schema = this.resolve(_extends3({}, options, {
        value
      }));
      let result;
      schema._validate(value, _extends3({}, options, {
        sync: true
      }), (err, value2) => {
        if (err)
          throw err;
        result = value2;
      });
      return result;
    }
    isValid(value, options) {
      return this.validate(value, options).then(() => true, (err) => {
        if (ValidationError.isError(err))
          return false;
        throw err;
      });
    }
    isValidSync(value, options) {
      try {
        this.validateSync(value, options);
        return true;
      } catch (err) {
        if (ValidationError.isError(err))
          return false;
        throw err;
      }
    }
    _getDefault() {
      let defaultValue = this.spec.default;
      if (defaultValue == null) {
        return defaultValue;
      }
      return typeof defaultValue === "function" ? defaultValue.call(this) : clone(defaultValue);
    }
    getDefault(options) {
      let schema = this.resolve(options || {});
      return schema._getDefault();
    }
    default(def) {
      if (arguments.length === 0) {
        return this._getDefault();
      }
      let next = this.clone({
        default: def
      });
      return next;
    }
    strict(isStrict = true) {
      let next = this.clone();
      next.spec.strict = isStrict;
      return next;
    }
    _isPresent(value) {
      return value != null;
    }
    defined(message = mixed.defined) {
      return this.test({
        message,
        name: "defined",
        exclusive: true,
        test(value) {
          return value !== void 0;
        }
      });
    }
    required(message = mixed.required) {
      return this.clone({
        presence: "required"
      }).withMutation((s) => s.test({
        message,
        name: "required",
        exclusive: true,
        test(value) {
          return this.schema._isPresent(value);
        }
      }));
    }
    notRequired() {
      let next = this.clone({
        presence: "optional"
      });
      next.tests = next.tests.filter((test) => test.OPTIONS.name !== "required");
      return next;
    }
    nullable(isNullable = true) {
      let next = this.clone({
        nullable: isNullable !== false
      });
      return next;
    }
    transform(fn) {
      let next = this.clone();
      next.transforms.push(fn);
      return next;
    }
    test(...args) {
      let opts;
      if (args.length === 1) {
        if (typeof args[0] === "function") {
          opts = {
            test: args[0]
          };
        } else {
          opts = args[0];
        }
      } else if (args.length === 2) {
        opts = {
          name: args[0],
          test: args[1]
        };
      } else {
        opts = {
          name: args[0],
          message: args[1],
          test: args[2]
        };
      }
      if (opts.message === void 0)
        opts.message = mixed.default;
      if (typeof opts.test !== "function")
        throw new TypeError("`test` is a required parameters");
      let next = this.clone();
      let validate = createValidation(opts);
      let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
      if (opts.exclusive) {
        if (!opts.name)
          throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
      }
      if (opts.name)
        next.exclusiveTests[opts.name] = !!opts.exclusive;
      next.tests = next.tests.filter((fn) => {
        if (fn.OPTIONS.name === opts.name) {
          if (isExclusive)
            return false;
          if (fn.OPTIONS.test === validate.OPTIONS.test)
            return false;
        }
        return true;
      });
      next.tests.push(validate);
      return next;
    }
    when(keys, options) {
      if (!Array.isArray(keys) && typeof keys !== "string") {
        options = keys;
        keys = ".";
      }
      let next = this.clone();
      let deps = toArray(keys).map((key) => new Reference(key));
      deps.forEach((dep) => {
        if (dep.isSibling)
          next.deps.push(dep.key);
      });
      next.conditions.push(new Condition_default(deps, options));
      return next;
    }
    typeError(message) {
      let next = this.clone();
      next._typeError = createValidation({
        message,
        name: "typeError",
        test(value) {
          if (value !== void 0 && !this.schema.isType(value))
            return this.createError({
              params: {
                type: this.schema._type
              }
            });
          return true;
        }
      });
      return next;
    }
    oneOf(enums, message = mixed.oneOf) {
      let next = this.clone();
      enums.forEach((val) => {
        next._whitelist.add(val);
        next._blacklist.delete(val);
      });
      next._whitelistError = createValidation({
        message,
        name: "oneOf",
        test(value) {
          if (value === void 0)
            return true;
          let valids = this.schema._whitelist;
          let resolved = valids.resolveAll(this.resolve);
          return resolved.includes(value) ? true : this.createError({
            params: {
              values: valids.toArray().join(", "),
              resolved
            }
          });
        }
      });
      return next;
    }
    notOneOf(enums, message = mixed.notOneOf) {
      let next = this.clone();
      enums.forEach((val) => {
        next._blacklist.add(val);
        next._whitelist.delete(val);
      });
      next._blacklistError = createValidation({
        message,
        name: "notOneOf",
        test(value) {
          let invalids = this.schema._blacklist;
          let resolved = invalids.resolveAll(this.resolve);
          if (resolved.includes(value))
            return this.createError({
              params: {
                values: invalids.toArray().join(", "),
                resolved
              }
            });
          return true;
        }
      });
      return next;
    }
    strip(strip = true) {
      let next = this.clone();
      next.spec.strip = strip;
      return next;
    }
    describe() {
      const next = this.clone();
      const {
        label,
        meta: meta2
      } = next.spec;
      const description = {
        meta: meta2,
        label,
        type: next.type,
        oneOf: next._whitelist.describe(),
        notOneOf: next._blacklist.describe(),
        tests: next.tests.map((fn) => ({
          name: fn.OPTIONS.name,
          params: fn.OPTIONS.params
        })).filter((n, idx, list) => list.findIndex((c) => c.name === n.name) === idx)
      };
      return description;
    }
  };
  BaseSchema.prototype.__isYupSchema__ = true;
  for (const method of ["validate", "validateSync"])
    BaseSchema.prototype[`${method}At`] = function(path, value, options = {}) {
      const {
        parent,
        parentPath,
        schema
      } = getIn(this, path, value, options.context);
      return schema[method](parent && parent[parentPath], _extends3({}, options, {
        parent,
        path
      }));
    };
  for (const alias of ["equals", "is"])
    BaseSchema.prototype[alias] = BaseSchema.prototype.oneOf;
  for (const alias of ["not", "nope"])
    BaseSchema.prototype[alias] = BaseSchema.prototype.notOneOf;
  BaseSchema.prototype.optional = BaseSchema.prototype.notRequired;

  // node_modules/yup/es/mixed.js
  var Mixed = BaseSchema;
  function create() {
    return new Mixed();
  }
  create.prototype = Mixed.prototype;

  // node_modules/yup/es/util/isAbsent.js
  var isAbsent = (value) => value == null;
  var isAbsent_default = isAbsent;

  // node_modules/yup/es/boolean.js
  function create2() {
    return new BooleanSchema();
  }
  var BooleanSchema = class extends BaseSchema {
    constructor() {
      super({
        type: "boolean"
      });
      this.withMutation(() => {
        this.transform(function(value) {
          if (!this.isType(value)) {
            if (/^(true|1)$/i.test(String(value)))
              return true;
            if (/^(false|0)$/i.test(String(value)))
              return false;
          }
          return value;
        });
      });
    }
    _typeCheck(v) {
      if (v instanceof Boolean)
        v = v.valueOf();
      return typeof v === "boolean";
    }
    isTrue(message = boolean.isValue) {
      return this.test({
        message,
        name: "is-value",
        exclusive: true,
        params: {
          value: "true"
        },
        test(value) {
          return isAbsent_default(value) || value === true;
        }
      });
    }
    isFalse(message = boolean.isValue) {
      return this.test({
        message,
        name: "is-value",
        exclusive: true,
        params: {
          value: "false"
        },
        test(value) {
          return isAbsent_default(value) || value === false;
        }
      });
    }
  };
  create2.prototype = BooleanSchema.prototype;

  // node_modules/yup/es/string.js
  var rEmail = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
  var rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
  var rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  var isTrimmed = (value) => isAbsent_default(value) || value === value.trim();
  var objStringTag = {}.toString();
  function create3() {
    return new StringSchema();
  }
  var StringSchema = class extends BaseSchema {
    constructor() {
      super({
        type: "string"
      });
      this.withMutation(() => {
        this.transform(function(value) {
          if (this.isType(value))
            return value;
          if (Array.isArray(value))
            return value;
          const strValue = value != null && value.toString ? value.toString() : value;
          if (strValue === objStringTag)
            return value;
          return strValue;
        });
      });
    }
    _typeCheck(value) {
      if (value instanceof String)
        value = value.valueOf();
      return typeof value === "string";
    }
    _isPresent(value) {
      return super._isPresent(value) && !!value.length;
    }
    length(length, message = string.length) {
      return this.test({
        message,
        name: "length",
        exclusive: true,
        params: {
          length
        },
        test(value) {
          return isAbsent_default(value) || value.length === this.resolve(length);
        }
      });
    }
    min(min, message = string.min) {
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        test(value) {
          return isAbsent_default(value) || value.length >= this.resolve(min);
        }
      });
    }
    max(max, message = string.max) {
      return this.test({
        name: "max",
        exclusive: true,
        message,
        params: {
          max
        },
        test(value) {
          return isAbsent_default(value) || value.length <= this.resolve(max);
        }
      });
    }
    matches(regex, options) {
      let excludeEmptyString = false;
      let message;
      let name;
      if (options) {
        if (typeof options === "object") {
          ({
            excludeEmptyString = false,
            message,
            name
          } = options);
        } else {
          message = options;
        }
      }
      return this.test({
        name: name || "matches",
        message: message || string.matches,
        params: {
          regex
        },
        test: (value) => isAbsent_default(value) || value === "" && excludeEmptyString || value.search(regex) !== -1
      });
    }
    email(message = string.email) {
      return this.matches(rEmail, {
        name: "email",
        message,
        excludeEmptyString: true
      });
    }
    url(message = string.url) {
      return this.matches(rUrl, {
        name: "url",
        message,
        excludeEmptyString: true
      });
    }
    uuid(message = string.uuid) {
      return this.matches(rUUID, {
        name: "uuid",
        message,
        excludeEmptyString: false
      });
    }
    ensure() {
      return this.default("").transform((val) => val === null ? "" : val);
    }
    trim(message = string.trim) {
      return this.transform((val) => val != null ? val.trim() : val).test({
        message,
        name: "trim",
        test: isTrimmed
      });
    }
    lowercase(message = string.lowercase) {
      return this.transform((value) => !isAbsent_default(value) ? value.toLowerCase() : value).test({
        message,
        name: "string_case",
        exclusive: true,
        test: (value) => isAbsent_default(value) || value === value.toLowerCase()
      });
    }
    uppercase(message = string.uppercase) {
      return this.transform((value) => !isAbsent_default(value) ? value.toUpperCase() : value).test({
        message,
        name: "string_case",
        exclusive: true,
        test: (value) => isAbsent_default(value) || value === value.toUpperCase()
      });
    }
  };
  create3.prototype = StringSchema.prototype;

  // node_modules/yup/es/number.js
  var isNaN2 = (value) => value != +value;
  function create4() {
    return new NumberSchema();
  }
  var NumberSchema = class extends BaseSchema {
    constructor() {
      super({
        type: "number"
      });
      this.withMutation(() => {
        this.transform(function(value) {
          let parsed = value;
          if (typeof parsed === "string") {
            parsed = parsed.replace(/\s/g, "");
            if (parsed === "")
              return NaN;
            parsed = +parsed;
          }
          if (this.isType(parsed))
            return parsed;
          return parseFloat(parsed);
        });
      });
    }
    _typeCheck(value) {
      if (value instanceof Number)
        value = value.valueOf();
      return typeof value === "number" && !isNaN2(value);
    }
    min(min, message = number.min) {
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        test(value) {
          return isAbsent_default(value) || value >= this.resolve(min);
        }
      });
    }
    max(max, message = number.max) {
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          max
        },
        test(value) {
          return isAbsent_default(value) || value <= this.resolve(max);
        }
      });
    }
    lessThan(less, message = number.lessThan) {
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          less
        },
        test(value) {
          return isAbsent_default(value) || value < this.resolve(less);
        }
      });
    }
    moreThan(more, message = number.moreThan) {
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          more
        },
        test(value) {
          return isAbsent_default(value) || value > this.resolve(more);
        }
      });
    }
    positive(msg = number.positive) {
      return this.moreThan(0, msg);
    }
    negative(msg = number.negative) {
      return this.lessThan(0, msg);
    }
    integer(message = number.integer) {
      return this.test({
        name: "integer",
        message,
        test: (val) => isAbsent_default(val) || Number.isInteger(val)
      });
    }
    truncate() {
      return this.transform((value) => !isAbsent_default(value) ? value | 0 : value);
    }
    round(method) {
      var _method;
      let avail = ["ceil", "floor", "round", "trunc"];
      method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
      if (method === "trunc")
        return this.truncate();
      if (avail.indexOf(method.toLowerCase()) === -1)
        throw new TypeError("Only valid options for round() are: " + avail.join(", "));
      return this.transform((value) => !isAbsent_default(value) ? Math[method](value) : value);
    }
  };
  create4.prototype = NumberSchema.prototype;

  // node_modules/yup/es/util/isodate.js
  var isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
  function parseIsoDate(date2) {
    var numericKeys = [1, 4, 5, 6, 7, 10, 11], minutesOffset = 0, timestamp, struct;
    if (struct = isoReg.exec(date2)) {
      for (var i = 0, k; k = numericKeys[i]; ++i)
        struct[k] = +struct[k] || 0;
      struct[2] = (+struct[2] || 1) - 1;
      struct[3] = +struct[3] || 1;
      struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0;
      if ((struct[8] === void 0 || struct[8] === "") && (struct[9] === void 0 || struct[9] === ""))
        timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
      else {
        if (struct[8] !== "Z" && struct[9] !== void 0) {
          minutesOffset = struct[10] * 60 + struct[11];
          if (struct[9] === "+")
            minutesOffset = 0 - minutesOffset;
        }
        timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
      }
    } else
      timestamp = Date.parse ? Date.parse(date2) : NaN;
    return timestamp;
  }

  // node_modules/yup/es/date.js
  var invalidDate = new Date("");
  var isDate = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
  function create5() {
    return new DateSchema();
  }
  var DateSchema = class extends BaseSchema {
    constructor() {
      super({
        type: "date"
      });
      this.withMutation(() => {
        this.transform(function(value) {
          if (this.isType(value))
            return value;
          value = parseIsoDate(value);
          return !isNaN(value) ? new Date(value) : invalidDate;
        });
      });
    }
    _typeCheck(v) {
      return isDate(v) && !isNaN(v.getTime());
    }
    prepareParam(ref, name) {
      let param;
      if (!Reference.isRef(ref)) {
        let cast = this.cast(ref);
        if (!this._typeCheck(cast))
          throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
        param = cast;
      } else {
        param = ref;
      }
      return param;
    }
    min(min, message = date.min) {
      let limit = this.prepareParam(min, "min");
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        test(value) {
          return isAbsent_default(value) || value >= this.resolve(limit);
        }
      });
    }
    max(max, message = date.max) {
      let limit = this.prepareParam(max, "max");
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          max
        },
        test(value) {
          return isAbsent_default(value) || value <= this.resolve(limit);
        }
      });
    }
  };
  DateSchema.INVALID_DATE = invalidDate;
  create5.prototype = DateSchema.prototype;
  create5.INVALID_DATE = invalidDate;

  // node_modules/yup/es/object.js
  var import_has3 = __toESM(require_has());
  var import_snakeCase = __toESM(require_snakeCase());
  var import_camelCase = __toESM(require_camelCase());
  var import_mapKeys = __toESM(require_mapKeys());
  var import_mapValues2 = __toESM(require_mapValues());
  var import_property_expr4 = __toESM(require_property_expr());

  // node_modules/yup/es/util/sortFields.js
  var import_has2 = __toESM(require_has());
  var import_toposort = __toESM(require_toposort());
  var import_property_expr3 = __toESM(require_property_expr());
  function sortFields(fields, excludedEdges = []) {
    let edges = [];
    let nodes = /* @__PURE__ */ new Set();
    let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));
    function addNode(depPath, key) {
      let node = (0, import_property_expr3.split)(depPath)[0];
      nodes.add(node);
      if (!excludes.has(`${key}-${node}`))
        edges.push([key, node]);
    }
    for (const key in fields)
      if ((0, import_has2.default)(fields, key)) {
        let value = fields[key];
        nodes.add(key);
        if (Reference.isRef(value) && value.isSibling)
          addNode(value.path, key);
        else if (isSchema_default(value) && "deps" in value)
          value.deps.forEach((path) => addNode(path, key));
      }
    return import_toposort.default.array(Array.from(nodes), edges).reverse();
  }

  // node_modules/yup/es/util/sortByKeyOrder.js
  function findIndex(arr, err) {
    let idx = Infinity;
    arr.some((key, ii) => {
      var _err$path;
      if (((_err$path = err.path) == null ? void 0 : _err$path.indexOf(key)) !== -1) {
        idx = ii;
        return true;
      }
    });
    return idx;
  }
  function sortByKeyOrder(keys) {
    return (a, b) => {
      return findIndex(keys, a) - findIndex(keys, b);
    };
  }

  // node_modules/yup/es/object.js
  function _extends4() {
    _extends4 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends4.apply(this, arguments);
  }
  var isObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
  function unknown(ctx, value) {
    let known = Object.keys(ctx.fields);
    return Object.keys(value).filter((key) => known.indexOf(key) === -1);
  }
  var defaultSort = sortByKeyOrder([]);
  var ObjectSchema = class extends BaseSchema {
    constructor(spec) {
      super({
        type: "object"
      });
      this.fields = /* @__PURE__ */ Object.create(null);
      this._sortErrors = defaultSort;
      this._nodes = [];
      this._excludedEdges = [];
      this.withMutation(() => {
        this.transform(function coerce2(value) {
          if (typeof value === "string") {
            try {
              value = JSON.parse(value);
            } catch (err) {
              value = null;
            }
          }
          if (this.isType(value))
            return value;
          return null;
        });
        if (spec) {
          this.shape(spec);
        }
      });
    }
    _typeCheck(value) {
      return isObject(value) || typeof value === "function";
    }
    _cast(_value, options = {}) {
      var _options$stripUnknown;
      let value = super._cast(_value, options);
      if (value === void 0)
        return this.getDefault();
      if (!this._typeCheck(value))
        return value;
      let fields = this.fields;
      let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
      let props = this._nodes.concat(Object.keys(value).filter((v) => this._nodes.indexOf(v) === -1));
      let intermediateValue = {};
      let innerOptions = _extends4({}, options, {
        parent: intermediateValue,
        __validating: options.__validating || false
      });
      let isChanged = false;
      for (const prop of props) {
        let field = fields[prop];
        let exists = (0, import_has3.default)(value, prop);
        if (field) {
          let fieldValue;
          let inputValue = value[prop];
          innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
          field = field.resolve({
            value: inputValue,
            context: options.context,
            parent: intermediateValue
          });
          let fieldSpec = "spec" in field ? field.spec : void 0;
          let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
          if (fieldSpec == null ? void 0 : fieldSpec.strip) {
            isChanged = isChanged || prop in value;
            continue;
          }
          fieldValue = !options.__validating || !strict ? field.cast(value[prop], innerOptions) : value[prop];
          if (fieldValue !== void 0) {
            intermediateValue[prop] = fieldValue;
          }
        } else if (exists && !strip) {
          intermediateValue[prop] = value[prop];
        }
        if (intermediateValue[prop] !== value[prop]) {
          isChanged = true;
        }
      }
      return isChanged ? intermediateValue : value;
    }
    _validate(_value, opts = {}, callback) {
      let errors = [];
      let {
        sync,
        from = [],
        originalValue = _value,
        abortEarly = this.spec.abortEarly,
        recursive = this.spec.recursive
      } = opts;
      from = [{
        schema: this,
        value: originalValue
      }, ...from];
      opts.__validating = true;
      opts.originalValue = originalValue;
      opts.from = from;
      super._validate(_value, opts, (err, value) => {
        if (err) {
          if (!ValidationError.isError(err) || abortEarly) {
            return void callback(err, value);
          }
          errors.push(err);
        }
        if (!recursive || !isObject(value)) {
          callback(errors[0] || null, value);
          return;
        }
        originalValue = originalValue || value;
        let tests = this._nodes.map((key) => (_, cb) => {
          let path = key.indexOf(".") === -1 ? (opts.path ? `${opts.path}.` : "") + key : `${opts.path || ""}["${key}"]`;
          let field = this.fields[key];
          if (field && "validate" in field) {
            field.validate(value[key], _extends4({}, opts, {
              path,
              from,
              strict: true,
              parent: value,
              originalValue: originalValue[key]
            }), cb);
            return;
          }
          cb(null);
        });
        runTests({
          sync,
          tests,
          value,
          errors,
          endEarly: abortEarly,
          sort: this._sortErrors,
          path: opts.path
        }, callback);
      });
    }
    clone(spec) {
      const next = super.clone(spec);
      next.fields = _extends4({}, this.fields);
      next._nodes = this._nodes;
      next._excludedEdges = this._excludedEdges;
      next._sortErrors = this._sortErrors;
      return next;
    }
    concat(schema) {
      let next = super.concat(schema);
      let nextFields = next.fields;
      for (let [field, schemaOrRef] of Object.entries(this.fields)) {
        const target = nextFields[field];
        if (target === void 0) {
          nextFields[field] = schemaOrRef;
        } else if (target instanceof BaseSchema && schemaOrRef instanceof BaseSchema) {
          nextFields[field] = schemaOrRef.concat(target);
        }
      }
      return next.withMutation(() => next.shape(nextFields, this._excludedEdges));
    }
    getDefaultFromShape() {
      let dft = {};
      this._nodes.forEach((key) => {
        const field = this.fields[key];
        dft[key] = "default" in field ? field.getDefault() : void 0;
      });
      return dft;
    }
    _getDefault() {
      if ("default" in this.spec) {
        return super._getDefault();
      }
      if (!this._nodes.length) {
        return void 0;
      }
      return this.getDefaultFromShape();
    }
    shape(additions, excludes = []) {
      let next = this.clone();
      let fields = Object.assign(next.fields, additions);
      next.fields = fields;
      next._sortErrors = sortByKeyOrder(Object.keys(fields));
      if (excludes.length) {
        if (!Array.isArray(excludes[0]))
          excludes = [excludes];
        next._excludedEdges = [...next._excludedEdges, ...excludes];
      }
      next._nodes = sortFields(fields, next._excludedEdges);
      return next;
    }
    pick(keys) {
      const picked = {};
      for (const key of keys) {
        if (this.fields[key])
          picked[key] = this.fields[key];
      }
      return this.clone().withMutation((next) => {
        next.fields = {};
        return next.shape(picked);
      });
    }
    omit(keys) {
      const next = this.clone();
      const fields = next.fields;
      next.fields = {};
      for (const key of keys) {
        delete fields[key];
      }
      return next.withMutation(() => next.shape(fields));
    }
    from(from, to, alias) {
      let fromGetter = (0, import_property_expr4.getter)(from, true);
      return this.transform((obj) => {
        if (obj == null)
          return obj;
        let newObj = obj;
        if ((0, import_has3.default)(obj, from)) {
          newObj = _extends4({}, obj);
          if (!alias)
            delete newObj[from];
          newObj[to] = fromGetter(obj);
        }
        return newObj;
      });
    }
    noUnknown(noAllow = true, message = object.noUnknown) {
      if (typeof noAllow === "string") {
        message = noAllow;
        noAllow = true;
      }
      let next = this.test({
        name: "noUnknown",
        exclusive: true,
        message,
        test(value) {
          if (value == null)
            return true;
          const unknownKeys = unknown(this.schema, value);
          return !noAllow || unknownKeys.length === 0 || this.createError({
            params: {
              unknown: unknownKeys.join(", ")
            }
          });
        }
      });
      next.spec.noUnknown = noAllow;
      return next;
    }
    unknown(allow = true, message = object.noUnknown) {
      return this.noUnknown(!allow, message);
    }
    transformKeys(fn) {
      return this.transform((obj) => obj && (0, import_mapKeys.default)(obj, (_, key) => fn(key)));
    }
    camelCase() {
      return this.transformKeys(import_camelCase.default);
    }
    snakeCase() {
      return this.transformKeys(import_snakeCase.default);
    }
    constantCase() {
      return this.transformKeys((key) => (0, import_snakeCase.default)(key).toUpperCase());
    }
    describe() {
      let base = super.describe();
      base.fields = (0, import_mapValues2.default)(this.fields, (value) => value.describe());
      return base;
    }
  };
  function create6(spec) {
    return new ObjectSchema(spec);
  }
  create6.prototype = ObjectSchema.prototype;

  // node_modules/yup/es/array.js
  function _extends5() {
    _extends5 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends5.apply(this, arguments);
  }
  function create7(type) {
    return new ArraySchema(type);
  }
  var ArraySchema = class extends BaseSchema {
    constructor(type) {
      super({
        type: "array"
      });
      this.innerType = void 0;
      this.innerType = type;
      this.withMutation(() => {
        this.transform(function(values) {
          if (typeof values === "string")
            try {
              values = JSON.parse(values);
            } catch (err) {
              values = null;
            }
          return this.isType(values) ? values : null;
        });
      });
    }
    _typeCheck(v) {
      return Array.isArray(v);
    }
    get _subType() {
      return this.innerType;
    }
    _cast(_value, _opts) {
      const value = super._cast(_value, _opts);
      if (!this._typeCheck(value) || !this.innerType)
        return value;
      let isChanged = false;
      const castArray = value.map((v, idx) => {
        const castElement = this.innerType.cast(v, _extends5({}, _opts, {
          path: `${_opts.path || ""}[${idx}]`
        }));
        if (castElement !== v) {
          isChanged = true;
        }
        return castElement;
      });
      return isChanged ? castArray : value;
    }
    _validate(_value, options = {}, callback) {
      var _options$abortEarly, _options$recursive;
      let errors = [];
      let sync = options.sync;
      let path = options.path;
      let innerType = this.innerType;
      let endEarly = (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly;
      let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
      let originalValue = options.originalValue != null ? options.originalValue : _value;
      super._validate(_value, options, (err, value) => {
        if (err) {
          if (!ValidationError.isError(err) || endEarly) {
            return void callback(err, value);
          }
          errors.push(err);
        }
        if (!recursive || !innerType || !this._typeCheck(value)) {
          callback(errors[0] || null, value);
          return;
        }
        originalValue = originalValue || value;
        let tests = new Array(value.length);
        for (let idx = 0; idx < value.length; idx++) {
          let item = value[idx];
          let path2 = `${options.path || ""}[${idx}]`;
          let innerOptions = _extends5({}, options, {
            path: path2,
            strict: true,
            parent: value,
            index: idx,
            originalValue: originalValue[idx]
          });
          tests[idx] = (_, cb) => innerType.validate(item, innerOptions, cb);
        }
        runTests({
          sync,
          path,
          value,
          errors,
          endEarly,
          tests
        }, callback);
      });
    }
    clone(spec) {
      const next = super.clone(spec);
      next.innerType = this.innerType;
      return next;
    }
    concat(schema) {
      let next = super.concat(schema);
      next.innerType = this.innerType;
      if (schema.innerType)
        next.innerType = next.innerType ? next.innerType.concat(schema.innerType) : schema.innerType;
      return next;
    }
    of(schema) {
      let next = this.clone();
      if (!isSchema_default(schema))
        throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
      next.innerType = schema;
      return next;
    }
    length(length, message = array.length) {
      return this.test({
        message,
        name: "length",
        exclusive: true,
        params: {
          length
        },
        test(value) {
          return isAbsent_default(value) || value.length === this.resolve(length);
        }
      });
    }
    min(min, message) {
      message = message || array.min;
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        test(value) {
          return isAbsent_default(value) || value.length >= this.resolve(min);
        }
      });
    }
    max(max, message) {
      message = message || array.max;
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          max
        },
        test(value) {
          return isAbsent_default(value) || value.length <= this.resolve(max);
        }
      });
    }
    ensure() {
      return this.default(() => []).transform((val, original) => {
        if (this._typeCheck(val))
          return val;
        return original == null ? [] : [].concat(original);
      });
    }
    compact(rejector) {
      let reject = !rejector ? (v) => !!v : (v, i, a) => !rejector(v, i, a);
      return this.transform((values) => values != null ? values.filter(reject) : values);
    }
    describe() {
      let base = super.describe();
      if (this.innerType)
        base.innerType = this.innerType.describe();
      return base;
    }
    nullable(isNullable = true) {
      return super.nullable(isNullable);
    }
    defined() {
      return super.defined();
    }
    required(msg) {
      return super.required(msg);
    }
  };
  create7.prototype = ArraySchema.prototype;

  // build/index.js
  var import_react5 = __toESM(require_react());
  var __defProp2 = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp2.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var entry_server_exports = {};
  __export2(entry_server_exports, {
    default: () => handleRequest
  });
  function handleRequest(request, responseStatusCode, responseHeaders, remixContext) {
    const markup = (0, import_server.renderToString)(/* @__PURE__ */ React3.createElement(import_react3.RemixServer, {
      context: remixContext,
      url: request.url
    }));
    responseHeaders.set("Content-Type", "text/html");
    return new Response("<!DOCTYPE html>" + markup, {
      status: responseStatusCode,
      headers: responseHeaders
    });
  }
  var root_exports = {};
  __export2(root_exports, {
    default: () => App,
    links: () => links,
    meta: () => meta
  });
  function Footer() {
    return /* @__PURE__ */ React3.createElement("div", {
      className: "static bottom-0 flex flex-row w-full justify-center  border-black border-t-2 mt-48 bg-white p-4"
    }, /* @__PURE__ */ React3.createElement(import_react3.Link, {
      className: "mr-10 text-orange-500 underline underline-offset-2",
      to: "/impressum"
    }, "Impressum"), /* @__PURE__ */ React3.createElement(import_react3.Link, {
      className: "mr-10 text-orange-500 underline underline-offset-2",
      to: "tos"
    }, "Terms of Service"), /* @__PURE__ */ React3.createElement(import_react3.Link, {
      className: "mr-10 text-orange-500 underline underline-offset-2",
      to: "privacy"
    }, "Privacy Policy"));
  }
  var Footer_default = Footer;
  function Navbar({ children }) {
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement("header", {
      className: "flex justify-center"
    }, /* @__PURE__ */ React3.createElement("nav", {
      className: "flex justify-between md:w-full  lg:max-w-[1400px] p-4"
    }, /* @__PURE__ */ React3.createElement(import_react3.Link, {
      to: "/"
    }, /* @__PURE__ */ React3.createElement("h1", {
      className: "font-bold text-4xl tracking-tighter text-slate-800 "
    }, "Mocka.")))), /* @__PURE__ */ React3.createElement("main", {
      className: "flex justify-center"
    }, /* @__PURE__ */ React3.createElement("div", {
      className: "w-full"
    }, children)), /* @__PURE__ */ React3.createElement(Footer_default, null));
  }
  var Layout_default = Navbar;
  var app_default = "/build/_assets/app-U2UFYTC7.css";
  var meta = () => ({ title: "Mock - Prototyping fast and easy" });
  function links() {
    return [{ rel: "stylesheet", href: app_default }];
  }
  function App() {
    return /* @__PURE__ */ React3.createElement("html", {
      lang: "en"
    }, /* @__PURE__ */ React3.createElement("head", null, /* @__PURE__ */ React3.createElement("meta", {
      charSet: "utf-8"
    }), /* @__PURE__ */ React3.createElement("meta", {
      name: "viewport",
      content: "width=device-width,initial-scale=1"
    }), /* @__PURE__ */ React3.createElement(import_react3.Meta, null), /* @__PURE__ */ React3.createElement(import_react3.Links, null)), /* @__PURE__ */ React3.createElement("body", null, /* @__PURE__ */ React3.createElement(Layout_default, null, /* @__PURE__ */ React3.createElement(import_react3.Outlet, null)), /* @__PURE__ */ React3.createElement(import_react3.ScrollRestoration, null), /* @__PURE__ */ React3.createElement(import_react3.Scripts, null), /* @__PURE__ */ React3.createElement(import_react3.LiveReload, null)));
  }
  var routes_exports = {};
  __export2(routes_exports, {
    default: () => Index
  });
  function Index() {
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement("div", {
      className: "background"
    }), /* @__PURE__ */ React3.createElement("div", {
      className: "flex flex-col justify-center mt-56 items-center relative  text-slate-700 "
    }, /* @__PURE__ */ React3.createElement("div", {
      className: "flex flex-col"
    }, /* @__PURE__ */ React3.createElement("h1", {
      className: "text-5xl underline underline-offset-4 font-bold"
    }, "Fast prototyping for developers"), /* @__PURE__ */ React3.createElement("p", {
      style: {
        textShadow: `
   -1px -1px 0 #fff,  
    1px -1px 0 #fff,
    -1px 1px 0 #fff,
     1px 1px 0 #fff`
      },
      className: "mt-6 ml-2 max-w-[55ch] text-xl font-semibold"
    }, "Easily create free HTTP Endpoints in a matter of seconds and save precious time to validate your ideas."), /* @__PURE__ */ React3.createElement("div", {
      className: "mt-12 ml-2 flex"
    }, /* @__PURE__ */ React3.createElement(import_react3.Link, {
      className: "p-4 w-[200px] text-orange-500 bg-white border-4 border-orange-500 rounded-lg border-dotted transition duration-300 transform active:scale-95 ease-in-out  text-xl flex flex-row items-center justify-center font-semibold hover:scale-95  focus:outline-none",
      to: "/new"
    }, "Get Started", " ", /* @__PURE__ */ React3.createElement(TiArrowRightThick, {
      className: "ml-2 text-2xl"
    }))))), /* @__PURE__ */ React3.createElement("div", {
      className: "text-lg flex justify-center w-full ",
      style: { marginTop: "300px" }
    }, /* @__PURE__ */ React3.createElement("div", {
      className: "mt-24 w-3/4 xl:w-1/2"
    }, /* @__PURE__ */ React3.createElement("div", {
      style: { width: "fit-content" },
      className: "bg-white rounded-xl p-8 shadow-2xl "
    }, /* @__PURE__ */ React3.createElement("h3", {
      className: "text-3xl font-semibold text-slate-600 mb-3"
    }, "What is Mocka?"), /* @__PURE__ */ React3.createElement("p", {
      style: { maxWidth: "55ch" },
      className: "text-gray-700"
    }, "Mocka helps you prototype faster than usual. Instead of wasting time, creating a HTTP Server to serve dummy content you can just spin-up an Endpoint in a couple clicks to do it for you.")), /* @__PURE__ */ React3.createElement("div", {
      className: "mt-24 w-full flex items-end flex-col"
    }, /* @__PURE__ */ React3.createElement("div", {
      className: "bg-white rounded-xl shadow-2xl p-8"
    }, /* @__PURE__ */ React3.createElement("h3", {
      className: "text-3xl flex flex-row items-center font-semibold text-slate-600 mb-3"
    }, /* @__PURE__ */ React3.createElement(AiFillSave, {
      className: "mr-2"
    }), "Caching"), /* @__PURE__ */ React3.createElement("p", {
      style: { maxWidth: "55ch" },
      className: "text-gray-700"
    }, "Mocka caches your API Endpoints for a long long time. This ensures that your responses will be fast and predictable, saving precious time that would be otherwise wasted."))), /* @__PURE__ */ React3.createElement("div", {
      className: "mt-24"
    }, /* @__PURE__ */ React3.createElement("div", {
      className: "bg-white rounded-xl shadow-2xl p-8",
      style: { width: "fit-content" }
    }, /* @__PURE__ */ React3.createElement("h3", {
      className: "text-3xl flex flex-row items-center font-semibold text-slate-600 mb-3"
    }, /* @__PURE__ */ React3.createElement(HiTrendingDown, {
      className: "mr-2"
    }), "Low Latency"), /* @__PURE__ */ React3.createElement("p", {
      style: { maxWidth: "55ch" },
      className: "text-gray-700"
    }, "Additionally, your Endpoints are executed on the Edge using Cloudflare Workers. Providing you with low latency wherever you may be."))))));
  }
  var new_exports = {};
  __export2(new_exports, {
    action: () => action,
    default: () => Index2,
    headers: () => headers
  });
  var httpMethodRegex = /^(GET|POST|PATCH|PUT|DELETE)$/g;
  var contentTypes = ["application/json", "text/plain"];
  var contentTypesRegex = new RegExp(contentTypes.join("|"), "g");
  var EndpointSchema = create6().shape({
    status: create4().typeError("Status must be a number").min(200, "Status must be greater than 100").max(599, "Status must be less than 599").required("Status is required"),
    method: create3().required("Method is required").matches(httpMethodRegex, "Method must be a valid HTTP method"),
    contentType: create3().matches(contentTypesRegex, "Content-Type is not valid").required("Content-Type is required"),
    headers: create7(create6({
      key: create3().required("Header key is required"),
      value: create3().required("Header value is required")
    })).optional().nullable().default(null),
    body: create3().when("contentType", {
      is: "application/json",
      then: (schema) => schema.test("is-json", "Please use valid JSON.", function t(value) {
        try {
          JSON.parse(value || "");
          return true;
        } catch (error) {
          const { path, createError } = this;
          return createError({ path, message: "Please use valid JSON." });
        }
      }),
      otherwise: (schema) => schema
    }).optional().nullable().default(null)
  });
  var formatHeaders = (headers2) => {
    if (!headers2)
      return void 0;
    return headers2.reduce((acc, header) => {
      acc[header.key] = header.value;
      return acc;
    }, {});
  };
  function Container(_a) {
    var _b = _a, { children, className } = _b, props = __objRest(_b, ["children", "className"]);
    return /* @__PURE__ */ React3.createElement("div", __spreadProps(__spreadValues({}, props), {
      className: clsx_m_default("p-8 w-3/4 mb-20 max-w-[1000px] rounded-lg shadow-lg bg-white  border-gray-100 border-2", className)
    }), children);
  }
  var Container_default = Container;
  var validator = withYup(EndpointSchema);
  async function action({ request }) {
    try {
      const fieldValues = await validator.validate(await request.formData());
      if (fieldValues.error)
        return (0, import_remix_validated_form2.validationError)(fieldValues.error);
      const headersObj = formatHeaders(fieldValues.data.headers);
      const payload = __spreadProps(__spreadValues({}, fieldValues.data), {
        headers: headersObj
      });
      const hash = (0, import_spark_md5.hash)(JSON.stringify(payload));
      await MOCKA_STORE.put(hash, JSON.stringify(payload));
      return (0, import_server_runtime.redirect)(`/out#${hash}`);
    } catch (error) {
      return new Response(error.message, { status: 500 });
    }
  }
  function headers() {
    return { "Cache-Control": "max-age=604800, s-maxage=604800" };
  }
  function Input(_a) {
    var _b = _a, {
      children,
      name,
      className
    } = _b, props = __objRest(_b, [
      "children",
      "name",
      "className"
    ]);
    const { error, getInputProps } = (0, import_remix_validated_form2.useField)(name);
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement("input", __spreadProps(__spreadValues({
      className: clsx_m_default(className, error ? "border-red-500" : "border-gray-300")
    }, getInputProps(__spreadValues({}, props))), {
      name
    })), error && /* @__PURE__ */ React3.createElement("span", {
      className: "text-red-500 text-sm italic"
    }, error));
  }
  function Textarea(_a) {
    var _b = _a, { children, name } = _b, props = __objRest(_b, ["children", "name"]);
    const { error, getInputProps } = (0, import_remix_validated_form2.useField)(name, {
      validationBehavior: {
        initial: "onBlur",
        whenSubmitted: "onBlur",
        whenTouched: "onBlur"
      }
    });
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, error && /* @__PURE__ */ React3.createElement("span", {
      className: "text-red-500 text-sm italic"
    }, error), /* @__PURE__ */ React3.createElement("textarea", __spreadProps(__spreadValues({}, getInputProps(__spreadValues({}, props))), {
      name
    })));
  }
  function Submit() {
    const { isSubmitting } = (0, import_remix_validated_form2.useFormContext)();
    return /* @__PURE__ */ React3.createElement("button", {
      className: "flex items-center px-5 py-2.5 font-medium tracking-wide text-white capitalize   bg-blue-800 rounded-md hover:bg-blue-600  focus:outline-none focus:bg-blue-500  transition duration-300 transform active:scale-95 ease-in-out",
      type: "submit"
    }, isSubmitting ? "Saving..." : "Save");
  }
  var counter = 0;
  var idPrefix = "header";
  function Index2() {
    const [headerList, setHeaders] = (0, import_react4.useState)([]);
    const handleAddHeader = (e) => {
      e.preventDefault();
      counter += 1;
      setHeaders((prev) => [...prev, `${idPrefix}-${counter}`]);
    };
    const handleDeleteHeader = (e, key) => {
      e.preventDefault();
      setHeaders((prev) => prev.filter((h) => h !== key));
    };
    return /* @__PURE__ */ React3.createElement("div", {
      className: "flex justify-center"
    }, /* @__PURE__ */ React3.createElement(Container_default, {
      className: "mt-32 ml-8"
    }, /* @__PURE__ */ React3.createElement(import_remix_validated_form2.ValidatedForm, {
      noValidate: true,
      id: "new-endpoint-form",
      validator,
      method: "post"
    }, /* @__PURE__ */ React3.createElement("fieldset", null, /* @__PURE__ */ React3.createElement("h1", {
      className: "font-bold text-3xl mb-10 text-slate-500"
    }, "Create your Endpoint", /* @__PURE__ */ React3.createElement("span", {
      className: "text-orange-400 text-5xl h-2"
    }, "."), " "), /* @__PURE__ */ React3.createElement("div", {
      className: "flex flex-row justify-between"
    }, /* @__PURE__ */ React3.createElement("div", {
      className: "flex flex-col mr-10"
    }, /* @__PURE__ */ React3.createElement("label", {
      className: "font-semibold text-gray-600",
      htmlFor: "status"
    }, "Status:"), /* @__PURE__ */ React3.createElement(Input, {
      id: "status",
      placeholder: "200",
      className: "text-black text-center border max-w-[90px] min-w-[90px] border-gray-300 placeholder-gray-600 w-full px-4 py-2.5 mt-2 text-base   transition duration-500 ease-in-out transform  rounded-md bg-gray-100  focus:border-blueGray-500 focus:bg-white dark:focus:bg-gray-800 focus:outline-none focus:shadow-outline focus:ring-2 ring-offset-current ring-blue-400",
      type: "number",
      min: 200,
      max: 599,
      name: "status"
    })), /* @__PURE__ */ React3.createElement("div", {
      className: "flex flex-col mr-10"
    }, /* @__PURE__ */ React3.createElement("label", {
      className: "font-semibold text-gray-600",
      htmlFor: "method"
    }, "Method:"), /* @__PURE__ */ React3.createElement("select", {
      className: "rounded-md min-w-[100px] mt-2 px-2 py-3 text-center text-black border border-gray-300 placeholder-gray-600 w-full  text-base   transition duration-500 ease-in-out transform bg-gray-100  focus:border-blueGray-500 focus:bg-white dark:focus:bg-gray-800 focus:outline-none focus:shadow-outline focus:border-blue-400",
      placeholder: "GET",
      name: "method"
    }, /* @__PURE__ */ React3.createElement("option", {
      value: "GET"
    }, "GET"), /* @__PURE__ */ React3.createElement("option", {
      value: "POST"
    }, "POST"), /* @__PURE__ */ React3.createElement("option", {
      value: "PUT"
    }, "PUT"), /* @__PURE__ */ React3.createElement("option", {
      value: "DELETE"
    }, "DELETE"), /* @__PURE__ */ React3.createElement("option", {
      value: "PATCH"
    }, "PATCH"))), /* @__PURE__ */ React3.createElement("div", {
      className: "w-full flex flex-col"
    }, /* @__PURE__ */ React3.createElement("label", {
      className: "text-gray-600 font-semibold",
      htmlFor: "contentType"
    }, "Content-Type:"), /* @__PURE__ */ React3.createElement(Input, {
      id: "contentType",
      placeholder: "text/plain",
      className: "text-black border border-gray-300 placeholder-gray-600 w-full px-4 py-2.5 mt-2 text-base   transition duration-500 ease-in-out transform  rounded-md bg-gray-100  focus:border-blueGray-500 focus:bg-white dark:focus:bg-gray-800 focus:outline-none focus:shadow-outline focus:border-blue-400",
      list: "contentTypes",
      type: "text",
      autoComplete: "on",
      name: "contentType"
    }), /* @__PURE__ */ React3.createElement("datalist", {
      id: "contentTypes"
    }, /* @__PURE__ */ React3.createElement("option", {
      "aria-label": "application/json",
      value: "application/json"
    }), /* @__PURE__ */ React3.createElement("option", {
      "aria-label": "text/plain",
      value: "text/plain"
    })))), /* @__PURE__ */ React3.createElement("div", {
      className: "flex flex-col mt-5"
    }, /* @__PURE__ */ React3.createElement("div", {
      className: "flex justify-between items-center"
    }, /* @__PURE__ */ React3.createElement("span", {
      className: "font-semibold text-gray-600"
    }, "Headers"), /* @__PURE__ */ React3.createElement("button", {
      type: "button",
      onClick: handleAddHeader,
      className: "flex items-center hover:bg-gray-100 hover:text-gray-700 rounded-md px-2  transition duration-300 transform active:scale-95 ease-in-out"
    }, /* @__PURE__ */ React3.createElement(TiPlus, null), " ", "Add Header")), headerList.map((key, index) => /* @__PURE__ */ React3.createElement("div", {
      key,
      className: "mt-2 flex flex-row "
    }, /* @__PURE__ */ React3.createElement("div", {
      className: "mr-2 flex flex-col w-full"
    }, /* @__PURE__ */ React3.createElement(Input, {
      placeholder: "Key",
      className: " text-black border border-gray-300 placeholder-gray-600 w-full px-4 py-2.5  text-base   transition duration-500 ease-in-out transform  rounded-lg bg-gray-100  focus:border-blueGray-500 focus:bg-white dark:focus:bg-gray-800 focus:outline-none focus:shadow-outline focus:border-blue-400",
      type: "text",
      name: `headers[${index}].key`
    })), /* @__PURE__ */ React3.createElement("div", {
      className: "flex flex-col w-full"
    }, /* @__PURE__ */ React3.createElement(Input, {
      placeholder: "Value",
      className: "text-black border border-gray-300 placeholder-gray-600 w-full px-4 py-2.5  text-base   transition duration-500 ease-in-out transform  rounded-lg bg-gray-100  focus:border-blueGray-500 focus:bg-white dark:focus:bg-gray-800 focus:outline-none focus:shadow-outline focus:border-blue-400",
      type: "text",
      name: `headers[${index}].value`
    })), /* @__PURE__ */ React3.createElement("button", {
      "aria-label": "Save",
      type: "button",
      onClick: (e) => handleDeleteHeader(e, key),
      className: "ml-3 text-3xl flex mt-2 text-red-400"
    }, /* @__PURE__ */ React3.createElement(TiDeleteOutline, null))))), /* @__PURE__ */ React3.createElement("div", {
      className: "flex flex-col mt-5"
    }, /* @__PURE__ */ React3.createElement("label", {
      className: "text-gray-600 font-semibold",
      htmlFor: "body"
    }, "Body:"), /* @__PURE__ */ React3.createElement(Textarea, {
      className: "text-black border border-gray-300 placeholder-gray-600 w-full px-4 py-2.5 mt-2 text-base   transition duration-500 ease-in-out transform  rounded-lg bg-gray-100  focus:border-blueGray-500 focus:bg-white dark:focus:bg-gray-800 focus:outline-none focus:shadow-outline focus:border-blue-400 resize-none ",
      name: "body"
    })), /* @__PURE__ */ React3.createElement("div", {
      className: "mt-5 flex justify-end"
    }, /* @__PURE__ */ React3.createElement(Submit, null))))));
  }
  var out_exports = {};
  __export2(out_exports, {
    default: () => out_default
  });
  function Out() {
    const location = (0, import_react3.useLocation)();
    const [url, setUrl] = (0, import_react5.useState)("");
    const urlRef = (0, import_react5.useRef)(null);
    const addToClipboard = () => {
      const content = urlRef.current;
      content == null ? void 0 : content.select();
      document.execCommand("copy");
    };
    (0, import_react5.useEffect)(() => {
      const hash = location.hash.replace("#", "");
      const API_URL = `https://api.mocka.io/${hash}`;
      setUrl(API_URL);
    }, [location.hash]);
    return /* @__PURE__ */ React3.createElement("div", {
      className: "flex flex-row justify-center"
    }, /* @__PURE__ */ React3.createElement("input", {
      readOnly: true,
      value: url,
      ref: urlRef,
      className: "border bg-white border-b-4 shadow-md font-medium rounded-sm py-3 px-6 flex items-center outline-none focus:ring-2 focus:ring-blue-500"
    }), /* @__PURE__ */ React3.createElement("button", {
      onClick: addToClipboard,
      className: "py-3 px-6 border-b-4 rounded-sm border-slate-700 bg-slate-600 text-white font-semibold text-lg shadow-md ",
      type: "button"
    }, "Copy!"));
  }
  var out_default = Out;
  var assets_manifest_default = { "version": "896c8ac4", "entry": { "module": "/build/entry.client-FE4J5TB4.js", "imports": ["/build/_shared/chunk-CVHS5ET5.js"] }, "routes": { "root": { "id": "root", "parentId": void 0, "path": "", "index": void 0, "caseSensitive": void 0, "module": "/build/root-OAO6RH2S.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/index": { "id": "routes/index", "parentId": "root", "path": void 0, "index": true, "caseSensitive": void 0, "module": "/build/routes/index-GGXFQK2Q.js", "imports": ["/build/_shared/chunk-GUV3WVMT.js"], "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/new": { "id": "routes/new", "parentId": "root", "path": "new", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/new-5CMSXWZQ.js", "imports": ["/build/_shared/chunk-GUV3WVMT.js"], "hasAction": true, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/out": { "id": "routes/out", "parentId": "root", "path": "out", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/out-NLODIBGT.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false } }, "url": "/build/manifest-896C8AC4.js" };
  var entry = { module: entry_server_exports };
  var routes = {
    "root": {
      id: "root",
      parentId: void 0,
      path: "",
      index: void 0,
      caseSensitive: void 0,
      module: root_exports
    },
    "routes/index": {
      id: "routes/index",
      parentId: "root",
      path: void 0,
      index: true,
      caseSensitive: void 0,
      module: routes_exports
    },
    "routes/new": {
      id: "routes/new",
      parentId: "root",
      path: "new",
      index: void 0,
      caseSensitive: void 0,
      module: new_exports
    },
    "routes/out": {
      id: "routes/out",
      parentId: "root",
      path: "out",
      index: void 0,
      caseSensitive: void 0,
      module: out_exports
    }
  };

  // worker/index.js
  addEventListener("fetch", createEventHandler({ build: build_exports }));
})();
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @remix-run/cloudflare v1.6.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/cloudflare-workers v1.6.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/react v1.6.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/server-runtime v1.6.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router DOM v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
* @license React
* use-sync-external-store-shim.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
/**
* @license React
* use-sync-external-store-shim/with-selector.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
//# sourceMappingURL=worker.js.map
